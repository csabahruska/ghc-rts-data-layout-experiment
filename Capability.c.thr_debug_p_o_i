# 1 "rts/Capability.c"
# 1 "/home/csaba/haskell/grin-compiler/ghc-whole-program-compiler-project/foundation-pak/foundation-pak-ghc-9.2.7-wpc/ghc-wpc//"
# 1 "<built-in>"
#define __STDC__ 1
#define __STDC_VERSION__ 201112L
#define __STDC_UTF_16__ 1
#define __STDC_UTF_32__ 1
#define __STDC_HOSTED__ 1
#define __GNUC__ 7
#define __GNUC_MINOR__ 5
#define __GNUC_PATCHLEVEL__ 0
#define __VERSION__ "7.5.0"
#define __ATOMIC_RELAXED 0
#define __ATOMIC_SEQ_CST 5
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_CONSUME 1
#define __FINITE_MATH_ONLY__ 0
#define _LP64 1
#define __LP64__ 1
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 8
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 16
#define __SIZEOF_SIZE_T__ 8
#define __CHAR_BIT__ 8
#define __BIGGEST_ALIGNMENT__ 16
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_PDP_ENDIAN__ 3412
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __SIZEOF_POINTER__ 8
#define __SIZE_TYPE__ long unsigned int
#define __PTRDIFF_TYPE__ long int
#define __WCHAR_TYPE__ int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long int
#define __UINTMAX_TYPE__ long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ int
#define __INT64_TYPE__ long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ unsigned int
#define __UINT64_TYPE__ long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ int
#define __INT_LEAST64_TYPE__ long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ unsigned int
#define __UINT_LEAST64_TYPE__ long unsigned int
#define __INT_FAST8_TYPE__ signed char
#define __INT_FAST16_TYPE__ long int
#define __INT_FAST32_TYPE__ long int
#define __INT_FAST64_TYPE__ long int
#define __UINT_FAST8_TYPE__ unsigned char
#define __UINT_FAST16_TYPE__ long unsigned int
#define __UINT_FAST32_TYPE__ long unsigned int
#define __UINT_FAST64_TYPE__ long unsigned int
#define __INTPTR_TYPE__ long int
#define __UINTPTR_TYPE__ long unsigned int
#define __has_include(STR) __has_include__(STR)
#define __has_include_next(STR) __has_include_next__(STR)
#define __GXX_ABI_VERSION 1011
#define __SCHAR_MAX__ 0x7f
#define __SHRT_MAX__ 0x7fff
#define __INT_MAX__ 0x7fffffff
#define __LONG_MAX__ 0x7fffffffffffffffL
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __WCHAR_MAX__ 0x7fffffff
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
#define __WINT_MAX__ 0xffffffffU
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 0x7fffffffffffffffL
#define __SIZE_MAX__ 0xffffffffffffffffUL
#define __SCHAR_WIDTH__ 8
#define __SHRT_WIDTH__ 16
#define __INT_WIDTH__ 32
#define __LONG_WIDTH__ 64
#define __LONG_LONG_WIDTH__ 64
#define __WCHAR_WIDTH__ 32
#define __WINT_WIDTH__ 32
#define __PTRDIFF_WIDTH__ 64
#define __SIZE_WIDTH__ 64
#define __INTMAX_MAX__ 0x7fffffffffffffffL
#define __INTMAX_C(c) c ## L
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
#define __UINTMAX_C(c) c ## UL
#define __INTMAX_WIDTH__ 64
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __SIG_ATOMIC_WIDTH__ 32
#define __INT8_MAX__ 0x7f
#define __INT16_MAX__ 0x7fff
#define __INT32_MAX__ 0x7fffffff
#define __INT64_MAX__ 0x7fffffffffffffffL
#define __UINT8_MAX__ 0xff
#define __UINT16_MAX__ 0xffff
#define __UINT32_MAX__ 0xffffffffU
#define __UINT64_MAX__ 0xffffffffffffffffUL
#define __INT_LEAST8_MAX__ 0x7f
#define __INT8_C(c) c
#define __INT_LEAST8_WIDTH__ 8
#define __INT_LEAST16_MAX__ 0x7fff
#define __INT16_C(c) c
#define __INT_LEAST16_WIDTH__ 16
#define __INT_LEAST32_MAX__ 0x7fffffff
#define __INT32_C(c) c
#define __INT_LEAST32_WIDTH__ 32
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL
#define __INT64_C(c) c ## L
#define __INT_LEAST64_WIDTH__ 64
#define __UINT_LEAST8_MAX__ 0xff
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 0xffff
#define __UINT16_C(c) c
#define __UINT_LEAST32_MAX__ 0xffffffffU
#define __UINT32_C(c) c ## U
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL
#define __UINT64_C(c) c ## UL
#define __INT_FAST8_MAX__ 0x7f
#define __INT_FAST8_WIDTH__ 8
#define __INT_FAST16_MAX__ 0x7fffffffffffffffL
#define __INT_FAST16_WIDTH__ 64
#define __INT_FAST32_MAX__ 0x7fffffffffffffffL
#define __INT_FAST32_WIDTH__ 64
#define __INT_FAST64_MAX__ 0x7fffffffffffffffL
#define __INT_FAST64_WIDTH__ 64
#define __UINT_FAST8_MAX__ 0xff
#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL
#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL
#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL
#define __INTPTR_MAX__ 0x7fffffffffffffffL
#define __INTPTR_WIDTH__ 64
#define __UINTPTR_MAX__ 0xffffffffffffffffUL
#define __GCC_IEC_559 2
#define __GCC_IEC_559_COMPLEX 2
#define __FLT_EVAL_METHOD__ 0
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_DECIMAL_DIG__ 9
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_DECIMAL_DIG__ 17
#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)
#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)
#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 64
#define __LDBL_DIG__ 18
#define __LDBL_MIN_EXP__ (-16381)
#define __LDBL_MIN_10_EXP__ (-4931)
#define __LDBL_MAX_EXP__ 16384
#define __LDBL_MAX_10_EXP__ 4932
#define __DECIMAL_DIG__ 21
#define __LDBL_DECIMAL_DIG__ 21
#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __FLT32_MANT_DIG__ 24
#define __FLT32_DIG__ 6
#define __FLT32_MIN_EXP__ (-125)
#define __FLT32_MIN_10_EXP__ (-37)
#define __FLT32_MAX_EXP__ 128
#define __FLT32_MAX_10_EXP__ 38
#define __FLT32_DECIMAL_DIG__ 9
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
#define __FLT32_HAS_DENORM__ 1
#define __FLT32_HAS_INFINITY__ 1
#define __FLT32_HAS_QUIET_NAN__ 1
#define __FLT64_MANT_DIG__ 53
#define __FLT64_DIG__ 15
#define __FLT64_MIN_EXP__ (-1021)
#define __FLT64_MIN_10_EXP__ (-307)
#define __FLT64_MAX_EXP__ 1024
#define __FLT64_MAX_10_EXP__ 308
#define __FLT64_DECIMAL_DIG__ 17
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
#define __FLT64_HAS_DENORM__ 1
#define __FLT64_HAS_INFINITY__ 1
#define __FLT64_HAS_QUIET_NAN__ 1
#define __FLT128_MANT_DIG__ 113
#define __FLT128_DIG__ 33
#define __FLT128_MIN_EXP__ (-16381)
#define __FLT128_MIN_10_EXP__ (-4931)
#define __FLT128_MAX_EXP__ 16384
#define __FLT128_MAX_10_EXP__ 4932
#define __FLT128_DECIMAL_DIG__ 36
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
#define __FLT128_HAS_DENORM__ 1
#define __FLT128_HAS_INFINITY__ 1
#define __FLT128_HAS_QUIET_NAN__ 1
#define __FLT32X_MANT_DIG__ 53
#define __FLT32X_DIG__ 15
#define __FLT32X_MIN_EXP__ (-1021)
#define __FLT32X_MIN_10_EXP__ (-307)
#define __FLT32X_MAX_EXP__ 1024
#define __FLT32X_MAX_10_EXP__ 308
#define __FLT32X_DECIMAL_DIG__ 17
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
#define __FLT32X_HAS_DENORM__ 1
#define __FLT32X_HAS_INFINITY__ 1
#define __FLT32X_HAS_QUIET_NAN__ 1
#define __FLT64X_MANT_DIG__ 64
#define __FLT64X_DIG__ 18
#define __FLT64X_MIN_EXP__ (-16381)
#define __FLT64X_MIN_10_EXP__ (-4931)
#define __FLT64X_MAX_EXP__ 16384
#define __FLT64X_MAX_10_EXP__ 4932
#define __FLT64X_DECIMAL_DIG__ 21
#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
#define __FLT64X_HAS_DENORM__ 1
#define __FLT64X_HAS_INFINITY__ 1
#define __FLT64X_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __GNUC_STDC_INLINE__ 1
#define __NO_INLINE__ 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SSP_STRONG__ 3
#define __SIZEOF_INT128__ 16
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 8
#define __amd64 1
#define __amd64__ 1
#define __x86_64 1
#define __x86_64__ 1
#define __SIZEOF_FLOAT80__ 16
#define __SIZEOF_FLOAT128__ 16
#define __ATOMIC_HLE_ACQUIRE 65536
#define __ATOMIC_HLE_RELEASE 131072
#define __GCC_ASM_FLAG_OUTPUTS__ 1
#define __k8 1
#define __k8__ 1
#define __code_model_small__ 1
#define __MMX__ 1
#define __SSE__ 1
#define __SSE2__ 1
#define __FXSR__ 1
#define __SSE_MATH__ 1
#define __SSE2_MATH__ 1
#define __SEG_FS 1
#define __SEG_GS 1
#define __gnu_linux__ 1
#define __linux 1
#define __linux__ 1
#define linux 1
#define __unix 1
#define __unix__ 1
#define unix 1
#define __ELF__ 1
#define __DECIMAL_BID_FORMAT__ 1
# 1 "<command-line>"
#define THREADED_RTS 1
#define DEBUG 1
#define DEBUG 1
#define TRACING 1
#define PROFILING 1
#define RtsWay "rts_thr_debug_p"
#define FS_NAMESPACE rts
#define COMPILING_RTS 1
#define PROFILING 1
#define THREADED_RTS 1
#define TRACING 1
#define PROFILING 1
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 19 "/usr/include/stdc-predef.h" 3 4
#define _STDC_PREDEF_H 1
# 38 "/usr/include/stdc-predef.h" 3 4
#define __STDC_IEC_559__ 1







#define __STDC_IEC_559_COMPLEX__ 1
# 55 "/usr/include/stdc-predef.h" 3 4
#define __STDC_ISO_10646__ 201505L


#define __STDC_NO_THREADS__ 1
# 1 "<command-line>" 2
# 1 "/home/csaba/haskell/grin-compiler/ghc-whole-program-compiler-project/foundation-pak/foundation-pak-ghc-9.2.7-wpc/ghc-wpc/_build/stage1/lib/ghcversion.h" 1

#define __GHCVERSION_H__ 


#define __GLASGOW_HASKELL__ 902


#define __GLASGOW_HASKELL_FULL_VERSION__ "9.2.7"


#define __GLASGOW_HASKELL_PATCHLEVEL1__ 7

#define MIN_VERSION_GLASGOW_HASKELL(ma,mi,pl1,pl2) ( ((ma)*100+(mi)) < __GLASGOW_HASKELL__ || ((ma)*100+(mi)) == __GLASGOW_HASKELL__ && (pl1) < __GLASGOW_HASKELL_PATCHLEVEL1__ || ((ma)*100+(mi)) == __GLASGOW_HASKELL__ && (pl1) == __GLASGOW_HASKELL_PATCHLEVEL1__ && (pl2) <= __GLASGOW_HASKELL_PATCHLEVEL2__ )
# 1 "<command-line>" 2
# 1 "./_build/stage1/rts/build/autogen/cabal_macros.h" 1




#define VERSION_rts "1.0.2"


#define MIN_VERSION_rts(major1,major2,minor) ( (major1) < 1 || (major1) == 1 && (major2) < 0 || (major1) == 1 && (major2) == 0 && (minor) <= 2)







#define TOOL_VERSION_alex "3.2.6"


#define MIN_TOOL_VERSION_alex(major1,major2,minor) ( (major1) < 3 || (major1) == 3 && (major2) < 2 || (major1) == 3 && (major2) == 2 && (minor) <= 6)







#define TOOL_VERSION_cpphs "1.19.3"


#define MIN_TOOL_VERSION_cpphs(major1,major2,minor) ( (major1) < 1 || (major1) == 1 && (major2) < 19 || (major1) == 1 && (major2) == 19 && (minor) <= 3)







#define TOOL_VERSION_gcc "7"


#define MIN_TOOL_VERSION_gcc(major1,major2,minor) ( (major1) < 7 || (major1) == 7 && (major2) < 0 || (major1) == 7 && (major2) == 0 && (minor) <= 0)







#define TOOL_VERSION_ghc "9.2.7"


#define MIN_TOOL_VERSION_ghc(major1,major2,minor) ( (major1) < 9 || (major1) == 9 && (major2) < 2 || (major1) == 9 && (major2) == 2 && (minor) <= 7)







#define TOOL_VERSION_ghc_pkg "9.2.7"


#define MIN_TOOL_VERSION_ghc_pkg(major1,major2,minor) ( (major1) < 9 || (major1) == 9 && (major2) < 2 || (major1) == 9 && (major2) == 2 && (minor) <= 7)







#define TOOL_VERSION_haddock "2.26.0"


#define MIN_TOOL_VERSION_haddock(major1,major2,minor) ( (major1) < 2 || (major1) == 2 && (major2) < 26 || (major1) == 2 && (major2) == 26 && (minor) <= 0)







#define TOOL_VERSION_happy "1.20.0"


#define MIN_TOOL_VERSION_happy(major1,major2,minor) ( (major1) < 1 || (major1) == 1 && (major2) < 20 || (major1) == 1 && (major2) == 20 && (minor) <= 0)







#define TOOL_VERSION_hpc "0.68"


#define MIN_TOOL_VERSION_hpc(major1,major2,minor) ( (major1) < 0 || (major1) == 0 && (major2) < 68 || (major1) == 0 && (major2) == 68 && (minor) <= 0)







#define TOOL_VERSION_hsc2hs "0.68.8"


#define MIN_TOOL_VERSION_hsc2hs(major1,major2,minor) ( (major1) < 0 || (major1) == 0 && (major2) < 68 || (major1) == 0 && (major2) == 68 && (minor) <= 8)







#define TOOL_VERSION_pkg_config "0.28"


#define MIN_TOOL_VERSION_pkg_config(major1,major2,minor) ( (major1) < 0 || (major1) == 0 && (major2) < 28 || (major1) == 0 && (major2) == 28 && (minor) <= 0)







#define TOOL_VERSION_runghc "8.10.4"


#define MIN_TOOL_VERSION_runghc(major1,major2,minor) ( (major1) < 8 || (major1) == 8 && (major2) < 10 || (major1) == 8 && (major2) == 10 && (minor) <= 4)







#define TOOL_VERSION_strip "2.26"


#define MIN_TOOL_VERSION_strip(major1,major2,minor) ( (major1) < 2 || (major1) == 2 && (major2) < 26 || (major1) == 2 && (major2) == 26 && (minor) <= 0)






#define CURRENT_PACKAGE_KEY "rts-1.0.2"


#define CURRENT_COMPONENT_ID "rts-1.0.2"


#define CURRENT_PACKAGE_VERSION "1.0.2"
# 1 "<command-line>" 2
# 1 "rts/Capability.c"
# 19 "rts/Capability.c"
# 1 "rts/PosixSource.h" 1
# 9 "rts/PosixSource.h"
       

# 1 "_build/stage1/lib/ghcplatform.h" 1

#define __GHCPLATFORM_H__ 

#define GHC_STAGE 2

#define BuildPlatform_TYPE x86_64_unknown_linux
#define HostPlatform_TYPE x86_64_unknown_linux

#define x86_64_unknown_linux_BUILD 1
#define x86_64_unknown_linux_HOST 1

#define x86_64_BUILD_ARCH 1
#define x86_64_HOST_ARCH 1
#define BUILD_ARCH "x86_64"
#define HOST_ARCH "x86_64"

#define linux_BUILD_OS 1
#define linux_HOST_OS 1
#define BUILD_OS "linux"
#define HOST_OS "linux"

#define unknown_BUILD_VENDOR 1
#define unknown_HOST_VENDOR 1
#define BUILD_VENDOR "unknown"
#define HOST_VENDOR "unknown"
# 12 "rts/PosixSource.h" 2
# 36 "rts/PosixSource.h"
#define _POSIX_C_SOURCE 200809L
#define _XOPEN_SOURCE 700
# 20 "rts/Capability.c" 2
# 1 "includes/Rts.h" 1
# 13 "includes/Rts.h"
       






# 1 "includes/ghcconfig.h" 1
       

# 1 "_build/stage1/lib/ghcautoconf.h" 1

#define __GHCAUTOCONF_H__ 







#define ALIGNMENT_CHAR 1


#define ALIGNMENT_DOUBLE 8


#define ALIGNMENT_FLOAT 4


#define ALIGNMENT_INT 4


#define ALIGNMENT_INT16_T 2


#define ALIGNMENT_INT32_T 4


#define ALIGNMENT_INT64_T 8


#define ALIGNMENT_INT8_T 1


#define ALIGNMENT_LONG 8


#define ALIGNMENT_LONG_LONG 8


#define ALIGNMENT_SHORT 2


#define ALIGNMENT_UINT16_T 2


#define ALIGNMENT_UINT32_T 4


#define ALIGNMENT_UINT64_T 8


#define ALIGNMENT_UINT8_T 1


#define ALIGNMENT_UNSIGNED_CHAR 1


#define ALIGNMENT_UNSIGNED_INT 4


#define ALIGNMENT_UNSIGNED_LONG 8


#define ALIGNMENT_UNSIGNED_LONG_LONG 8


#define ALIGNMENT_UNSIGNED_SHORT 2


#define ALIGNMENT_VOID_P 8





#define CC_SUPPORTS_TLS 1
# 94 "_build/stage1/lib/ghcautoconf.h"
#define HAS_VISIBILITY_HIDDEN 1


#define HAVE_ALLOCA 1



#define HAVE_ALLOCA_H 1





#define HAVE_C11_ATOMICS 1


#define HAVE_CLOCK_GETTIME 1


#define HAVE_CTIME_R 1


#define HAVE_CTYPE_H 1



#define HAVE_DECL_CTIME_R 1



#define HAVE_DECL_ENVIRON 1



#define HAVE_DECL_MADV_DONTNEED 1



#define HAVE_DECL_MADV_FREE 0



#define HAVE_DECL_MAP_NORESERVE 1


#define HAVE_DIRENT_H 1


#define HAVE_DLFCN_H 1


#define HAVE_DLINFO 1





#define HAVE_ERRNO_H 1


#define HAVE_EVENTFD 1


#define HAVE_FCNTL_H 1





#define HAVE_FORK 1
# 172 "_build/stage1/lib/ghcautoconf.h"
#define HAVE_GETRUSAGE 1


#define HAVE_GETTIMEOFDAY 1


#define HAVE_GRP_H 1


#define HAVE_INTTYPES_H 1





#define HAVE_LIBDL 1





#define HAVE_LIBM 1


#define HAVE_LIBNUMA 0


#define HAVE_LIBPTHREAD 1


#define HAVE_LIBRT 1


#define HAVE_LIMITS_H 1


#define HAVE_LOCALE_H 1


#define HAVE_LONG_LONG 1


#define HAVE_MEMORY_H 1





#define HAVE_NLIST_H 1
# 229 "_build/stage1/lib/ghcautoconf.h"
#define HAVE_PRINTF_LDBLSTUB 0





#define HAVE_PTHREAD_H 1





#define HAVE_PTHREAD_SETNAME_NP 1
# 250 "_build/stage1/lib/ghcautoconf.h"
#define HAVE_PWD_H 1


#define HAVE_SCHED_GETAFFINITY 1


#define HAVE_SCHED_H 1


#define HAVE_SCHED_SETAFFINITY 1


#define HAVE_SETITIMER 1


#define HAVE_SETLOCALE 1


#define HAVE_SIGINTERRUPT 1


#define HAVE_SIGNAL_H 1


#define HAVE_STDINT_H 1


#define HAVE_STDLIB_H 1


#define HAVE_STRINGS_H 1


#define HAVE_STRING_H 1





#define HAVE_SYSCONF 1
# 298 "_build/stage1/lib/ghcautoconf.h"
#define HAVE_SYS_EVENTFD_H 1


#define HAVE_SYS_MMAN_H 1


#define HAVE_SYS_PARAM_H 1


#define HAVE_SYS_RESOURCE_H 1


#define HAVE_SYS_SELECT_H 1


#define HAVE_SYS_STAT_H 1


#define HAVE_SYS_TIMEB_H 1


#define HAVE_SYS_TIMERFD_H 1





#define HAVE_SYS_TIMES_H 1


#define HAVE_SYS_TIME_H 1


#define HAVE_SYS_TYPES_H 1


#define HAVE_SYS_UTSNAME_H 1


#define HAVE_SYS_WAIT_H 1


#define HAVE_TERMIOS_H 1


#define HAVE_TIMER_SETTIME 1


#define HAVE_TIMES 1


#define HAVE_TIME_H 1


#define HAVE_UNISTD_H 1


#define HAVE_UTIME_H 1


#define HAVE_VFORK 1
# 373 "_build/stage1/lib/ghcautoconf.h"
#define HAVE_WORKING_FORK 1


#define HAVE_WORKING_VFORK 1






#define NEED_ATOMIC_LIB 0


#define NEED_PTHREAD_LIB 1
# 407 "_build/stage1/lib/ghcautoconf.h"
#define RTS_LINKER_USE_MMAP 1


#define SIZEOF_CHAR 1


#define SIZEOF_DOUBLE 8


#define SIZEOF_FLOAT 4


#define SIZEOF_INT 4


#define SIZEOF_INT16_T 2


#define SIZEOF_INT32_T 4


#define SIZEOF_INT64_T 8


#define SIZEOF_INT8_T 1


#define SIZEOF_LONG 8


#define SIZEOF_LONG_LONG 8


#define SIZEOF_SHORT 2


#define SIZEOF_UINT16_T 2


#define SIZEOF_UINT32_T 4


#define SIZEOF_UINT64_T 8


#define SIZEOF_UINT8_T 1


#define SIZEOF_UNSIGNED_CHAR 1


#define SIZEOF_UNSIGNED_INT 4


#define SIZEOF_UNSIGNED_LONG 8


#define SIZEOF_UNSIGNED_LONG_LONG 8


#define SIZEOF_UNSIGNED_SHORT 2


#define SIZEOF_VOID_P 8
# 481 "_build/stage1/lib/ghcautoconf.h"
#define STDC_HEADERS 1


#define TABLES_NEXT_TO_CODE 1


#define TIME_WITH_SYS_TIME 1


#define USE_LARGE_ADDRESS_SPACE 1


#define USE_LIBDW 0



#define _ALL_SOURCE 1



#define _GNU_SOURCE 1



#define _POSIX_PTHREAD_SEMANTICS 1



#define _TANDEM_SOURCE 1



#define __EXTENSIONS__ 1




#define USE_TIMER_CREATE 1
# 534 "_build/stage1/lib/ghcautoconf.h"
#define _DARWIN_USE_64_BIT_INODE 1
# 566 "_build/stage1/lib/ghcautoconf.h"
#define sUPPORTED_LLVM_VERSION_MAX (13)


#define sUPPORTED_LLVM_VERSION_MIN (9)
# 4 "includes/ghcconfig.h" 2
# 21 "includes/Rts.h" 2


# 1 "includes/stg/Types.h" 1
# 21 "includes/stg/Types.h"
       
# 43 "includes/stg/Types.h"
#define __STDC_LIMIT_MACROS 
# 1 "/usr/include/inttypes.h" 1 3 4
# 23 "/usr/include/inttypes.h" 3 4
#define _INTTYPES_H 1

# 1 "/usr/include/features.h" 1 3 4
# 19 "/usr/include/features.h" 3 4
#define _FEATURES_H 1
# 97 "/usr/include/features.h" 3 4
#undef __USE_ISOC11
#undef __USE_ISOC99
#undef __USE_ISOC95
#undef __USE_ISOCXX11
#undef __USE_POSIX
#undef __USE_POSIX2
#undef __USE_POSIX199309
#undef __USE_POSIX199506
#undef __USE_XOPEN
#undef __USE_XOPEN_EXTENDED
#undef __USE_UNIX98
#undef __USE_XOPEN2K
#undef __USE_XOPEN2KXSI
#undef __USE_XOPEN2K8
#undef __USE_XOPEN2K8XSI
#undef __USE_LARGEFILE
#undef __USE_LARGEFILE64
#undef __USE_FILE_OFFSET64
#undef __USE_MISC
#undef __USE_ATFILE
#undef __USE_GNU
#undef __USE_REENTRANT
#undef __USE_FORTIFY_LEVEL
#undef __KERNEL_STRICT_NAMES




#define __KERNEL_STRICT_NAMES 
# 136 "/usr/include/features.h" 3 4
#define __GNUC_PREREQ(maj,min) ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
# 158 "/usr/include/features.h" 3 4
#undef _ISOC95_SOURCE
#define _ISOC95_SOURCE 1
#undef _ISOC99_SOURCE
#define _ISOC99_SOURCE 1
#undef _ISOC11_SOURCE
#define _ISOC11_SOURCE 1
#undef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
#undef _XOPEN_SOURCE
#define _XOPEN_SOURCE 700
#undef _XOPEN_SOURCE_EXTENDED
#define _XOPEN_SOURCE_EXTENDED 1
#undef _LARGEFILE64_SOURCE
#define _LARGEFILE64_SOURCE 1
#undef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE 1
#undef _ATFILE_SOURCE
#define _ATFILE_SOURCE 1
# 187 "/usr/include/features.h" 3 4
#undef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE 1





#define __USE_ISOC11 1





#define __USE_ISOC99 1





#define __USE_ISOC95 1
# 225 "/usr/include/features.h" 3 4
#undef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
# 249 "/usr/include/features.h" 3 4
#define __USE_POSIX 1



#define __USE_POSIX2 1



#define __USE_POSIX199309 1



#define __USE_POSIX199506 1



#define __USE_XOPEN2K 1
#undef __USE_ISOC95
#define __USE_ISOC95 1
#undef __USE_ISOC99
#define __USE_ISOC99 1



#define __USE_XOPEN2K8 1
#undef _ATFILE_SOURCE
#define _ATFILE_SOURCE 1



#define __USE_XOPEN 1

#define __USE_XOPEN_EXTENDED 1
#define __USE_UNIX98 1
#undef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE 1


#define __USE_XOPEN2K8 1
#define __USE_XOPEN2K8XSI 1

#define __USE_XOPEN2K 1
#define __USE_XOPEN2KXSI 1
#undef __USE_ISOC95
#define __USE_ISOC95 1
#undef __USE_ISOC99
#define __USE_ISOC99 1
# 305 "/usr/include/features.h" 3 4
#define __USE_LARGEFILE 1



#define __USE_LARGEFILE64 1







#define __USE_MISC 1



#define __USE_ATFILE 1



#define __USE_GNU 1
# 340 "/usr/include/features.h" 3 4
#define __USE_FORTIFY_LEVEL 0
# 353 "/usr/include/features.h" 3 4
#undef __GNU_LIBRARY__
#define __GNU_LIBRARY__ 6



#define __GLIBC__ 2
#define __GLIBC_MINOR__ 23

#define __GLIBC_PREREQ(maj,min) ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))





# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define _SYS_CDEFS_H 1
# 34 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#undef __P
#undef __PMT






#define __LEAF , __leaf__
#define __LEAF_ATTR __attribute__ ((__leaf__))
# 55 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __THROW __attribute__ ((__nothrow__ __LEAF))
#define __THROWNL __attribute__ ((__nothrow__))
#define __NTH(fct) __attribute__ ((__nothrow__ __LEAF)) fct
# 82 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __P(args) args
#define __PMT(args) args




#define __CONCAT(x,y) x ## y
#define __STRING(x) #x


#define __ptr_t void *
#define __long_double_t long double







#define __BEGIN_DECLS 
#define __END_DECLS 
# 122 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __BEGIN_NAMESPACE_STD 
#define __END_NAMESPACE_STD 
#define __USING_NAMESPACE_STD(name) 
#define __BEGIN_NAMESPACE_C99 
#define __END_NAMESPACE_C99 
#define __USING_NAMESPACE_C99(name) 




#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
#define __bos0(ptr) __builtin_object_size (ptr, 0)


#define __warndecl(name,msg) extern void name (void) __attribute__((__warning__ (msg)))

#define __warnattr(msg) __attribute__((__warning__ (msg)))
#define __errordecl(name,msg) extern void name (void) __attribute__((__error__ (msg)))
# 150 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __flexarr []
# 177 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __REDIRECT(name,proto,alias) name proto __asm__ (__ASMNAME (#alias))






#define __REDIRECT_NTH(name,proto,alias) name proto __asm__ (__ASMNAME (#alias)) __THROW

#define __REDIRECT_NTHNL(name,proto,alias) name proto __asm__ (__ASMNAME (#alias)) __THROWNL


#define __ASMNAME(cname) __ASMNAME2 (__USER_LABEL_PREFIX__, cname)
#define __ASMNAME2(prefix,cname) __STRING (prefix) cname
# 211 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_malloc__ __attribute__ ((__malloc__))







#define __attribute_alloc_size__(params) __attribute__ ((__alloc_size__ params))
# 229 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_pure__ __attribute__ ((__pure__))






#define __attribute_const__ __attribute__ ((__const__))
# 245 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_used__ __attribute__ ((__used__))
#define __attribute_noinline__ __attribute__ ((__noinline__))







#define __attribute_deprecated__ __attribute__ ((__deprecated__))
# 266 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))
# 276 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __attribute_format_strfmon__(a,b) __attribute__ ((__format__ (__strfmon__, a, b)))
# 285 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __nonnull(params) __attribute__ ((__nonnull__ params))







#define __attribute_warn_unused_result__ __attribute__ ((__warn_unused_result__))
# 302 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __wur 




#define __always_inline __inline __attribute__ ((__always_inline__))







#define __attribute_artificial__ __attribute__ ((__artificial__))
# 333 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __extern_inline extern __inline __attribute__ ((__gnu_inline__))
#define __extern_always_inline extern __always_inline __attribute__ ((__gnu_inline__))
# 343 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __fortify_function __extern_always_inline __attribute_artificial__





#define __va_arg_pack() __builtin_va_arg_pack ()
#define __va_arg_pack_len() __builtin_va_arg_pack_len ()
# 370 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __restrict_arr __restrict
# 385 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __glibc_unlikely(cond) __builtin_expect ((cond), 0)
#define __glibc_likely(cond) __builtin_expect ((cond), 1)
# 410 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64





#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 411 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 432 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
#define __LDBL_REDIR1(name,proto,alias) name proto
#define __LDBL_REDIR(name,proto) name proto
#define __LDBL_REDIR1_NTH(name,proto,alias) name proto __THROW
#define __LDBL_REDIR_NTH(name,proto) name proto __THROW
#define __LDBL_REDIR_DECL(name) 

#define __REDIRECT_LDBL(name,proto,alias) __REDIRECT (name, proto, alias)
#define __REDIRECT_NTH_LDBL(name,proto,alias) __REDIRECT_NTH (name, proto, alias)
# 368 "/usr/include/features.h" 2 3 4
# 391 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 3 4
#define __stub___compat_bdflush 
#define __stub_chflags 
#define __stub_fattach 
#define __stub_fchflags 
#define __stub_fdetach 
#define __stub_getmsg 
#define __stub_gtty 
#define __stub_lchmod 
#define __stub_putmsg 
#define __stub_revoke 
#define __stub_setlogin 
#define __stub_sigreturn 
#define __stub_sstk 
#define __stub_stty 
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 392 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/inttypes.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 23 "/usr/include/stdint.h" 3 4
#define _STDINT_H 1


# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 3 4
#define _BITS_WCHAR_H 1
# 34 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 3 4
#define __WCHAR_MAX __WCHAR_MAX__







#define __WCHAR_MIN __WCHAR_MIN__
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64





#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 28 "/usr/include/stdint.h" 2 3 4







#define __int8_t_defined 

# 36 "/usr/include/stdint.h" 3 4
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;

typedef long int int64_t;







typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;
#define __uint32_t_defined 


typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;
#define __intptr_t_defined 

typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 145 "/usr/include/stdint.h" 3 4
#define __INT64_C(c) c ## L
#define __UINT64_C(c) c ## UL
# 155 "/usr/include/stdint.h" 3 4
#define INT8_MIN (-128)
#define INT16_MIN (-32767-1)
#define INT32_MIN (-2147483647-1)
#define INT64_MIN (-__INT64_C(9223372036854775807)-1)

#define INT8_MAX (127)
#define INT16_MAX (32767)
#define INT32_MAX (2147483647)
#define INT64_MAX (__INT64_C(9223372036854775807))


#define UINT8_MAX (255)
#define UINT16_MAX (65535)
#define UINT32_MAX (4294967295U)
#define UINT64_MAX (__UINT64_C(18446744073709551615))



#define INT_LEAST8_MIN (-128)
#define INT_LEAST16_MIN (-32767-1)
#define INT_LEAST32_MIN (-2147483647-1)
#define INT_LEAST64_MIN (-__INT64_C(9223372036854775807)-1)

#define INT_LEAST8_MAX (127)
#define INT_LEAST16_MAX (32767)
#define INT_LEAST32_MAX (2147483647)
#define INT_LEAST64_MAX (__INT64_C(9223372036854775807))


#define UINT_LEAST8_MAX (255)
#define UINT_LEAST16_MAX (65535)
#define UINT_LEAST32_MAX (4294967295U)
#define UINT_LEAST64_MAX (__UINT64_C(18446744073709551615))



#define INT_FAST8_MIN (-128)

#define INT_FAST16_MIN (-9223372036854775807L-1)
#define INT_FAST32_MIN (-9223372036854775807L-1)




#define INT_FAST64_MIN (-__INT64_C(9223372036854775807)-1)

#define INT_FAST8_MAX (127)

#define INT_FAST16_MAX (9223372036854775807L)
#define INT_FAST32_MAX (9223372036854775807L)




#define INT_FAST64_MAX (__INT64_C(9223372036854775807))


#define UINT_FAST8_MAX (255)

#define UINT_FAST16_MAX (18446744073709551615UL)
#define UINT_FAST32_MAX (18446744073709551615UL)




#define UINT_FAST64_MAX (__UINT64_C(18446744073709551615))




#define INTPTR_MIN (-9223372036854775807L-1)
#define INTPTR_MAX (9223372036854775807L)
#define UINTPTR_MAX (18446744073709551615UL)
# 236 "/usr/include/stdint.h" 3 4
#define INTMAX_MIN (-__INT64_C(9223372036854775807)-1)

#define INTMAX_MAX (__INT64_C(9223372036854775807))


#define UINTMAX_MAX (__UINT64_C(18446744073709551615))






#define PTRDIFF_MIN (-9223372036854775807L-1)
#define PTRDIFF_MAX (9223372036854775807L)






#define SIG_ATOMIC_MIN (-2147483647-1)
#define SIG_ATOMIC_MAX (2147483647)



#define SIZE_MAX (18446744073709551615UL)
# 273 "/usr/include/stdint.h" 3 4
#define WCHAR_MIN __WCHAR_MIN
#define WCHAR_MAX __WCHAR_MAX



#define WINT_MIN (0u)
#define WINT_MAX (4294967295u)


#define INT8_C(c) c
#define INT16_C(c) c
#define INT32_C(c) c

#define INT64_C(c) c ## L





#define UINT8_C(c) c
#define UINT16_C(c) c
#define UINT32_C(c) c ## U

#define UINT64_C(c) c ## UL






#define INTMAX_C(c) c ## L
#define UINTMAX_C(c) c ## UL
# 10 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 2 3 4



#define _GCC_WRAP_STDINT_H 
# 28 "/usr/include/inttypes.h" 2 3 4






typedef int __gwchar_t;





#define ____gwchar_t_defined 1



#define __PRI64_PREFIX "l"
#define __PRIPTR_PREFIX "l"
# 54 "/usr/include/inttypes.h" 3 4
#define PRId8 "d"
#define PRId16 "d"
#define PRId32 "d"
#define PRId64 __PRI64_PREFIX "d"

#define PRIdLEAST8 "d"
#define PRIdLEAST16 "d"
#define PRIdLEAST32 "d"
#define PRIdLEAST64 __PRI64_PREFIX "d"

#define PRIdFAST8 "d"
#define PRIdFAST16 __PRIPTR_PREFIX "d"
#define PRIdFAST32 __PRIPTR_PREFIX "d"
#define PRIdFAST64 __PRI64_PREFIX "d"


#define PRIi8 "i"
#define PRIi16 "i"
#define PRIi32 "i"
#define PRIi64 __PRI64_PREFIX "i"

#define PRIiLEAST8 "i"
#define PRIiLEAST16 "i"
#define PRIiLEAST32 "i"
#define PRIiLEAST64 __PRI64_PREFIX "i"

#define PRIiFAST8 "i"
#define PRIiFAST16 __PRIPTR_PREFIX "i"
#define PRIiFAST32 __PRIPTR_PREFIX "i"
#define PRIiFAST64 __PRI64_PREFIX "i"


#define PRIo8 "o"
#define PRIo16 "o"
#define PRIo32 "o"
#define PRIo64 __PRI64_PREFIX "o"

#define PRIoLEAST8 "o"
#define PRIoLEAST16 "o"
#define PRIoLEAST32 "o"
#define PRIoLEAST64 __PRI64_PREFIX "o"

#define PRIoFAST8 "o"
#define PRIoFAST16 __PRIPTR_PREFIX "o"
#define PRIoFAST32 __PRIPTR_PREFIX "o"
#define PRIoFAST64 __PRI64_PREFIX "o"


#define PRIu8 "u"
#define PRIu16 "u"
#define PRIu32 "u"
#define PRIu64 __PRI64_PREFIX "u"

#define PRIuLEAST8 "u"
#define PRIuLEAST16 "u"
#define PRIuLEAST32 "u"
#define PRIuLEAST64 __PRI64_PREFIX "u"

#define PRIuFAST8 "u"
#define PRIuFAST16 __PRIPTR_PREFIX "u"
#define PRIuFAST32 __PRIPTR_PREFIX "u"
#define PRIuFAST64 __PRI64_PREFIX "u"


#define PRIx8 "x"
#define PRIx16 "x"
#define PRIx32 "x"
#define PRIx64 __PRI64_PREFIX "x"

#define PRIxLEAST8 "x"
#define PRIxLEAST16 "x"
#define PRIxLEAST32 "x"
#define PRIxLEAST64 __PRI64_PREFIX "x"

#define PRIxFAST8 "x"
#define PRIxFAST16 __PRIPTR_PREFIX "x"
#define PRIxFAST32 __PRIPTR_PREFIX "x"
#define PRIxFAST64 __PRI64_PREFIX "x"


#define PRIX8 "X"
#define PRIX16 "X"
#define PRIX32 "X"
#define PRIX64 __PRI64_PREFIX "X"

#define PRIXLEAST8 "X"
#define PRIXLEAST16 "X"
#define PRIXLEAST32 "X"
#define PRIXLEAST64 __PRI64_PREFIX "X"

#define PRIXFAST8 "X"
#define PRIXFAST16 __PRIPTR_PREFIX "X"
#define PRIXFAST32 __PRIPTR_PREFIX "X"
#define PRIXFAST64 __PRI64_PREFIX "X"



#define PRIdMAX __PRI64_PREFIX "d"
#define PRIiMAX __PRI64_PREFIX "i"
#define PRIoMAX __PRI64_PREFIX "o"
#define PRIuMAX __PRI64_PREFIX "u"
#define PRIxMAX __PRI64_PREFIX "x"
#define PRIXMAX __PRI64_PREFIX "X"



#define PRIdPTR __PRIPTR_PREFIX "d"
#define PRIiPTR __PRIPTR_PREFIX "i"
#define PRIoPTR __PRIPTR_PREFIX "o"
#define PRIuPTR __PRIPTR_PREFIX "u"
#define PRIxPTR __PRIPTR_PREFIX "x"
#define PRIXPTR __PRIPTR_PREFIX "X"





#define SCNd8 "hhd"
#define SCNd16 "hd"
#define SCNd32 "d"
#define SCNd64 __PRI64_PREFIX "d"

#define SCNdLEAST8 "hhd"
#define SCNdLEAST16 "hd"
#define SCNdLEAST32 "d"
#define SCNdLEAST64 __PRI64_PREFIX "d"

#define SCNdFAST8 "hhd"
#define SCNdFAST16 __PRIPTR_PREFIX "d"
#define SCNdFAST32 __PRIPTR_PREFIX "d"
#define SCNdFAST64 __PRI64_PREFIX "d"


#define SCNi8 "hhi"
#define SCNi16 "hi"
#define SCNi32 "i"
#define SCNi64 __PRI64_PREFIX "i"

#define SCNiLEAST8 "hhi"
#define SCNiLEAST16 "hi"
#define SCNiLEAST32 "i"
#define SCNiLEAST64 __PRI64_PREFIX "i"

#define SCNiFAST8 "hhi"
#define SCNiFAST16 __PRIPTR_PREFIX "i"
#define SCNiFAST32 __PRIPTR_PREFIX "i"
#define SCNiFAST64 __PRI64_PREFIX "i"


#define SCNu8 "hhu"
#define SCNu16 "hu"
#define SCNu32 "u"
#define SCNu64 __PRI64_PREFIX "u"

#define SCNuLEAST8 "hhu"
#define SCNuLEAST16 "hu"
#define SCNuLEAST32 "u"
#define SCNuLEAST64 __PRI64_PREFIX "u"

#define SCNuFAST8 "hhu"
#define SCNuFAST16 __PRIPTR_PREFIX "u"
#define SCNuFAST32 __PRIPTR_PREFIX "u"
#define SCNuFAST64 __PRI64_PREFIX "u"


#define SCNo8 "hho"
#define SCNo16 "ho"
#define SCNo32 "o"
#define SCNo64 __PRI64_PREFIX "o"

#define SCNoLEAST8 "hho"
#define SCNoLEAST16 "ho"
#define SCNoLEAST32 "o"
#define SCNoLEAST64 __PRI64_PREFIX "o"

#define SCNoFAST8 "hho"
#define SCNoFAST16 __PRIPTR_PREFIX "o"
#define SCNoFAST32 __PRIPTR_PREFIX "o"
#define SCNoFAST64 __PRI64_PREFIX "o"


#define SCNx8 "hhx"
#define SCNx16 "hx"
#define SCNx32 "x"
#define SCNx64 __PRI64_PREFIX "x"

#define SCNxLEAST8 "hhx"
#define SCNxLEAST16 "hx"
#define SCNxLEAST32 "x"
#define SCNxLEAST64 __PRI64_PREFIX "x"

#define SCNxFAST8 "hhx"
#define SCNxFAST16 __PRIPTR_PREFIX "x"
#define SCNxFAST32 __PRIPTR_PREFIX "x"
#define SCNxFAST64 __PRI64_PREFIX "x"



#define SCNdMAX __PRI64_PREFIX "d"
#define SCNiMAX __PRI64_PREFIX "i"
#define SCNoMAX __PRI64_PREFIX "o"
#define SCNuMAX __PRI64_PREFIX "u"
#define SCNxMAX __PRI64_PREFIX "x"


#define SCNdPTR __PRIPTR_PREFIX "d"
#define SCNiPTR __PRIPTR_PREFIX "i"
#define SCNoPTR __PRIPTR_PREFIX "o"
#define SCNuPTR __PRIPTR_PREFIX "u"
#define SCNxPTR __PRIPTR_PREFIX "x"







typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 432 "/usr/include/inttypes.h" 3 4

# 45 "includes/stg/Types.h" 2
# 71 "includes/stg/Types.h"

# 71 "includes/stg/Types.h"
typedef int8_t StgInt8;
typedef uint8_t StgWord8;

#define STG_INT8_MIN INT8_MIN
#define STG_INT8_MAX INT8_MAX
#define STG_WORD8_MAX UINT8_MAX

#define FMT_Word8 PRIu8
#define FMT_HexWord8 PRIx8

typedef int16_t StgInt16;
typedef uint16_t StgWord16;

#define STG_INT16_MIN INT16_MIN
#define STG_INT16_MAX INT16_MAX
#define STG_WORD16_MAX UINT16_MAX

#define FMT_Word16 PRIu16
#define FMT_HexWord16 PRIx16

typedef int32_t StgInt32;
typedef uint32_t StgWord32;

#define STG_INT32_MIN INT32_MIN
#define STG_INT32_MAX INT32_MAX
#define STG_WORD32_MAX UINT32_MAX

#define FMT_Word32 PRIu32
#define FMT_HexWord32 PRIx32
#define FMT_Int32 PRId32

typedef int64_t StgInt64;
typedef uint64_t StgWord64;

#define STG_INT64_MIN INT64_MIN
#define STG_INT64_MAX INT64_MAX
#define STG_WORD64_MAX UINT64_MAX

#define FMT_Word64 PRIu64
#define FMT_HexWord64 PRIx64
#define FMT_Int64 PRId64

typedef struct { StgWord64 h; StgWord64 l; } StgWord128;

typedef struct { StgWord128 h; StgWord128 l; } StgWord256;

typedef struct { StgWord256 h; StgWord256 l; } StgWord512;







typedef int64_t StgInt;
typedef uint64_t StgWord;

typedef int32_t StgHalfInt;
typedef uint32_t StgHalfWord;

#define STG_INT_MIN INT64_MIN
#define STG_INT_MAX INT64_MAX
#define STG_WORD_MAX UINT64_MAX

#define FMT_Word FMT_Word64
#define FMT_HexWord FMT_HexWord64
#define FMT_Int FMT_Int64

#define strToStgWord strtoull
# 162 "includes/stg/Types.h"
#define W_MASK (sizeof(W_)-1)





typedef void* StgAddr;
typedef StgWord32 StgChar;
typedef int StgBool;
typedef float StgFloat;
typedef double StgDouble;
typedef StgWord* StgPtr;
typedef StgWord volatile* StgVolatilePtr;
typedef StgWord StgOffset;
typedef StgWord8 StgCode;
typedef void* StgStablePtr;
typedef StgWord8* StgByteArray;
# 195 "includes/stg/Types.h"
typedef void *(*(*StgFunPtr)(void))(void);
typedef StgFunPtr StgFun(void);






struct StgClosure_;
struct StgThunk_;
struct Capability_;
# 24 "includes/Rts.h" 2
# 33 "includes/Rts.h"
# 1 "/usr/include/assert.h" 1 3 4
# 34 "/usr/include/assert.h" 3 4
#define _ASSERT_H 1





#define __ASSERT_VOID_CAST (void)
# 65 "/usr/include/assert.h" 3 4
#define _ASSERT_H_DECLS 




# 69 "/usr/include/assert.h" 3 4
extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





#define assert(expr) ((expr) ? __ASSERT_VOID_CAST (0) : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))





#define assert_perror(errnum) (!(errnum) ? __ASSERT_VOID_CAST (0) : __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))
# 106 "/usr/include/assert.h" 3 4
#define __ASSERT_FUNCTION __PRETTY_FUNCTION__
# 119 "/usr/include/assert.h" 3 4
#undef static_assert
#define static_assert _Static_assert
# 34 "includes/Rts.h" 2


#define IN_STG_CODE 0

# 1 "includes/Stg.h" 1
# 26 "includes/Stg.h"
       
# 74 "includes/Stg.h"
#define NO_GLOBAL_REG_DECLS 
# 83 "includes/Stg.h"
# 1 "/usr/include/math.h" 1 3 4
# 24 "/usr/include/math.h" 3 4
#define _MATH_H 1






# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 3 4
#define _BITS_LIBM_SIMD_DECL_STUBS_H 1

#define __DECL_SIMD_cos 
#define __DECL_SIMD_cosf 
#define __DECL_SIMD_cosl 

#define __DECL_SIMD_sin 
#define __DECL_SIMD_sinf 
#define __DECL_SIMD_sinl 

#define __DECL_SIMD_sincos 
#define __DECL_SIMD_sincosf 
#define __DECL_SIMD_sincosl 

#define __DECL_SIMD_log 
#define __DECL_SIMD_logf 
#define __DECL_SIMD_logl 

#define __DECL_SIMD_exp 
#define __DECL_SIMD_expf 
#define __DECL_SIMD_expl 

#define __DECL_SIMD_pow 
#define __DECL_SIMD_powf 
#define __DECL_SIMD_powl 
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 32 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 3 4
#define HUGE_VAL (__builtin_huge_val())
# 36 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 3 4
#define HUGE_VALF (__builtin_huge_valf())
# 38 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 3 4
#define HUGE_VALL (__builtin_huge_vall())
# 39 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/inf.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/inf.h" 3 4
#define INFINITY (__builtin_inff())
# 42 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/nan.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/nan.h" 3 4
#define NAN (__builtin_nanf (""))
# 45 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3 4
#define _MATH_H_MATHDEF 1




typedef float float_t;
typedef double double_t;
# 42 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3 4
#define FP_ILOGB0 (-2147483647 - 1)
#define FP_ILOGBNAN (-2147483647 - 1)
# 49 "/usr/include/math.h" 2 3 4






#define __SIMD_DECL(function) __CONCAT (__DECL_SIMD_, function)

#define __MATHCALL_VEC(function,suffix,args) __SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHCALL (function, suffix, args)



#define __MATHDECL_VEC(type,function,suffix,args) __SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHDECL(type, function,suffix, args)



#define __MATHCALL(function,suffix,args) __MATHDECL (_Mdouble_,function,suffix, args)

#define __MATHDECL(type,function,suffix,args) __MATHDECL_1(type, function,suffix, args); __MATHDECL_1(type, __CONCAT(__,function),suffix, args)


#define __MATHCALLX(function,suffix,args,attrib) __MATHDECLX (_Mdouble_,function,suffix, args, attrib)

#define __MATHDECLX(type,function,suffix,args,attrib) __MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)


#define __MATHDECL_1(type,function,suffix,args) extern type __MATH_PRECNAME(function,suffix) args __THROW


#define _Mdouble_ double
#define __MATH_PRECNAME(name,r) __CONCAT(name,r)
#define __MATH_DECLARING_DOUBLE 1
#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_STD
#define _Mdouble_END_NAMESPACE __END_NAMESPACE_STD
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));




 extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;





extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));







 extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));








 extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));






extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));








extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));








extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));






extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));





extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));








extern int __issignaling (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));






extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 84 "/usr/include/math.h" 2 3 4
#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
# 97 "/usr/include/math.h" 3 4
#define _Mfloat_ float

#define _Mdouble_ _Mfloat_
#define __MATH_PRECNAME(name,r) name ##f ##r
#define __MATH_DECLARING_DOUBLE 0
#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
#define _Mdouble_END_NAMESPACE __END_NAMESPACE_C99
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));


 extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));




 extern void sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;





extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));







 extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));








 extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));






extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));








extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));








extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));






extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));








extern int __issignalingf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));






extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 105 "/usr/include/math.h" 2 3 4
#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
# 143 "/usr/include/math.h" 3 4
#define _Mlong_double_ long double

#define _Mdouble_ _Mlong_double_
#define __MATH_PRECNAME(name,r) name ##l ##r
#define __MATH_DECLARING_DOUBLE 0
#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
#define _Mdouble_END_NAMESPACE __END_NAMESPACE_C99
#define __MATH_DECLARE_LDOUBLE 1
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;





extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));







 extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));








 extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));






extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));








extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));








extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));








extern int __issignalingl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));






extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 152 "/usr/include/math.h" 2 3 4
#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE




#undef __MATHDECL_1
#undef __MATHDECL
#undef __MATHCALL




extern int signgam;
# 209 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =
#define FP_NAN 0
      0,
    FP_INFINITE =
#define FP_INFINITE 1
      1,
    FP_ZERO =
#define FP_ZERO 2
      2,
    FP_SUBNORMAL =
#define FP_SUBNORMAL 3
      3,
    FP_NORMAL =
#define FP_NORMAL 4
      4
  };
# 235 "/usr/include/math.h" 3 4
#define fpclassify(x) __builtin_fpclassify (FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)
# 250 "/usr/include/math.h" 3 4
#define signbit(x) (sizeof (x) == sizeof (float) ? __builtin_signbitf (x) : sizeof (x) == sizeof (double) ? __builtin_signbit (x) : __builtin_signbitl (x))
# 270 "/usr/include/math.h" 3 4
#define isfinite(x) __builtin_isfinite (x)
# 284 "/usr/include/math.h" 3 4
#define isnormal(x) __builtin_isnormal (x)







#define isnan(x) __builtin_isnan (x)
# 306 "/usr/include/math.h" 3 4
#define isinf(x) __builtin_isinf_sign (x)
# 319 "/usr/include/math.h" 3 4
#define MATH_ERRNO 1
#define MATH_ERREXCEPT 2





#define math_errhandling (MATH_ERRNO | MATH_ERREXCEPT)
# 337 "/usr/include/math.h" 3 4
#define issignaling(x) (sizeof (x) == sizeof (float) ? __issignalingf (x) : sizeof (x) == sizeof (double) ? __issignaling (x) : __issignalingl (x))
# 347 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 372 "/usr/include/math.h" 3 4
struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);


#define X_TLOSS 1.41484755040568800000e+16


#define DOMAIN 1
#define SING 2
#define OVERFLOW 3
#define UNDERFLOW 4
#define TLOSS 5
#define PLOSS 6


#define HUGE 3.40282347e+38F
# 413 "/usr/include/math.h" 3 4
#define M_E 2.7182818284590452354
#define M_LOG2E 1.4426950408889634074
#define M_LOG10E 0.43429448190325182765
#define M_LN2 0.69314718055994530942
#define M_LN10 2.30258509299404568402
#define M_PI 3.14159265358979323846
#define M_PI_2 1.57079632679489661923
#define M_PI_4 0.78539816339744830962
#define M_1_PI 0.31830988618379067154
#define M_2_PI 0.63661977236758134308
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2 1.41421356237309504880
#define M_SQRT1_2 0.70710678118654752440






#define M_El 2.718281828459045235360287471352662498L
#define M_LOG2El 1.442695040888963407359924681001892137L
#define M_LOG10El 0.434294481903251827651128918916605082L
#define M_LN2l 0.693147180559945309417232121458176568L
#define M_LN10l 2.302585092994045684017991454684364208L
#define M_PIl 3.141592653589793238462643383279502884L
#define M_PI_2l 1.570796326794896619231321691639751442L
#define M_PI_4l 0.785398163397448309615660845819875721L
#define M_1_PIl 0.318309886183790671537767526745028724L
#define M_2_PIl 0.636619772367581343075535053490057448L
#define M_2_SQRTPIl 1.128379167095512573896158903121545172L
#define M_SQRT2l 1.414213562373095048801688724209698079L
#define M_SQRT1_2l 0.707106781186547524400844362104849039L
# 462 "/usr/include/math.h" 3 4
#define isgreater(x,y) __builtin_isgreater(x, y)
#define isgreaterequal(x,y) __builtin_isgreaterequal(x, y)
#define isless(x,y) __builtin_isless(x, y)
#define islessequal(x,y) __builtin_islessequal(x, y)
#define islessgreater(x,y) __builtin_islessgreater(x, y)
#define isunordered(u,v) __builtin_isunordered(u, v)
# 534 "/usr/include/math.h" 3 4

# 84 "includes/Stg.h" 2
# 121 "includes/Stg.h"
#define RTS_VAR(x) x
#define RTS_DEREF(x) x




#define BITS_PER_BYTE 8
#define BITS_IN(x) (BITS_PER_BYTE * sizeof(x))



#define STG_FIELD_OFFSET(s_type,field) ((StgWord)&(((s_type*)0)->field))
# 148 "includes/Stg.h"
#define INLINE_HEADER static inline
#define STATIC_INLINE static inline
# 185 "includes/Stg.h"
#define EXTERN_INLINE inline
# 194 "includes/Stg.h"
#define GNU_ATTRIBUTE(at) __attribute__((at))





#define GNUC3_ATTRIBUTE(at) __attribute__((at))
# 211 "includes/Stg.h"
#define FALLTHROUGH GNU_ATTRIBUTE(fallthrough)







#define GNUC_ATTR_HOT 


#define STG_UNUSED GNUC3_ATTRIBUTE(__unused__)






#define STG_NO_OPTIMIZE __attribute__((optimize("O0")))
# 238 "includes/Stg.h"
# 1 "includes/MachDeps.h" 1
# 16 "includes/MachDeps.h"
       
# 52 "includes/MachDeps.h"
#define SIZEOF_HSCHAR SIZEOF_WORD32
#define ALIGNMENT_HSCHAR ALIGNMENT_WORD32

#define SIZEOF_HSINT SIZEOF_VOID_P
#define ALIGNMENT_HSINT ALIGNMENT_VOID_P

#define SIZEOF_HSWORD SIZEOF_VOID_P
#define ALIGNMENT_HSWORD ALIGNMENT_VOID_P

#define SIZEOF_HSDOUBLE SIZEOF_DOUBLE
#define ALIGNMENT_HSDOUBLE ALIGNMENT_DOUBLE

#define SIZEOF_HSFLOAT SIZEOF_FLOAT
#define ALIGNMENT_HSFLOAT ALIGNMENT_FLOAT

#define SIZEOF_HSPTR SIZEOF_VOID_P
#define ALIGNMENT_HSPTR ALIGNMENT_VOID_P

#define SIZEOF_HSFUNPTR SIZEOF_VOID_P
#define ALIGNMENT_HSFUNPTR ALIGNMENT_VOID_P

#define SIZEOF_HSSTABLEPTR SIZEOF_VOID_P
#define ALIGNMENT_HSSTABLEPTR ALIGNMENT_VOID_P

#define SIZEOF_INT8 SIZEOF_INT8_T
#define ALIGNMENT_INT8 ALIGNMENT_INT8_T

#define SIZEOF_WORD8 SIZEOF_UINT8_T
#define ALIGNMENT_WORD8 ALIGNMENT_UINT8_T

#define SIZEOF_INT16 SIZEOF_INT16_T
#define ALIGNMENT_INT16 ALIGNMENT_INT16_T

#define SIZEOF_WORD16 SIZEOF_UINT16_T
#define ALIGNMENT_WORD16 ALIGNMENT_UINT16_T

#define SIZEOF_INT32 SIZEOF_INT32_T
#define ALIGNMENT_INT32 ALIGNMENT_INT32_T

#define SIZEOF_WORD32 SIZEOF_UINT32_T
#define ALIGNMENT_WORD32 ALIGNMENT_UINT32_T

#define SIZEOF_INT64 SIZEOF_INT64_T
#define ALIGNMENT_INT64 ALIGNMENT_INT64_T

#define SIZEOF_WORD64 SIZEOF_UINT64_T
#define ALIGNMENT_WORD64 ALIGNMENT_UINT64_T






#define WORD_SIZE_IN_BITS 64
#define WORD_SIZE_IN_BITS_FLOAT 64.0







#define TAG_BITS 3



#define TAG_MASK ((1 << TAG_BITS) - 1)
# 239 "includes/Stg.h" 2







# 245 "includes/Stg.h"
typedef StgChar C_;
typedef StgWord W_;
typedef StgWord* P_;
typedef StgInt I_;
typedef StgWord StgWordArray[];
typedef StgFunPtr F_;


#define EB_(X) extern const char X[]
#define IB_(X) static const char X[]

#define EC_(X) extern StgWordArray (X) GNU_ATTRIBUTE(aligned (8))
#define IC_(X) static StgWordArray (X) GNU_ATTRIBUTE(aligned (8))

#define ERW_(X) extern StgWordArray (X)
#define IRW_(X) static StgWordArray (X)

#define ERO_(X) extern const StgWordArray (X)
#define IRO_(X) static const StgWordArray (X)

#define IF_(f) static StgFunPtr GNUC3_ATTRIBUTE(used) f(void)
#define FN_(f) StgFunPtr f(void)
#define EF_(f) StgFunPtr f(void)

#define EFF_(f) void f()
# 316 "includes/Stg.h"
#define JMP_(cont) return((StgFunPtr)(cont))





# 1 "includes/stg/DLL.h" 1
# 14 "includes/stg/DLL.h"
       
# 35 "includes/stg/DLL.h"
#define DLL_IMPORT_DATA_REF(x) (&(x))
#define DLL_IMPORT_DATA_VARNAME(x) x
#define DLLIMPORT 
# 50 "includes/stg/DLL.h"
#define DLL_IMPORT DLLIMPORT
#define DLL_IMPORT_RTS 
#define DLL_IMPORT_DATA_VAR(x) x
# 71 "includes/stg/DLL.h"
#define DLL_IMPORT_STDLIB DLLIMPORT
# 323 "includes/Stg.h" 2
# 1 "includes/stg/MachRegsForHost.h" 1
# 15 "includes/stg/MachRegsForHost.h"
       
# 39 "includes/stg/MachRegsForHost.h"
#define MACHREGS_NO_REGS 0






#define MACHREGS_x86_64 1
# 80 "includes/stg/MachRegsForHost.h"
# 1 "includes/stg/MachRegs.h" 1
# 15 "includes/stg/MachRegs.h"
       
# 25 "includes/stg/MachRegs.h"
#undef REG_R1
#undef REG_R2
#undef REG_R3
#undef REG_R4
#undef REG_R5
#undef REG_R6
#undef REG_R7
#undef REG_R8
#undef REG_R9
#undef REG_R10
# 162 "includes/stg/MachRegs.h"
#define REG(x) __asm__("%" #x)

#define REG_Base r13
#define REG_Sp rbp
#define REG_Hp r12
#define REG_R1 rbx
#define REG_R2 r14
#define REG_R3 rsi
#define REG_R4 rdi
#define REG_R5 r8
#define REG_R6 r9
#define REG_SpLim r15
#define REG_MachSp rsp







#define REG_F1 xmm1
#define REG_F2 xmm2
#define REG_F3 xmm3
#define REG_F4 xmm4
#define REG_F5 xmm5
#define REG_F6 xmm6

#define REG_D1 xmm1
#define REG_D2 xmm2
#define REG_D3 xmm3
#define REG_D4 xmm4
#define REG_D5 xmm5
#define REG_D6 xmm6

#define REG_XMM1 xmm1
#define REG_XMM2 xmm2
#define REG_XMM3 xmm3
#define REG_XMM4 xmm4
#define REG_XMM5 xmm5
#define REG_XMM6 xmm6

#define REG_YMM1 ymm1
#define REG_YMM2 ymm2
#define REG_YMM3 ymm3
#define REG_YMM4 ymm4
#define REG_YMM5 ymm5
#define REG_YMM6 ymm6

#define REG_ZMM1 zmm1
#define REG_ZMM2 zmm2
#define REG_ZMM3 zmm3
#define REG_ZMM4 zmm4
#define REG_ZMM5 zmm5
#define REG_ZMM6 zmm6


#define CALLER_SAVES_R3 
#define CALLER_SAVES_R4 

#define CALLER_SAVES_R5 
#define CALLER_SAVES_R6 

#define CALLER_SAVES_F1 
#define CALLER_SAVES_F2 
#define CALLER_SAVES_F3 
#define CALLER_SAVES_F4 
#define CALLER_SAVES_F5 

#define CALLER_SAVES_F6 


#define CALLER_SAVES_D1 
#define CALLER_SAVES_D2 
#define CALLER_SAVES_D3 
#define CALLER_SAVES_D4 
#define CALLER_SAVES_D5 

#define CALLER_SAVES_D6 


#define CALLER_SAVES_XMM1 
#define CALLER_SAVES_XMM2 
#define CALLER_SAVES_XMM3 
#define CALLER_SAVES_XMM4 
#define CALLER_SAVES_XMM5 

#define CALLER_SAVES_XMM6 


#define CALLER_SAVES_YMM1 
#define CALLER_SAVES_YMM2 
#define CALLER_SAVES_YMM3 
#define CALLER_SAVES_YMM4 
#define CALLER_SAVES_YMM5 

#define CALLER_SAVES_YMM6 


#define CALLER_SAVES_ZMM1 
#define CALLER_SAVES_ZMM2 
#define CALLER_SAVES_ZMM3 
#define CALLER_SAVES_ZMM4 
#define CALLER_SAVES_ZMM5 

#define CALLER_SAVES_ZMM6 


#define MAX_REAL_VANILLA_REG 6
#define MAX_REAL_FLOAT_REG 6
#define MAX_REAL_DOUBLE_REG 6
#define MAX_REAL_LONG_REG 0
#define MAX_REAL_XMM_REG 6
#define MAX_REAL_YMM_REG 6
#define MAX_REAL_ZMM_REG 6
# 853 "includes/stg/MachRegs.h"
#undef NO_ARG_REGS
# 80 "includes/stg/MachRegsForHost.h" 2
# 324 "includes/Stg.h" 2
# 1 "includes/stg/Regs.h" 1
# 14 "includes/stg/Regs.h"
       
# 32 "includes/stg/Regs.h"
typedef struct {
  StgWord stgEagerBlackholeInfo;
  StgFunPtr stgGCEnter1;
  StgFunPtr stgGCFun;
} StgFunTable;






typedef union {
    StgWord w;
    StgAddr a;
    StgChar c;
    StgFloat f;
    StgInt i;
    StgPtr p;
} StgUnion;
# 60 "includes/stg/Regs.h"
typedef struct {
  StgUnion rR1;
  StgUnion rR2;
  StgUnion rR3;
  StgUnion rR4;
  StgUnion rR5;
  StgUnion rR6;
  StgUnion rR7;
  StgUnion rR8;
  StgUnion rR9;
  StgUnion rR10;
  StgFloat rF1;
  StgFloat rF2;
  StgFloat rF3;
  StgFloat rF4;
  StgFloat rF5;
  StgFloat rF6;
  StgDouble rD1;
  StgDouble rD2;
  StgDouble rD3;
  StgDouble rD4;
  StgDouble rD5;
  StgDouble rD6;
  StgWord128 rXMM1;
  StgWord128 rXMM2;
  StgWord128 rXMM3;
  StgWord128 rXMM4;
  StgWord128 rXMM5;
  StgWord128 rXMM6;
  StgWord256 rYMM1;
  StgWord256 rYMM2;
  StgWord256 rYMM3;
  StgWord256 rYMM4;
  StgWord256 rYMM5;
  StgWord256 rYMM6;
  StgWord512 rZMM1;
  StgWord512 rZMM2;
  StgWord512 rZMM3;
  StgWord512 rZMM4;
  StgWord512 rZMM5;
  StgWord512 rZMM6;
  StgWord64 rL1;
  StgPtr rSp;
  StgPtr rSpLim;
  StgPtr rHp;
  StgPtr rHpLim;
  struct CostCentreStack_ * rCCCS;
  struct StgTSO_ * rCurrentTSO;
  struct nursery_ * rNursery;
  struct bdescr_ * rCurrentNursery;
  struct bdescr_ * rCurrentAlloc;
  StgWord rHpAlloc;
  StgWord rRet;
} StgRegTable;
# 325 "includes/Stg.h" 2
# 1 "includes/stg/Ticky.h" 1
# 14 "includes/stg/Ticky.h"
       
# 42 "includes/stg/Ticky.h"
#define INIT(ializer) 
#define EXTERN extern


extern StgInt ENT_VIA_NODE_ctr ;
extern StgInt ENT_STATIC_THK_SINGLE_ctr ;
extern StgInt ENT_DYN_THK_SINGLE_ctr ;
extern StgInt ENT_STATIC_THK_MANY_ctr ;
extern StgInt ENT_DYN_THK_MANY_ctr ;
extern StgInt ENT_STATIC_FUN_DIRECT_ctr ;
extern StgInt ENT_DYN_FUN_DIRECT_ctr ;
extern StgInt ENT_STATIC_CON_ctr ;
extern StgInt ENT_DYN_CON_ctr ;
extern StgInt ENT_STATIC_IND_ctr ;
extern StgInt ENT_DYN_IND_ctr ;
extern StgInt ENT_PERM_IND_ctr ;
extern StgInt ENT_PAP_ctr ;
extern StgInt ENT_AP_ctr ;
extern StgInt ENT_AP_STACK_ctr ;
extern StgInt ENT_BH_ctr ;
extern StgInt ENT_LNE_ctr ;

extern StgInt UNKNOWN_CALL_ctr ;

extern StgInt SLOW_CALL_fast_v16_ctr ;
extern StgInt SLOW_CALL_fast_v_ctr ;
extern StgInt SLOW_CALL_fast_f_ctr ;
extern StgInt SLOW_CALL_fast_d_ctr ;
extern StgInt SLOW_CALL_fast_l_ctr ;
extern StgInt SLOW_CALL_fast_n_ctr ;
extern StgInt SLOW_CALL_fast_p_ctr ;
extern StgInt SLOW_CALL_fast_pv_ctr ;
extern StgInt SLOW_CALL_fast_pp_ctr ;
extern StgInt SLOW_CALL_fast_ppv_ctr ;
extern StgInt SLOW_CALL_fast_ppp_ctr ;
extern StgInt SLOW_CALL_fast_pppv_ctr ;
extern StgInt SLOW_CALL_fast_pppp_ctr ;
extern StgInt SLOW_CALL_fast_ppppp_ctr ;
extern StgInt SLOW_CALL_fast_pppppp_ctr ;
extern StgInt VERY_SLOW_CALL_ctr ;

extern StgInt ticky_slow_call_unevald;
extern StgInt SLOW_CALL_ctr ;
extern StgInt MULTI_CHUNK_SLOW_CALL_ctr ;
extern StgInt MULTI_CHUNK_SLOW_CALL_CHUNKS_ctr ;
extern StgInt KNOWN_CALL_ctr ;
extern StgInt KNOWN_CALL_TOO_FEW_ARGS_ctr ;
extern StgInt KNOWN_CALL_EXTRA_ARGS_ctr ;
extern StgInt SLOW_CALL_FUN_TOO_FEW_ctr ;
extern StgInt SLOW_CALL_FUN_CORRECT_ctr ;
extern StgInt SLOW_CALL_FUN_TOO_MANY_ctr ;
extern StgInt SLOW_CALL_PAP_TOO_FEW_ctr ;
extern StgInt SLOW_CALL_PAP_CORRECT_ctr ;
extern StgInt SLOW_CALL_PAP_TOO_MANY_ctr ;
extern StgInt SLOW_CALL_UNEVALD_ctr ;


extern StgInt UPDF_OMITTED_ctr ;
extern StgInt UPDF_PUSHED_ctr ;
extern StgInt CATCHF_PUSHED_ctr ;
extern StgInt UPDF_RCC_PUSHED_ctr ;
extern StgInt UPDF_RCC_OMITTED_ctr ;

extern StgInt UPD_SQUEEZED_ctr ;
extern StgInt UPD_CON_IN_NEW_ctr ;
extern StgInt UPD_CON_IN_PLACE_ctr ;
extern StgInt UPD_PAP_IN_NEW_ctr ;
extern StgInt UPD_PAP_IN_PLACE_ctr ;

extern StgInt ALLOC_HEAP_ctr ;
extern StgInt ALLOC_HEAP_tot ;

extern StgInt HEAP_CHK_ctr ;
extern StgInt STK_CHK_ctr ;

extern StgInt ALLOC_RTS_ctr ;
extern StgInt ALLOC_RTS_tot ;

extern StgInt ALLOC_FUN_ctr ;
extern StgInt ALLOC_FUN_adm ;
extern StgInt ALLOC_FUN_gds ;
extern StgInt ALLOC_FUN_slp ;

extern StgInt UPD_NEW_IND_ctr ;
extern StgInt UPD_NEW_PERM_IND_ctr ;
extern StgInt UPD_OLD_IND_ctr ;
extern StgInt UPD_OLD_PERM_IND_ctr ;

extern StgInt UPD_BH_UPDATABLE_ctr ;
extern StgInt UPD_CAF_BH_UPDATABLE_ctr ;
extern StgInt UPD_CAF_BH_SINGLE_ENTRY_ctr ;

extern StgInt GC_SEL_ABANDONED_ctr ;
extern StgInt GC_SEL_MINOR_ctr ;
extern StgInt GC_SEL_MAJOR_ctr ;

extern StgInt GC_FAILED_PROMOTION_ctr ;

extern StgInt ALLOC_UP_THK_ctr ;
extern StgInt ALLOC_SE_THK_ctr ;
extern StgInt ALLOC_THK_adm ;
extern StgInt ALLOC_THK_gds ;
extern StgInt ALLOC_THK_slp ;

extern StgInt ALLOC_CON_ctr ;
extern StgInt ALLOC_CON_adm ;
extern StgInt ALLOC_CON_gds ;
extern StgInt ALLOC_CON_slp ;

extern StgInt ALLOC_TUP_ctr ;
extern StgInt ALLOC_TUP_adm ;
extern StgInt ALLOC_TUP_gds ;
extern StgInt ALLOC_TUP_slp ;

extern StgInt ALLOC_BH_ctr ;
extern StgInt ALLOC_BH_adm ;
extern StgInt ALLOC_BH_gds ;
extern StgInt ALLOC_BH_slp ;

extern StgInt ALLOC_PRIM_ctr ;
extern StgInt ALLOC_PRIM_adm ;
extern StgInt ALLOC_PRIM_gds ;
extern StgInt ALLOC_PRIM_slp ;

extern StgInt ALLOC_PAP_ctr ;
extern StgInt ALLOC_PAP_adm ;
extern StgInt ALLOC_PAP_gds ;
extern StgInt ALLOC_PAP_slp ;

extern StgInt ALLOC_TSO_ctr ;
extern StgInt ALLOC_TSO_adm ;
extern StgInt ALLOC_TSO_gds ;
extern StgInt ALLOC_TSO_slp ;

extern StgInt RET_NEW_ctr ;
extern StgInt RET_OLD_ctr ;
extern StgInt RET_UNBOXED_TUP_ctr ;

extern StgInt RET_SEMI_loads_avoided ;



#define TICKY_BIN_COUNT 9


extern StgInt RET_NEW_hst[9] ;
extern StgInt RET_OLD_hst[9] ;
extern StgInt RET_UNBOXED_TUP_hst[9] ;
# 205 "includes/stg/Ticky.h"
#define TICK_BUMP_BY(ctr,n) 


#define TICK_BUMP(ctr) TICK_BUMP_BY(ctr,1)

#define TICK_ALLOC_PRIM(x,y,z) 
#define TICK_UPD_OLD_IND() TICK_BUMP(UPD_OLD_IND_ctr)
#define TICK_UPD_NEW_IND() TICK_BUMP(UPD_NEW_IND_ctr)
#define TICK_UPD_SQUEEZED() TICK_BUMP(UPD_SQUEEZED_ctr)
#define TICK_ALLOC_HEAP_NOCTR(bytes) 
#define TICK_GC_FAILED_PROMOTION() 
#define TICK_ALLOC_TSO() 
#define TICK_ALLOC_STACK(g) 
#define TICK_ALLOC_UP_THK(g,s) 
#define TICK_ALLOC_SE_THK(g,s) 
# 326 "includes/Stg.h" 2
# 335 "includes/Stg.h"
# 1 "includes/stg/Prim.h" 1
# 14 "includes/stg/Prim.h"
       


StgWord hs_atomic_add8(StgWord x, StgWord val);
StgWord hs_atomic_add16(StgWord x, StgWord val);
StgWord hs_atomic_add32(StgWord x, StgWord val);
StgWord64 hs_atomic_add64(StgWord x, StgWord64 val);
StgWord hs_atomic_sub8(StgWord x, StgWord val);
StgWord hs_atomic_sub16(StgWord x, StgWord val);
StgWord hs_atomic_sub32(StgWord x, StgWord val);
StgWord64 hs_atomic_sub64(StgWord x, StgWord64 val);
StgWord hs_atomic_and8(StgWord x, StgWord val);
StgWord hs_atomic_and16(StgWord x, StgWord val);
StgWord hs_atomic_and32(StgWord x, StgWord val);
StgWord64 hs_atomic_and64(StgWord x, StgWord64 val);
StgWord hs_atomic_nand8(StgWord x, StgWord val);
StgWord hs_atomic_nand16(StgWord x, StgWord val);
StgWord hs_atomic_nand32(StgWord x, StgWord val);
StgWord64 hs_atomic_nand64(StgWord x, StgWord64 val);
StgWord hs_atomic_or8(StgWord x, StgWord val);
StgWord hs_atomic_or16(StgWord x, StgWord val);
StgWord hs_atomic_or32(StgWord x, StgWord val);
StgWord64 hs_atomic_or64(StgWord x, StgWord64 val);
StgWord hs_atomic_xor8(StgWord x, StgWord val);
StgWord hs_atomic_xor16(StgWord x, StgWord val);
StgWord hs_atomic_xor32(StgWord x, StgWord val);
StgWord64 hs_atomic_xor64(StgWord x, StgWord64 val);
StgWord hs_cmpxchg8(StgWord x, StgWord old, StgWord new_);
StgWord hs_cmpxchg16(StgWord x, StgWord old, StgWord new_);
StgWord hs_cmpxchg32(StgWord x, StgWord old, StgWord new_);
StgWord hs_cmpxchg64(StgWord x, StgWord64 old, StgWord64 new_);
StgWord hs_atomicread8(StgWord x);
StgWord hs_atomicread16(StgWord x);
StgWord hs_atomicread32(StgWord x);
StgWord64 hs_atomicread64(StgWord x);
void hs_atomicwrite8(StgWord x, StgWord val);
void hs_atomicwrite16(StgWord x, StgWord val);
void hs_atomicwrite32(StgWord x, StgWord val);
void hs_atomicwrite64(StgWord x, StgWord64 val);
StgWord hs_xchg8(StgWord x, StgWord val);
StgWord hs_xchg16(StgWord x, StgWord val);
StgWord hs_xchg32(StgWord x, StgWord val);
StgWord hs_xchg64(StgWord x, StgWord val);


StgWord16 hs_bswap16(StgWord16 x);
StgWord32 hs_bswap32(StgWord32 x);
StgWord64 hs_bswap64(StgWord64 x);




StgWord hs_bitrev8(StgWord x);
StgWord16 hs_bitrev16(StgWord16 x);
StgWord32 hs_bitrev32(StgWord32 x);
StgWord64 hs_bitrev64(StgWord64 x);
# 107 "includes/stg/Prim.h"
StgWord64 hs_pdep64(StgWord64 src, StgWord64 mask);
StgWord hs_pdep32(StgWord src, StgWord mask);
StgWord hs_pdep16(StgWord src, StgWord mask);
StgWord hs_pdep8(StgWord src, StgWord mask);


StgWord64 hs_pext64(StgWord64 src, StgWord64 mask);
StgWord hs_pext32(StgWord src, StgWord mask);
StgWord hs_pext16(StgWord src, StgWord mask);
StgWord hs_pext8(StgWord src, StgWord mask);


StgWord hs_popcnt8(StgWord x);
StgWord hs_popcnt16(StgWord x);
StgWord hs_popcnt32(StgWord x);
StgWord hs_popcnt64(StgWord64 x);
StgWord hs_popcnt(StgWord x);


StgFloat hs_word2float32(StgWord x);
StgDouble hs_word2float64(StgWord x);


StgWord hs_clz8(StgWord x);
StgWord hs_clz16(StgWord x);
StgWord hs_clz32(StgWord x);
StgWord hs_clz64(StgWord64 x);


StgWord hs_ctz8(StgWord x);
StgWord hs_ctz16(StgWord x);
StgWord hs_ctz32(StgWord x);
StgWord hs_ctz64(StgWord64 x);
# 336 "includes/Stg.h" 2
# 1 "includes/stg/SMP.h" 1
# 14 "includes/stg/SMP.h"
       
# 40 "includes/stg/SMP.h"
inline StgWord xchg(StgPtr p, StgWord w);
# 51 "includes/stg/SMP.h"
inline StgWord cas(StgVolatilePtr p, StgWord o, StgWord n);
inline StgWord8 cas_word8(StgWord8 *volatile p, StgWord8 o, StgWord8 n);





inline StgWord cas_seq_cst_relaxed(StgVolatilePtr p, StgWord o, StgWord n);
# 68 "includes/stg/SMP.h"
inline StgWord atomic_inc(StgVolatilePtr p, StgWord n);
# 78 "includes/stg/SMP.h"
inline StgWord atomic_dec(StgVolatilePtr p);






inline void busy_wait_nop(void);
# 103 "includes/stg/SMP.h"
inline void write_barrier(void);
inline void store_load_barrier(void);
inline void load_load_barrier(void);
# 264 "includes/stg/SMP.h"
inline StgWord
xchg(StgPtr p, StgWord w)
{

    return __atomic_exchange_n(p, w, 5);
# 286 "includes/stg/SMP.h"
}





inline StgWord
cas(StgVolatilePtr p, StgWord o, StgWord n)
{

    __atomic_compare_exchange_n(p, &o, n, 0, 5, 5);
    return o;



}

inline StgWord8
cas_word8(StgWord8 *volatile p, StgWord8 o, StgWord8 n)
{

    __atomic_compare_exchange_n(p, &o, n, 0, 5, 5);
    return o;



}

inline StgWord
cas_seq_cst_relaxed(StgVolatilePtr p, StgWord o, StgWord n) {

    __atomic_compare_exchange_n(p, &o, n, 0, 5, 0);
    return o;




}




inline StgWord
atomic_inc(StgVolatilePtr p, StgWord incr)
{

    return __atomic_add_fetch(p, incr, 5);



}

inline StgWord
atomic_dec(StgVolatilePtr p)
{

    return __atomic_sub_fetch(p, 1, 5);



}






inline void
busy_wait_nop(void)
{







    __asm__ __volatile__ ("rep; nop");



}
# 377 "includes/stg/SMP.h"
inline void
write_barrier(void) {
# 387 "includes/stg/SMP.h"
    __asm__ __volatile__ ("" : : : "memory");
# 403 "includes/stg/SMP.h"
}

inline void
store_load_barrier(void) {





    __asm__ __volatile__ ("lock; addq $0,0(%%rsp)" : : : "memory");
# 429 "includes/stg/SMP.h"
}

inline void
load_load_barrier(void) {





    __asm__ __volatile__ ("" : : : "memory");
# 456 "includes/stg/SMP.h"
}





#define VOLATILE_LOAD(p) (*((StgVolatilePtr)(p)))


#define RELAXED_LOAD(ptr) __atomic_load_n(ptr, __ATOMIC_RELAXED)
#define RELAXED_STORE(ptr,val) __atomic_store_n(ptr, val, __ATOMIC_RELAXED)
#define RELAXED_ADD(ptr,val) __atomic_add_fetch(ptr, val, __ATOMIC_RELAXED)


#define ACQUIRE_LOAD(ptr) __atomic_load_n(ptr, __ATOMIC_ACQUIRE)
#define RELEASE_STORE(ptr,val) __atomic_store_n(ptr, val, __ATOMIC_RELEASE)


#define SEQ_CST_LOAD(ptr) __atomic_load_n(ptr, __ATOMIC_SEQ_CST)
#define SEQ_CST_STORE(ptr,val) __atomic_store_n(ptr, val, __ATOMIC_SEQ_CST)
#define SEQ_CST_ADD(ptr,val) __atomic_add_fetch(ptr, val, __ATOMIC_SEQ_CST)


#define NONATOMIC_ADD(ptr,val) RELAXED_STORE(ptr, RELAXED_LOAD(ptr) + val)


#define SEQ_CST_RELAXED_CAS(p,o,n) cas_seq_cst_relaxed(p,o,n)






#define RELEASE_FENCE() __atomic_thread_fence(__ATOMIC_RELEASE)
#define SEQ_CST_FENCE() __atomic_thread_fence(__ATOMIC_SEQ_CST)
# 337 "includes/Stg.h" 2
# 349 "includes/Stg.h"
static inline void ASSIGN_FLT (W_ [], StgFloat);
static inline StgFloat PK_FLT (W_ []);



static inline void ASSIGN_FLT(W_ p_dest[], StgFloat src) { *(StgFloat *)p_dest = src; }
static inline StgFloat PK_FLT (W_ p_src[]) { return *(StgFloat *)p_src; }
# 377 "includes/Stg.h"
static inline void ASSIGN_DBL (W_ [], StgDouble);
static inline StgDouble PK_DBL (W_ []);

static inline void ASSIGN_DBL(W_ p_dest[], StgDouble src) { *(StgDouble *)p_dest = src; }
static inline StgDouble PK_DBL (W_ p_src[]) { return *(StgDouble *)p_src; }
# 509 "includes/Stg.h"
static inline void ASSIGN_Word64(W_ p_dest[], StgWord64 src)
{
   p_dest[0] = src;
}

static inline StgWord64 PK_Word64(W_ p_src[])
{
    return p_src[0];
}

static inline void ASSIGN_Int64(W_ p_dest[], StgInt64 src)
{
    p_dest[0] = src;
}

static inline StgInt64 PK_Int64(W_ p_src[])
{
    return p_src[0];
}
# 591 "includes/Stg.h"
#define HALF_POS_INT (((I_)1) << ((BITS_IN (I_) - 1) / 2))
#define HALF_NEG_INT (-HALF_POS_INT)

#define mulIntMayOflo(a,b) ({ I_ c; if ((I_)a <= HALF_NEG_INT || a >= HALF_POS_INT || (I_)b <= HALF_NEG_INT || b >= HALF_POS_INT) { c = 1; } else { c = 0; } c; })
# 39 "includes/Rts.h" 2

# 1 "includes/HsFFI.h" 1
# 16 "includes/HsFFI.h"
       
# 27 "includes/HsFFI.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/float.h" 1 3 4
# 29 "/usr/lib/gcc/x86_64-linux-gnu/7/include/float.h" 3 4
#define _FLOAT_H___ 


#undef FLT_RADIX
#define FLT_RADIX __FLT_RADIX__


#undef FLT_MANT_DIG
#undef DBL_MANT_DIG
#undef LDBL_MANT_DIG
#define FLT_MANT_DIG __FLT_MANT_DIG__
#define DBL_MANT_DIG __DBL_MANT_DIG__
#define LDBL_MANT_DIG __LDBL_MANT_DIG__
# 50 "/usr/lib/gcc/x86_64-linux-gnu/7/include/float.h" 3 4
#undef FLT_DIG
#undef DBL_DIG
#undef LDBL_DIG
#define FLT_DIG __FLT_DIG__
#define DBL_DIG __DBL_DIG__
#define LDBL_DIG __LDBL_DIG__


#undef FLT_MIN_EXP
#undef DBL_MIN_EXP
#undef LDBL_MIN_EXP
#define FLT_MIN_EXP __FLT_MIN_EXP__
#define DBL_MIN_EXP __DBL_MIN_EXP__
#define LDBL_MIN_EXP __LDBL_MIN_EXP__






#undef FLT_MIN_10_EXP
#undef DBL_MIN_10_EXP
#undef LDBL_MIN_10_EXP
#define FLT_MIN_10_EXP __FLT_MIN_10_EXP__
#define DBL_MIN_10_EXP __DBL_MIN_10_EXP__
#define LDBL_MIN_10_EXP __LDBL_MIN_10_EXP__


#undef FLT_MAX_EXP
#undef DBL_MAX_EXP
#undef LDBL_MAX_EXP
#define FLT_MAX_EXP __FLT_MAX_EXP__
#define DBL_MAX_EXP __DBL_MAX_EXP__
#define LDBL_MAX_EXP __LDBL_MAX_EXP__






#undef FLT_MAX_10_EXP
#undef DBL_MAX_10_EXP
#undef LDBL_MAX_10_EXP
#define FLT_MAX_10_EXP __FLT_MAX_10_EXP__
#define DBL_MAX_10_EXP __DBL_MAX_10_EXP__
#define LDBL_MAX_10_EXP __LDBL_MAX_10_EXP__





#undef FLT_MAX
#undef DBL_MAX
#undef LDBL_MAX
#define FLT_MAX __FLT_MAX__
#define DBL_MAX __DBL_MAX__
#define LDBL_MAX __LDBL_MAX__



#undef FLT_EPSILON
#undef DBL_EPSILON
#undef LDBL_EPSILON
#define FLT_EPSILON __FLT_EPSILON__
#define DBL_EPSILON __DBL_EPSILON__
#define LDBL_EPSILON __LDBL_EPSILON__


#undef FLT_MIN
#undef DBL_MIN
#undef LDBL_MIN
#define FLT_MIN __FLT_MIN__
#define DBL_MIN __DBL_MIN__
#define LDBL_MIN __LDBL_MIN__



#undef FLT_ROUNDS
#define FLT_ROUNDS 1
# 193 "/usr/lib/gcc/x86_64-linux-gnu/7/include/float.h" 3 4
#undef FLT_EVAL_METHOD



#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
# 208 "/usr/lib/gcc/x86_64-linux-gnu/7/include/float.h" 3 4
#undef DECIMAL_DIG
#define DECIMAL_DIG __DECIMAL_DIG__





#undef FLT_DECIMAL_DIG
#undef DBL_DECIMAL_DIG
#undef LDBL_DECIMAL_DIG
#define FLT_DECIMAL_DIG __FLT_DECIMAL_DIG__
#define DBL_DECIMAL_DIG __DBL_DECIMAL_DIG__
#define LDBL_DECIMAL_DIG __LDBL_DECIMAL_DIG__


#undef FLT_HAS_SUBNORM
#undef DBL_HAS_SUBNORM
#undef LDBL_HAS_SUBNORM
#define FLT_HAS_SUBNORM __FLT_HAS_DENORM__
#define DBL_HAS_SUBNORM __DBL_HAS_DENORM__
#define LDBL_HAS_SUBNORM __LDBL_HAS_DENORM__


#undef FLT_TRUE_MIN
#undef DBL_TRUE_MIN
#undef LDBL_TRUE_MIN
#define FLT_TRUE_MIN __FLT_DENORM_MIN__
#define DBL_TRUE_MIN __DBL_DENORM_MIN__
#define LDBL_TRUE_MIN __LDBL_DENORM_MIN__
# 28 "includes/HsFFI.h" 2

typedef StgChar HsChar;
typedef StgInt HsInt;
typedef StgInt8 HsInt8;
typedef StgInt16 HsInt16;
typedef StgInt32 HsInt32;
typedef StgInt64 HsInt64;
typedef StgWord HsWord;
typedef StgWord8 HsWord8;
typedef StgWord16 HsWord16;
typedef StgWord32 HsWord32;
typedef StgWord64 HsWord64;
typedef StgFloat HsFloat;
typedef StgDouble HsDouble;
typedef StgInt HsBool;
typedef void* HsPtr;
typedef void (*HsFunPtr)(void);
typedef void* HsStablePtr;


#define HS_CHAR_MIN 0
#define HS_CHAR_MAX 0x10FFFF


#define HS_BOOL_FALSE 0
#define HS_BOOL_TRUE 1

#define HS_BOOL_MIN HS_BOOL_FALSE
#define HS_BOOL_MAX HS_BOOL_TRUE


#define HS_INT_MIN STG_INT_MIN
#define HS_INT_MAX STG_INT_MAX
#define HS_WORD_MAX STG_WORD_MAX

#define HS_INT8_MIN STG_INT8_MIN
#define HS_INT8_MAX STG_INT8_MAX
#define HS_INT16_MIN STG_INT16_MIN
#define HS_INT16_MAX STG_INT16_MAX
#define HS_INT32_MIN STG_INT32_MIN
#define HS_INT32_MAX STG_INT32_MAX
#define HS_INT64_MIN STG_INT64_MIN
#define HS_INT64_MAX STG_INT64_MAX
#define HS_WORD8_MAX STG_WORD8_MAX
#define HS_WORD16_MAX STG_WORD16_MAX
#define HS_WORD32_MAX STG_WORD32_MAX
#define HS_WORD64_MAX STG_WORD64_MAX

#define HS_FLOAT_RADIX FLT_RADIX
#define HS_FLOAT_ROUNDS FLT_ROUNDS
#define HS_FLOAT_EPSILON FLT_EPSILON
#define HS_FLOAT_DIG FLT_DIG
#define HS_FLOAT_MANT_DIG FLT_MANT_DIG
#define HS_FLOAT_MIN FLT_MIN
#define HS_FLOAT_MIN_EXP FLT_MIN_EXP
#define HS_FLOAT_MIN_10_EXP FLT_MIN_10_EXP
#define HS_FLOAT_MAX FLT_MAX
#define HS_FLOAT_MAX_EXP FLT_MAX_EXP
#define HS_FLOAT_MAX_10_EXP FLT_MAX_10_EXP

#define HS_DOUBLE_RADIX DBL_RADIX
#define HS_DOUBLE_ROUNDS DBL_ROUNDS
#define HS_DOUBLE_EPSILON DBL_EPSILON
#define HS_DOUBLE_DIG DBL_DIG
#define HS_DOUBLE_MANT_DIG DBL_MANT_DIG
#define HS_DOUBLE_MIN DBL_MIN
#define HS_DOUBLE_MIN_EXP DBL_MIN_EXP
#define HS_DOUBLE_MIN_10_EXP DBL_MIN_10_EXP
#define HS_DOUBLE_MAX DBL_MAX
#define HS_DOUBLE_MAX_EXP DBL_MAX_EXP
#define HS_DOUBLE_MAX_10_EXP DBL_MAX_10_EXP

extern void hs_init (int *argc, char **argv[]);
extern void hs_exit (void);
extern void hs_exit_nowait(void);
extern void hs_set_argv (int argc, char *argv[]);
extern void hs_thread_done (void);
extern void hs_restoreConsoleCP (void);

extern void hs_perform_gc (void);
# 117 "includes/HsFFI.h"
extern void hs_lock_stable_ptr_table (void);


extern void hs_lock_stable_tables (void);


extern void hs_unlock_stable_ptr_table (void);


extern void hs_unlock_stable_tables (void);




extern void hs_free_stable_ptr_unsafe (HsStablePtr sp);

extern void hs_free_stable_ptr (HsStablePtr sp);
extern void hs_free_fun_ptr (HsFunPtr fp);

extern StgPtr hs_spt_lookup(StgWord64 key[2]);
extern int hs_spt_keys(StgPtr keys[], int szKeys);
extern int hs_spt_key_count (void);

extern void hs_try_putmvar (int capability, HsStablePtr sp);
# 41 "includes/Rts.h" 2
# 1 "includes/RtsAPI.h" 1
# 12 "includes/RtsAPI.h"
       






# 1 "includes/rts/Time.h" 1
# 12 "includes/rts/Time.h"
       




#define TIME_RESOLUTION 1000000000
typedef int64_t Time;

#define TIME_MAX HS_INT64_MAX



#define TimeToMS(t) ((t) / 1000000)
#define TimeToUS(t) ((t) / 1000)
#define TimeToNS(t) (t)
#define MSToTime(t) ((Time)(t) * 1000000)
#define USToTime(t) ((Time)(t) * 1000)
#define NSToTime(t) ((Time)(t))




#define SecondsToTime(t) ((Time)(t) * TIME_RESOLUTION)
#define TimeToSeconds(t) ((t) / TIME_RESOLUTION)
#define TimeToSecondsDbl(t) ((double)(t) / TIME_RESOLUTION)



static inline Time fsecondsToTime (double t)
{
    return (Time)(t * 1000000000);
}

Time getProcessElapsedTime (void);
# 20 "includes/RtsAPI.h" 2
# 1 "includes/rts/Types.h" 1
# 14 "includes/rts/Types.h"
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#define _STDDEF_H 
#define _STDDEF_H_ 

#define _ANSI_STDDEF_H 
# 137 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#define _PTRDIFF_T 
#define _T_PTRDIFF_ 
#define _T_PTRDIFF 
#define __PTRDIFF_T 
#define _PTRDIFF_T_ 
#define _BSD_PTRDIFF_T_ 
#define ___int_ptrdiff_t_h 
#define _GCC_PTRDIFF_T 
#define _PTRDIFF_T_DECLARED 




# 149 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 161 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 187 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#define __size_t__ 
#define __SIZE_T__ 
#define _SIZE_T 
#define _SYS_SIZE_T_H 
#define _T_SIZE_ 
#define _T_SIZE 
#define __SIZE_T 
#define _SIZE_T_ 
#define _BSD_SIZE_T_ 
#define _SIZE_T_DEFINED_ 
#define _SIZE_T_DEFINED 
#define _BSD_SIZE_T_DEFINED_ 
#define _SIZE_T_DECLARED 
#define ___int_size_t_h 
#define _GCC_SIZE_T 
#define _SIZET_ 







#define __size_t 





typedef long unsigned int size_t;
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_size_t
# 267 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#define __wchar_t__ 
#define __WCHAR_T__ 
#define _WCHAR_T 
#define _T_WCHAR_ 
#define _T_WCHAR 
#define __WCHAR_T 
#define _WCHAR_T_ 
#define _BSD_WCHAR_T_ 
#define _WCHAR_T_DEFINED_ 
#define _WCHAR_T_DEFINED 
#define _WCHAR_T_H 
#define ___int_wchar_t_h 
#define __INT_WCHAR_T_H 
#define _GCC_WCHAR_T 
#define _WCHAR_T_DECLARED 
# 294 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef _BSD_WCHAR_T_
# 328 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef int wchar_t;
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_wchar_t
# 401 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)




#define _GCC_MAX_ALIGN_T 



typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
} max_align_t;
# 17 "includes/rts/Types.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdbool.h" 1 3 4
# 29 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdbool.h" 3 4
#define _STDBOOL_H 



#define bool _Bool
#define true 1
#define false 0
# 52 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdbool.h" 3 4
#define __bool_true_false_are_defined 1
# 18 "includes/rts/Types.h" 2



# 20 "includes/rts/Types.h"
typedef unsigned int nat __attribute__((deprecated));



#define LL(x) (x ##LL)




typedef struct StgClosure_ StgClosure;
typedef struct StgInfoTable_ StgInfoTable;
typedef struct StgTSO_ StgTSO;
# 21 "includes/RtsAPI.h" 2




typedef enum {
    NoStatus,
    Success,
    Killed,
    Interrupted,
    HeapExhausted
} SchedulerStatus;

typedef struct StgClosure_ *HaskellObj;





typedef struct Capability_ Capability;




typedef struct PauseToken_ PauseToken;





Capability *pauseTokenCapability(PauseToken *pauseToken);





typedef struct CapabilityPublic_ {
    StgFunTable f;
    StgRegTable r;
} CapabilityPublic;


# 1 "includes/rts/EventLogWriter.h" 1
# 14 "includes/rts/EventLogWriter.h"
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 17 "includes/rts/EventLogWriter.h" 2





typedef struct {

    void (* initEventLogWriter) (void);




    
# 29 "includes/rts/EventLogWriter.h" 3 4
   _Bool 
# 29 "includes/rts/EventLogWriter.h"
        (* writeEventLog) (void *eventlog, size_t eventlog_size);




    void (* flushEventLog) (void);


    void (* stopEventLogWriter) (void);
} EventLogWriter;





extern const EventLogWriter FileEventLogWriter;




extern const EventLogWriter NullEventLogWriter;

enum EventLogStatus {

  EVENTLOG_NOT_SUPPORTED,

  EVENTLOG_NOT_CONFIGURED,

  EVENTLOG_RUNNING,
};




enum EventLogStatus eventLogStatus(void);







# 70 "includes/rts/EventLogWriter.h" 3 4
_Bool 
# 70 "includes/rts/EventLogWriter.h"
    startEventLogging(const EventLogWriter *writer);




void endEventLogging(void);




void flushEventLog(Capability **cap);
# 63 "includes/RtsAPI.h" 2





typedef enum {
    RtsOptsNone,
    RtsOptsIgnore,
    RtsOptsIgnoreAll,
    RtsOptsSafeOnly,
    RtsOptsAll
  } RtsOptsEnabledEnum;

struct GCDetails_;




typedef struct {


    RtsOptsEnabledEnum rts_opts_enabled;


    HsBool rts_opts_suggestions;


    const char *rts_opts;


    HsBool rts_hs_main;


    HsBool keep_cafs;


    const EventLogWriter *eventlog_writer;



    void (* defaultsHook) (void);


    void (* onExitHook) (void);


    void (* stackOverflowHook) (W_ stack_size);


    void (* outOfHeapHook) (W_ request_size, W_ heap_size);


    void (* mallocFailHook) (W_ request_size , const char *msg);


    void (* gcDoneHook) (const struct GCDetails_ *stats);


    void (* longGCSync) (uint32_t this_cap, Time time_ns);
    void (* longGCSyncEnd) (Time time_ns);
} RtsConfig;




extern const RtsConfig defaultRtsConfig;
# 137 "includes/RtsAPI.h"
typedef struct GCDetails_ {

  uint32_t gen;

  uint32_t threads;

  uint64_t allocated_bytes;



  uint64_t live_bytes;

  uint64_t large_objects_bytes;

  uint64_t compact_bytes;

  uint64_t slop_bytes;

  uint64_t mem_in_use_bytes;

  uint64_t copied_bytes;

  uint64_t par_max_copied_bytes;

  uint64_t par_balanced_copied_bytes;

  Time sync_elapsed_ns;

  Time cpu_ns;

  Time elapsed_ns;







  Time nonmoving_gc_sync_cpu_ns;


  Time nonmoving_gc_sync_elapsed_ns;


  Time nonmoving_gc_cpu_ns;


  Time nonmoving_gc_elapsed_ns;
} GCDetails;




typedef struct _RTSStats {





  uint32_t gcs;

  uint32_t major_gcs;

  uint64_t allocated_bytes;


  uint64_t max_live_bytes;

  uint64_t max_large_objects_bytes;

  uint64_t max_compact_bytes;

  uint64_t max_slop_bytes;

  uint64_t max_mem_in_use_bytes;


  uint64_t cumulative_live_bytes;

  uint64_t copied_bytes;

  uint64_t par_copied_bytes;

  uint64_t cumulative_par_max_copied_bytes;

  uint64_t cumulative_par_balanced_copied_bytes;







  Time init_cpu_ns;

  Time init_elapsed_ns;

  Time mutator_cpu_ns;

  Time mutator_elapsed_ns;

  Time gc_cpu_ns;

  Time gc_elapsed_ns;

  Time cpu_ns;

  Time elapsed_ns;




  GCDetails gc;




  uint64_t any_work;


  uint64_t scav_find_work;

  uint64_t max_n_todo_overflow;






  Time nonmoving_gc_sync_cpu_ns;


  Time nonmoving_gc_sync_elapsed_ns;


  Time nonmoving_gc_sync_max_elapsed_ns;


  Time nonmoving_gc_cpu_ns;


  Time nonmoving_gc_elapsed_ns;


  Time nonmoving_gc_max_elapsed_ns;
} RTSStats;

void getRTSStats (RTSStats *s);
int getRTSStatsEnabled (void);



uint64_t getAllocations (void);






extern void startupHaskell ( int argc, char *argv[],
                                     void (*init_root)(void) );


extern void shutdownHaskell ( void );



extern void hs_init_with_rtsopts (int *argc, char **argv[]);







extern void hs_init_ghc (int *argc, char **argv[],
                         RtsConfig rts_config);

extern void shutdownHaskellAndExit (int exitCode, int fastExit)
    __attribute__((__noreturn__));


extern void shutdownHaskellAndSignal (int sig, int fastExit)
     __attribute__((__noreturn__));


extern void getProgArgv ( int *argc, char **argv[] );
extern void setProgArgv ( int argc, char *argv[] );
extern void getFullProgArgv ( int *argc, char **argv[] );
extern void setFullProgArgv ( int argc, char *argv[] );
extern void freeFullProgArgv ( void ) ;


extern void (*exitFn)(int);
# 399 "includes/RtsAPI.h"
Capability *rts_lock (void);



void rts_unlock (Capability *token);
# 412 "includes/RtsAPI.h"
Capability *rts_unsafeGetMyCapability (void);
# 439 "includes/RtsAPI.h"
void rts_setInCallCapability (int preferred_capability, int affinity);





void rts_pinThreadToNumaNode (int node);




HaskellObj rts_mkChar ( Capability *, HsChar c );
HaskellObj rts_mkInt ( Capability *, HsInt i );
HaskellObj rts_mkInt8 ( Capability *, HsInt8 i );
HaskellObj rts_mkInt16 ( Capability *, HsInt16 i );
HaskellObj rts_mkInt32 ( Capability *, HsInt32 i );
HaskellObj rts_mkInt64 ( Capability *, HsInt64 i );
HaskellObj rts_mkWord ( Capability *, HsWord w );
HaskellObj rts_mkWord8 ( Capability *, HsWord8 w );
HaskellObj rts_mkWord16 ( Capability *, HsWord16 w );
HaskellObj rts_mkWord32 ( Capability *, HsWord32 w );
HaskellObj rts_mkWord64 ( Capability *, HsWord64 w );
HaskellObj rts_mkPtr ( Capability *, HsPtr a );
HaskellObj rts_mkFunPtr ( Capability *, HsFunPtr a );
HaskellObj rts_mkFloat ( Capability *, HsFloat f );
HaskellObj rts_mkDouble ( Capability *, HsDouble f );
HaskellObj rts_mkStablePtr ( Capability *, HsStablePtr s );
HaskellObj rts_mkBool ( Capability *, HsBool b );
HaskellObj rts_mkString ( Capability *, char *s );

HaskellObj rts_apply ( Capability *, HaskellObj, HaskellObj );




HsChar rts_getChar ( HaskellObj );
HsInt rts_getInt ( HaskellObj );
HsInt8 rts_getInt8 ( HaskellObj );
HsInt16 rts_getInt16 ( HaskellObj );
HsInt32 rts_getInt32 ( HaskellObj );
HsInt64 rts_getInt64 ( HaskellObj );
HsWord rts_getWord ( HaskellObj );
HsWord8 rts_getWord8 ( HaskellObj );
HsWord16 rts_getWord16 ( HaskellObj );
HsWord32 rts_getWord32 ( HaskellObj );
HsWord64 rts_getWord64 ( HaskellObj );
HsPtr rts_getPtr ( HaskellObj );
HsFunPtr rts_getFunPtr ( HaskellObj );
HsFloat rts_getFloat ( HaskellObj );
HsDouble rts_getDouble ( HaskellObj );
HsStablePtr rts_getStablePtr ( HaskellObj );
HsBool rts_getBool ( HaskellObj );
# 507 "includes/RtsAPI.h"
void rts_eval ( Capability **,
                           HaskellObj p,
                           HaskellObj *ret);

void rts_eval_ ( Capability **,
                            HaskellObj p,
                            unsigned int stack_size,
                            HaskellObj *ret);

void rts_evalIO ( Capability **,
                             HaskellObj p,
                             HaskellObj *ret);

void rts_evalStableIOMain ( Capability **,
                                       HsStablePtr s,
                                       HsStablePtr *ret);

void rts_evalStableIO ( Capability **,
                                   HsStablePtr s,
                                   HsStablePtr *ret);

void rts_evalLazyIO ( Capability **,
                                 HaskellObj p,
                                 HaskellObj *ret);

void rts_evalLazyIO_ ( Capability **,
                                  HaskellObj p,
                                  unsigned int stack_size,
                                  HaskellObj *ret);

void rts_inCall ( Capability **,
                             HaskellObj p,
                             HaskellObj *ret);

void rts_checkSchedStatus (char* site, Capability *);

SchedulerStatus rts_getSchedStatus (Capability *cap);



PauseToken *rts_pause (void);




void rts_resume (PauseToken *pauseToken);



# 555 "includes/RtsAPI.h" 3 4
_Bool 
# 555 "includes/RtsAPI.h"
    rts_isPaused(void);



typedef void (*ListThreadsCb)(void *user, StgTSO *);
void rts_listThreads(ListThreadsCb cb, void *user);



typedef void (*ListRootsCb)(void *user, StgClosure *);
void rts_listMiscRoots(ListRootsCb cb, void *user);
# 578 "includes/RtsAPI.h"
void rts_done (void);
# 596 "includes/RtsAPI.h"
extern StgWord base_GHCziTopHandler_runIO_closure[];
extern StgWord base_GHCziTopHandler_runNonIO_closure[];


#define runIO_closure base_GHCziTopHandler_runIO_closure
#define runNonIO_closure base_GHCziTopHandler_runNonIO_closure
# 42 "includes/Rts.h" 2



#undef STATIC_INLINE
#define STATIC_INLINE static



#define ATTR_ALWAYS_INLINE __attribute__((always_inline))
#define ATTR_NOINLINE __attribute__((noinline))






#define ATTRIBUTE_ALIGNED(n) __attribute__((aligned(n)))
# 67 "includes/Rts.h"
#define RTS_PRIVATE GNUC3_ATTRIBUTE(visibility("hidden"))





#define RTS_UNLIKELY(p) __builtin_expect((p),0)





#define RTS_LIKELY(p) __builtin_expect(!!(p), 1)






#define RTS_UNREACHABLE __builtin_unreachable()





#define prefetchForRead(ptr) __builtin_prefetch(ptr, 0)
#define prefetchForWrite(ptr) __builtin_prefetch(ptr, 1)
# 103 "includes/Rts.h"
#define _REENTRANT 1






#define ROUNDUP_BYTES_TO_WDS(n) (((n) + sizeof(W_) - 1) / sizeof(W_))

#define sizeofW(t) ROUNDUP_BYTES_TO_WDS(sizeof(t))
# 121 "includes/Rts.h"
void _assertFail(const char *filename, unsigned int linenum)
   __attribute__((__noreturn__));

void _warnFail(const char *filename, unsigned int linenum);

#define CHECK(predicate) if (RTS_LIKELY(predicate)) ; else _assertFail(__FILE__, __LINE__)





#define CHECKWARN(predicate) if (RTS_LIKELY(predicate)) ; else _warnFail(__FILE__, __LINE__)





#define CHECKM(predicate,msg,...) if (RTS_LIKELY(predicate)) ; else barf(msg, ##__VA_ARGS__)
# 149 "includes/Rts.h"
#define ASSERT(predicate) CHECK(predicate)
#define ASSERTM(predicate,msg,...) CHECKM(predicate,msg, ##__VA_ARGS__)
#define WARN(predicate) CHECKWARN(predicate)
#undef ASSERTS_ENABLED






#define GHC_STATIC_ASSERT(x,msg) _Static_assert((x), msg)
# 170 "includes/Rts.h"
#define doNothing() do { } while (0)


#define USED_IF_DEBUG 
#define USED_IF_NOT_DEBUG STG_UNUSED






#define USED_IF_THREADS 
#define USED_IF_NOT_THREADS STG_UNUSED






#define USED_IF_PROFILING 
#define USED_IF_NOT_PROFILING STG_UNUSED





#define FMT_SizeT "zu"
#define FMT_HexSizeT "zx"
# 208 "includes/Rts.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 27 "/usr/include/stdlib.h" 3 4
#define __need_size_t 

#define __need_wchar_t 
#define __need_NULL 

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 161 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_size_t
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_wchar_t
# 401 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 33 "/usr/include/stdlib.h" 2 3 4




#define _STDLIB_H 1



# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
#define WNOHANG 1
#define WUNTRACED 2


#define WSTOPPED 2
#define WEXITED 4
#define WCONTINUED 8
#define WNOWAIT 0x01000000

#define __WNOTHREAD 0x20000000

#define __WALL 0x40000000
#define __WCLONE 0x80000000




#define __ENUM_IDTYPE_T 1



#undef P_ALL
#undef P_PID
#undef P_PGID


# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
#define __WEXITSTATUS(status) (((status) & 0xff00) >> 8)


#define __WTERMSIG(status) ((status) & 0x7f)


#define __WSTOPSIG(status) __WEXITSTATUS(status)


#define __WIFEXITED(status) (__WTERMSIG(status) == 0)


#define __WIFSIGNALED(status) (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)



#define __WIFSTOPPED(status) (((status) & 0xff) == 0x7f)




#define __WIFCONTINUED(status) ((status) == __W_CONTINUED)



#define __WCOREDUMP(status) ((status) & __WCOREFLAG)


#define __W_EXITCODE(ret,sig) ((ret) << 8 | (sig))
#define __W_STOPCODE(sig) ((sig) << 8 | 0x7f)
#define __W_CONTINUED 0xffff
#define __WCOREFLAG 0x80




# 1 "/usr/include/endian.h" 1 3 4
# 19 "/usr/include/endian.h" 3 4
#define _ENDIAN_H 1
# 31 "/usr/include/endian.h" 3 4
#define __LITTLE_ENDIAN 1234
#define __BIG_ENDIAN 4321
#define __PDP_ENDIAN 3412


# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4






#define __BYTE_ORDER __LITTLE_ENDIAN
# 37 "/usr/include/endian.h" 2 3 4




#define __FLOAT_WORD_ORDER __BYTE_ORDER



#define LITTLE_ENDIAN __LITTLE_ENDIAN
#define BIG_ENDIAN __BIG_ENDIAN
#define PDP_ENDIAN __PDP_ENDIAN
#define BYTE_ORDER __BYTE_ORDER



#define __LONG_LONG_PAIR(HI,LO) LO, HI







# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
#define _BITS_BYTESWAP_H 1


# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#define _BITS_TYPES_H 1


# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64





#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 89 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#define __S16_TYPE short int
#define __U16_TYPE unsigned short int
#define __S32_TYPE int
#define __U32_TYPE unsigned int
#define __SLONGWORD_TYPE long int
#define __ULONGWORD_TYPE unsigned long int
# 108 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
#define __SQUAD_TYPE long int
#define __UQUAD_TYPE unsigned long int
#define __SWORD_TYPE long int
#define __UWORD_TYPE unsigned long int
#define __SLONG32_TYPE int
#define __ULONG32_TYPE unsigned int
#define __S64_TYPE long int
#define __U64_TYPE unsigned long int

#define __STD_TYPE typedef



# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 3 4
#define _BITS_TYPESIZES_H 1
# 34 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 3 4
#define __SYSCALL_SLONG_TYPE __SLONGWORD_TYPE
#define __SYSCALL_ULONG_TYPE __ULONGWORD_TYPE


#define __DEV_T_TYPE __UQUAD_TYPE
#define __UID_T_TYPE __U32_TYPE
#define __GID_T_TYPE __U32_TYPE
#define __INO_T_TYPE __SYSCALL_ULONG_TYPE
#define __INO64_T_TYPE __UQUAD_TYPE
#define __MODE_T_TYPE __U32_TYPE

#define __NLINK_T_TYPE __SYSCALL_ULONG_TYPE
#define __FSWORD_T_TYPE __SYSCALL_SLONG_TYPE




#define __OFF_T_TYPE __SYSCALL_SLONG_TYPE
#define __OFF64_T_TYPE __SQUAD_TYPE
#define __PID_T_TYPE __S32_TYPE
#define __RLIM_T_TYPE __SYSCALL_ULONG_TYPE
#define __RLIM64_T_TYPE __UQUAD_TYPE
#define __BLKCNT_T_TYPE __SYSCALL_SLONG_TYPE
#define __BLKCNT64_T_TYPE __SQUAD_TYPE
#define __FSBLKCNT_T_TYPE __SYSCALL_ULONG_TYPE
#define __FSBLKCNT64_T_TYPE __UQUAD_TYPE
#define __FSFILCNT_T_TYPE __SYSCALL_ULONG_TYPE
#define __FSFILCNT64_T_TYPE __UQUAD_TYPE
#define __ID_T_TYPE __U32_TYPE
#define __CLOCK_T_TYPE __SYSCALL_SLONG_TYPE
#define __TIME_T_TYPE __SYSCALL_SLONG_TYPE
#define __USECONDS_T_TYPE __U32_TYPE
#define __SUSECONDS_T_TYPE __SYSCALL_SLONG_TYPE
#define __DADDR_T_TYPE __S32_TYPE
#define __KEY_T_TYPE __S32_TYPE
#define __CLOCKID_T_TYPE __S32_TYPE
#define __TIMER_T_TYPE void *
#define __BLKSIZE_T_TYPE __SYSCALL_SLONG_TYPE
#define __FSID_T_TYPE struct { int __val[2]; }
#define __SSIZE_T_TYPE __SWORD_TYPE
#define __CPU_MASK_TYPE __SYSCALL_ULONG_TYPE





#define __OFF_T_MATCHES_OFF64_T 1


#define __INO_T_MATCHES_INO64_T 1



#define __FD_SETSIZE 1024
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;


#undef __STD_TYPE
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64





#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4


#define __bswap_constant_16(x) ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))



# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 3 4
#define __bswap_16(x) (__extension__ ({ unsigned short int __v, __x = (unsigned short int) (x); if (__builtin_constant_p (__x)) __v = __bswap_constant_16 (__x); else __asm__ ("rorw $8, %w0" : "=r" (__v) : "0" (__x) : "cc"); __v; }))
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4


#define __bswap_constant_32(x) ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >> 8) | (((x) & 0x0000ff00) << 8) | (((x) & 0x000000ff) << 24))





static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 97 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
#define __bswap_constant_64(x) (__extension__ ((((x) & 0xff00000000000000ull) >> 56) | (((x) & 0x00ff000000000000ull) >> 40) | (((x) & 0x0000ff0000000000ull) >> 24) | (((x) & 0x000000ff00000000ull) >> 8) | (((x) & 0x00000000ff000000ull) << 8) | (((x) & 0x0000000000ff0000ull) << 24) | (((x) & 0x000000000000ff00ull) << 40) | (((x) & 0x00000000000000ffull) << 56)))
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4


#define htobe16(x) __bswap_16 (x)
#define htole16(x) (x)
#define be16toh(x) __bswap_16 (x)
#define le16toh(x) (x)

#define htobe32(x) __bswap_32 (x)
#define htole32(x) (x)
#define be32toh(x) __bswap_32 (x)
#define le32toh(x) (x)

#define htobe64(x) __bswap_64 (x)
#define htole64(x) (x)
#define be64toh(x) __bswap_64 (x)
#define le64toh(x) (x)
# 65 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };

#define w_termsig __wait_terminated.__w_termsig
#define w_coredump __wait_terminated.__w_coredump
#define w_retcode __wait_terminated.__w_retcode
#define w_stopsig __wait_stopped.__w_stopsig
#define w_stopval __wait_stopped.__w_stopval
# 43 "/usr/include/stdlib.h" 2 3 4







#define __WAIT_INT(status) (__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
#define __WAIT_STATUS_DEFN int *
# 84 "/usr/include/stdlib.h" 3 4
#define WEXITSTATUS(status) __WEXITSTATUS (__WAIT_INT (status))
#define WTERMSIG(status) __WTERMSIG (__WAIT_INT (status))
#define WSTOPSIG(status) __WSTOPSIG (__WAIT_INT (status))
#define WIFEXITED(status) __WIFEXITED (__WAIT_INT (status))
#define WIFSIGNALED(status) __WIFSIGNALED (__WAIT_INT (status))
#define WIFSTOPPED(status) __WIFSTOPPED (__WAIT_INT (status))

#define WIFCONTINUED(status) __WIFCONTINUED (__WAIT_INT (status))





typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;
#define __ldiv_t_defined 1






__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
#define __lldiv_t_defined 1





#define RAND_MAX 2147483647




#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0



#define MB_CUR_MAX (__ctype_get_mb_cur_max ())
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 235 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 21 "/usr/include/xlocale.h" 3 4
#define _XLOCALE_H 1





typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 236 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
#define _SYS_TYPES_H 1









typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
#define __u_char_defined 



typedef __loff_t loff_t;



typedef __ino_t ino_t;



#define __ino_t_defined 


typedef __ino64_t ino64_t;
#define __ino64_t_defined 



typedef __dev_t dev_t;
#define __dev_t_defined 



typedef __gid_t gid_t;
#define __gid_t_defined 



typedef __mode_t mode_t;
#define __mode_t_defined 



typedef __nlink_t nlink_t;
#define __nlink_t_defined 



typedef __uid_t uid_t;
#define __uid_t_defined 




typedef __off_t off_t;



#define __off_t_defined 


typedef __off64_t off64_t;
#define __off64_t_defined 



typedef __pid_t pid_t;
#define __pid_t_defined 




typedef __id_t id_t;
#define __id_t_defined 



typedef __ssize_t ssize_t;
#define __ssize_t_defined 




typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
#define __daddr_t_defined 




typedef __key_t key_t;
#define __key_t_defined 



#define __need_clock_t 

#define __need_time_t 
#define __need_timer_t 
#define __need_clockid_t 
# 1 "/usr/include/time.h" 1 3 4
# 53 "/usr/include/time.h" 3 4
#define __clock_t_defined 1





typedef __clock_t clock_t;






#undef __need_clock_t


#define __time_t_defined 1





typedef __time_t time_t;






#undef __need_time_t



#define __clockid_t_defined 1




typedef __clockid_t clockid_t;


#undef __clockid_time_t



#define __timer_t_defined 1




typedef __timer_t timer_t;


#undef __need_timer_t
# 127 "/usr/include/time.h" 3 4
#undef __need_timespec
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;
#define __useconds_t_defined 


typedef __suseconds_t suseconds_t;
#define __suseconds_t_defined 



#define __need_size_t 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 161 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_size_t
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_wchar_t
# 401 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 187 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
#define __intN_t(N,MODE) typedef int int ##N ##_t __attribute__ ((__mode__ (MODE)))

#define __u_intN_t(N,MODE) typedef unsigned int u_int ##N ##_t __attribute__ ((__mode__ (MODE)))
# 200 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));





#define __BIT_TYPES_DEFINED__ 1







# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
#define _SYS_SELECT_H 1







# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64





#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4





#define __FD_ZERO_STOS "stosq"




#define __FD_ZERO(fdsp) do { int __d0, __d1; __asm__ __volatile__ ("cld; rep; " __FD_ZERO_STOS : "=c" (__d0), "=D" (__d1) : "a" (0), "0" (sizeof (fd_set) / sizeof (__fd_mask)), "1" (&__FDS_BITS (fdsp)[0]) : "memory"); } while (0)
# 58 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
#define __FD_SET(d,set) ((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))

#define __FD_CLR(d,set) ((void) (__FDS_BITS (set)[__FD_ELT (d)] &= ~__FD_MASK (d)))

#define __FD_ISSET(d,set) ((__FDS_BITS (set)[__FD_ELT (d)] & __FD_MASK (d)) != 0)
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
#define _SIGSET_H_types 1

typedef int __sig_atomic_t;



#define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))
typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


#define __sigset_t_defined 
typedef __sigset_t sigset_t;



#define __need_time_t 
#define __need_timespec 
# 1 "/usr/include/time.h" 1 3 4
# 66 "/usr/include/time.h" 3 4
#undef __need_clock_t
# 82 "/usr/include/time.h" 3 4
#undef __need_time_t
# 94 "/usr/include/time.h" 3 4
#undef __clockid_time_t
# 106 "/usr/include/time.h" 3 4
#undef __need_timer_t







#define __timespec_defined 1





struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };


#undef __need_timespec
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
#define __need_timeval 
# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
#define _STRUCT_TIMEVAL 1




struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 101 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
#undef __need_timeval
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 54 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;


#undef __NFDBITS

#define __NFDBITS (8 * (int) sizeof (__fd_mask))
#define __FD_ELT(d) ((d) / __NFDBITS)
#define __FD_MASK(d) ((__fd_mask) (1UL << ((d) % __NFDBITS)))


typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];
#define __FDS_BITS(set) ((set)->fds_bits)




  } fd_set;


#define FD_SETSIZE __FD_SETSIZE



typedef __fd_mask fd_mask;


#define NFDBITS __NFDBITS




#define FD_SET(fd,fdsetp) __FD_SET (fd, fdsetp)
#define FD_CLR(fd,fdsetp) __FD_CLR (fd, fdsetp)
#define FD_ISSET(fd,fdsetp) __FD_ISSET (fd, fdsetp)
#define FD_ZERO(fdsetp) __FD_ZERO (fdsetp)



# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
#define _SYS_SYSMACROS_H 1





__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4



#define major(dev) gnu_dev_major (dev)
#define minor(dev) gnu_dev_minor (dev)
#define makedev(maj,min) gnu_dev_makedev (maj, min)
# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;
#define __blksize_t_defined 





typedef __blkcnt_t blkcnt_t;
#define __blkcnt_t_defined 


typedef __fsblkcnt_t fsblkcnt_t;
#define __fsblkcnt_t_defined 


typedef __fsfilcnt_t fsfilcnt_t;
#define __fsfilcnt_t_defined 
# 262 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
#define _BITS_PTHREADTYPES_H 1

# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64





#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



#define __SIZEOF_PTHREAD_ATTR_T 56
#define __SIZEOF_PTHREAD_MUTEX_T 40
#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
#define __SIZEOF_PTHREAD_COND_T 48
#define __SIZEOF_PTHREAD_CONDATTR_T 4
#define __SIZEOF_PTHREAD_RWLOCK_T 56
#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
#define __SIZEOF_PTHREAD_BARRIER_T 32
#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;
#define __have_pthread_attr_t 1




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
#define __PTHREAD_MUTEX_HAVE_PREV 1

#define __PTHREAD_SPINS 0, 0
# 125 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    signed char __rwelision;




    unsigned char __pad1[7];
#define __PTHREAD_RWLOCK_ELISION_EXTRA 0, { 0, 0, 0, 0, 0, 0, 0 }

    unsigned long int __pad2;


    unsigned int __flags;
#define __PTHREAD_RWLOCK_INT_FLAGS_SHARED 1
  } __data;
# 220 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






#define __malloc_and_calloc_defined 


extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 19 "/usr/include/alloca.h" 3 4
#define _ALLOCA_H 1



#define __need_size_t 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 161 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_size_t
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_wchar_t
# 401 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 25 "/usr/include/alloca.h" 2 3 4




#undef alloca


extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));


#define alloca(size) __builtin_alloca (size)



# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;




extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 619 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 629 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 641 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 651 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 673 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 683 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 693 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;





#define __COMPAR_FN_T 
typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 811 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 898 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 955 "/usr/include/stdlib.h" 2 3 4
# 965 "/usr/include/stdlib.h" 3 4
#undef __need_malloc_and_calloc


# 209 "includes/Rts.h" 2

# 1 "includes/rts/Config.h" 1
# 16 "includes/rts/Config.h"
       
# 39 "includes/rts/Config.h"
#define TICKY_TICKY 
# 48 "includes/rts/Config.h"
#define RTS_USER_SIGNALS 1



#define PROF_SPIN 
# 211 "includes/Rts.h" 2


# 1 "includes/rts/Constants.h" 1
# 20 "includes/rts/Constants.h"
       
# 32 "includes/rts/Constants.h"
#define MIN_PAYLOAD_SIZE 1
# 43 "includes/rts/Constants.h"
#define MAX_SPEC_SELECTEE_SIZE 15







#define MAX_SPEC_AP_SIZE 7



#define MAX_SPEC_THUNK_SIZE 2
#define MAX_SPEC_FUN_SIZE 2
#define MAX_SPEC_CONSTR_SIZE 2






#define MAX_INTLIKE 255
#define MIN_INTLIKE (-16)

#define MAX_CHARLIKE 255
#define MIN_CHARLIKE 0






#define MUT_ARR_PTRS_CARD_BITS 7
# 84 "includes/rts/Constants.h"
#define MAX_VANILLA_REG 10
#define MAX_FLOAT_REG 6
#define MAX_DOUBLE_REG 6
#define MAX_LONG_REG 1
#define MAX_XMM_REG 6
# 104 "includes/rts/Constants.h"
#define INFO_OTHER_TAG (-1)
#define INFO_IND_TAG (-2)
#define INFO_FIRST_TAG 0






#define RESERVED_C_STACK_BYTES (2048 * SIZEOF_LONG)
# 128 "includes/rts/Constants.h"
#define STG_RUN_STACK_FRAME_SIZE 48
# 141 "includes/rts/Constants.h"
#define STG_RUN "StgRun"
#define STG_RUN_JMP StgRunJmp
#define STG_RETURN "StgReturn"
# 156 "includes/rts/Constants.h"
#define RESERVED_STACK_WORDS 21






#define AP_STACK_SPLIM 1024






#define BLOCK_SHIFT 12


#define MBLOCK_SHIFT 20
# 188 "includes/rts/Constants.h"
#define BITMAP_SIZE_MASK 0x3f
#define BITMAP_BITS_SHIFT 6
# 203 "includes/rts/Constants.h"
#define LDV_SHIFT 30
#define LDV_STATE_MASK 0x1000000000000000
#define LDV_CREATE_MASK 0x0FFFFFFFC0000000
#define LDV_LAST_MASK 0x000000003FFFFFFF
#define LDV_STATE_CREATE 0x0000000000000000
#define LDV_STATE_USE 0x1000000000000000
# 226 "includes/rts/Constants.h"
#define ThreadRunGHC 1
#define ThreadInterpret 2
#define ThreadKilled 3
#define ThreadComplete 4





#define NotBlocked 0
#define BlockedOnMVar 1
#define BlockedOnMVarRead 14
#define BlockedOnBlackHole 2
#define BlockedOnRead 3
#define BlockedOnWrite 4
#define BlockedOnDelay 5
#define BlockedOnSTM 6


#define BlockedOnDoProc 7


#define BlockedOnCCall 10
#define BlockedOnCCall_Interruptible 11



#define BlockedOnMsgThrowTo 12



#define ThreadMigrating 13
# 266 "includes/rts/Constants.h"
#define HeapOverflow 1
#define StackOverflow 2
#define ThreadYielding 3
#define ThreadBlocked 4
#define ThreadFinished 5
# 279 "includes/rts/Constants.h"
#define TSO_LOCKED 2
# 289 "includes/rts/Constants.h"
#define TSO_BLOCKEX 4
#define TSO_INTERRUPTIBLE 8
#define TSO_STOPPED_ON_BREAKPOINT 16





#define TSO_MARKED 64






#define TSO_SQUEEZED 128





#define TSO_ALLOC_LIMIT 256
# 319 "includes/rts/Constants.h"
#define SPIN_COUNT 1000
# 328 "includes/rts/Constants.h"
#define MAX_SPARE_WORKERS 6





#define MAX_NUMA_NODES 16
# 214 "includes/Rts.h" 2


# 1 "includes/rts/Flags.h" 1
# 14 "includes/rts/Flags.h"
       

# 1 "/usr/include/stdio.h" 1 3 4
# 26 "/usr/include/stdio.h" 3 4
#define _STDIO_H 1




#define __need_size_t 
#define __need_NULL 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 161 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_size_t
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_wchar_t
# 401 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 34 "/usr/include/stdio.h" 2 3 4


#define __need_FILE 
#define __need___FILE 






struct _IO_FILE;



typedef struct _IO_FILE FILE;







#define __FILE_defined 1

#undef __need_FILE





typedef struct _IO_FILE __FILE;

#define ____FILE_defined 1

#undef __need___FILE



#define _STDIO_USES_IOSTREAM 

# 1 "/usr/include/libio.h" 1 3 4
# 29 "/usr/include/libio.h" 3 4
#define _IO_STDIO_H 

# 1 "/usr/include/_G_config.h" 1 3 4




#define _G_config_h 1




#define __need_size_t 



#define __need_NULL 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 161 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_size_t
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_wchar_t
# 401 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 16 "/usr/include/_G_config.h" 2 3 4
#define __need_mbstate_t 



# 1 "/usr/include/wchar.h" 1 3 4
# 80 "/usr/include/wchar.h" 3 4
#define ____mbstate_t_defined 1

typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;

#undef __need_mbstate_t
# 902 "/usr/include/wchar.h" 3 4
#undef __need_mbstate_t
#undef __need_wint_t
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 46 "/usr/include/_G_config.h" 3 4
#define _G_va_list __gnuc_va_list

#define _G_HAVE_MMAP 1
#define _G_HAVE_MREMAP 1

#define _G_IO_IO_FILE_VERSION 0x20001


#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)

#define _G_BUFSIZ 8192
# 32 "/usr/include/libio.h" 2 3 4

#define _IO_fpos_t _G_fpos_t
#define _IO_fpos64_t _G_fpos64_t
#define _IO_size_t size_t
#define _IO_ssize_t __ssize_t
#define _IO_off_t __off_t
#define _IO_off64_t __off64_t
#define _IO_pid_t __pid_t
#define _IO_uid_t __uid_t
#define _IO_iconv_t _G_iconv_t
#define _IO_HAVE_ST_BLKSIZE _G_HAVE_ST_BLKSIZE
#define _IO_BUFSIZ _G_BUFSIZ
#define _IO_va_list _G_va_list
#define _IO_wint_t wint_t


#define __need___va_list 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
#undef __need___va_list




#define __GNUC_VA_LIST 
typedef __builtin_va_list __gnuc_va_list;
# 50 "/usr/include/libio.h" 2 3 4

#undef _IO_va_list
#define _IO_va_list __gnuc_va_list






#define _IO_UNIFIED_JUMPTABLES 1


#define EOF (-1)
# 77 "/usr/include/libio.h" 3 4
#define _IOS_INPUT 1
#define _IOS_OUTPUT 2
#define _IOS_ATEND 4
#define _IOS_APPEND 8
#define _IOS_TRUNC 16
#define _IOS_NOCREATE 32
#define _IOS_NOREPLACE 64
#define _IOS_BIN 128







#define _IO_MAGIC 0xFBAD0000
#define _OLD_STDIO_MAGIC 0xFABC0000
#define _IO_MAGIC_MASK 0xFFFF0000
#define _IO_USER_BUF 1
#define _IO_UNBUFFERED 2
#define _IO_NO_READS 4
#define _IO_NO_WRITES 8
#define _IO_EOF_SEEN 0x10
#define _IO_ERR_SEEN 0x20
#define _IO_DELETE_DONT_CLOSE 0x40
#define _IO_LINKED 0x80
#define _IO_IN_BACKUP 0x100
#define _IO_LINE_BUF 0x200
#define _IO_TIED_PUT_GET 0x400
#define _IO_CURRENTLY_PUTTING 0x800
#define _IO_IS_APPENDING 0x1000
#define _IO_IS_FILEBUF 0x2000
#define _IO_BAD_SEEN 0x4000
#define _IO_USER_LOCK 0x8000

#define _IO_FLAGS2_MMAP 1
#define _IO_FLAGS2_NOTCANCEL 2



#define _IO_FLAGS2_USER_WBUF 8







#define _IO_SKIPWS 01
#define _IO_LEFT 02
#define _IO_RIGHT 04
#define _IO_INTERNAL 010
#define _IO_DEC 020
#define _IO_OCT 040
#define _IO_HEX 0100
#define _IO_SHOWBASE 0200
#define _IO_SHOWPOINT 0400
#define _IO_UPPERCASE 01000
#define _IO_SHOWPOS 02000
#define _IO_SCIENTIFIC 04000
#define _IO_FIXED 010000
#define _IO_UNITBUF 020000
#define _IO_STDIO 040000
#define _IO_DONT_CLOSE 0100000
#define _IO_BOOLALPHA 0200000


struct _IO_jump_t; struct _IO_FILE;





typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 173 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 241 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;
#define _IO_file_flags _flags



  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;

#define __HAVE_COLUMN 

  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 289 "/usr/include/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;

#define _IO_stdin ((_IO_FILE*)(&_IO_2_1_stdin_))
#define _IO_stdout ((_IO_FILE*)(&_IO_2_1_stdout_))
#define _IO_stderr ((_IO_FILE*)(&_IO_2_1_stderr_))
# 333 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);







#define _IO_BE(expr,res) __builtin_expect ((expr), res)




#define _IO_getc_unlocked(_fp) (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) ? __uflow (_fp) : *(unsigned char *) (_fp)->_IO_read_ptr++)


#define _IO_peekc_unlocked(_fp) (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) && __underflow (_fp) == EOF ? EOF : *(unsigned char *) (_fp)->_IO_read_ptr)



#define _IO_putc_unlocked(_ch,_fp) (_IO_BE ((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end, 0) ? __overflow (_fp, (unsigned char) (_ch)) : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))
# 426 "/usr/include/libio.h" 3 4
#define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)
#define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)

extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);


#define _IO_PENDING_OUTPUT_COUNT(_fp) ((_fp)->_IO_write_ptr - (_fp)->_IO_write_base)


extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 451 "/usr/include/libio.h" 3 4
#define _IO_peekc(_fp) _IO_peekc_unlocked (_fp)
#define _IO_flockfile(_fp) 
#define _IO_funlockfile(_fp) 
#define _IO_ftrylockfile(_fp) 
#define _IO_cleanup_region_start(_fct,_fp) 
#define _IO_cleanup_region_end(_Doit) 


extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
#define _VA_LIST_DEFINED 
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;



#define _IOFBF 0
#define _IOLBF 1
#define _IONBF 2




#define BUFSIZ _IO_BUFSIZ
# 140 "/usr/include/stdio.h" 3 4
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

#define SEEK_DATA 3
#define SEEK_HOLE 4





#define P_tmpdir "/tmp"
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 3 4
#define L_tmpnam 20
#define TMP_MAX 238328
#define FILENAME_MAX 4096


#define L_ctermid 9

#define L_cuserid 9





#undef FOPEN_MAX
#define FOPEN_MAX 16
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;

#define stdin stdin
#define stdout stdout
#define stderr stderr



extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);




#define getc(_fp) _IO_getc (_fp)






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);




#define putc(_ch,_fp) _IO_putc (_ch, _fp)
# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 640 "/usr/include/stdio.h" 3 4

# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 872 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 942 "/usr/include/stdio.h" 3 4

# 17 "includes/rts/Flags.h" 2
# 31 "includes/rts/Flags.h"

# 31 "includes/rts/Flags.h"
typedef struct _GC_FLAGS {
    FILE *statsFile;
    uint32_t giveStats;
#define NO_GC_STATS 0
#define COLLECT_GC_STATS 1
#define ONELINE_GC_STATS 2
#define SUMMARY_GC_STATS 3
#define VERBOSE_GC_STATS 4

    uint32_t maxStkSize;
    uint32_t initialStkSize;
    uint32_t stkChunkSize;
    uint32_t stkChunkBufferSize;

    uint32_t maxHeapSize;
    uint32_t minAllocAreaSize;
    uint32_t largeAllocLim;
    uint32_t nurseryChunkSize;
    uint32_t minOldGenSize;
    uint32_t heapSizeSuggestion;
    
# 51 "includes/rts/Flags.h" 3 4
   _Bool 
# 51 "includes/rts/Flags.h"
        heapSizeSuggestionAuto;
    double oldGenFactor;
    double returnDecayFactor;
    double pcFreeHeap;

    
# 56 "includes/rts/Flags.h" 3 4
   _Bool 
# 56 "includes/rts/Flags.h"
                useNonmoving;
    uint32_t generations;
    
# 58 "includes/rts/Flags.h" 3 4
   _Bool 
# 58 "includes/rts/Flags.h"
        squeezeUpdFrames;

    
# 60 "includes/rts/Flags.h" 3 4
   _Bool 
# 60 "includes/rts/Flags.h"
        compact;
    double compactThreshold;

    
# 63 "includes/rts/Flags.h" 3 4
   _Bool 
# 63 "includes/rts/Flags.h"
        sweep;

    
# 65 "includes/rts/Flags.h" 3 4
   _Bool 
# 65 "includes/rts/Flags.h"
        ringBell;

    Time idleGCDelayTime;
    Time interIdleGCWait;
    
# 69 "includes/rts/Flags.h" 3 4
   _Bool 
# 69 "includes/rts/Flags.h"
        doIdleGC;

    Time longGCSync;

    StgWord heapBase;

    StgWord allocLimitGrace;






    StgWord heapLimitGrace;






    
# 89 "includes/rts/Flags.h" 3 4
   _Bool 
# 89 "includes/rts/Flags.h"
        numa;
    StgWord numaMask;
} GC_FLAGS;


typedef struct _DEBUG_FLAGS {

    
# 96 "includes/rts/Flags.h" 3 4
   _Bool 
# 96 "includes/rts/Flags.h"
        scheduler;
    
# 97 "includes/rts/Flags.h" 3 4
   _Bool 
# 97 "includes/rts/Flags.h"
        interpreter;
    
# 98 "includes/rts/Flags.h" 3 4
   _Bool 
# 98 "includes/rts/Flags.h"
        weak;
    
# 99 "includes/rts/Flags.h" 3 4
   _Bool 
# 99 "includes/rts/Flags.h"
        gccafs;
    
# 100 "includes/rts/Flags.h" 3 4
   _Bool 
# 100 "includes/rts/Flags.h"
        gc;
    
# 101 "includes/rts/Flags.h" 3 4
   _Bool 
# 101 "includes/rts/Flags.h"
        nonmoving_gc;
    
# 102 "includes/rts/Flags.h" 3 4
   _Bool 
# 102 "includes/rts/Flags.h"
        block_alloc;
    
# 103 "includes/rts/Flags.h" 3 4
   _Bool 
# 103 "includes/rts/Flags.h"
        sanity;
    
# 104 "includes/rts/Flags.h" 3 4
   _Bool 
# 104 "includes/rts/Flags.h"
        zero_on_gc;
    
# 105 "includes/rts/Flags.h" 3 4
   _Bool 
# 105 "includes/rts/Flags.h"
        stable;
    
# 106 "includes/rts/Flags.h" 3 4
   _Bool 
# 106 "includes/rts/Flags.h"
        prof;
    
# 107 "includes/rts/Flags.h" 3 4
   _Bool 
# 107 "includes/rts/Flags.h"
        linker;
    
# 108 "includes/rts/Flags.h" 3 4
   _Bool 
# 108 "includes/rts/Flags.h"
        apply;
    
# 109 "includes/rts/Flags.h" 3 4
   _Bool 
# 109 "includes/rts/Flags.h"
        stm;
    
# 110 "includes/rts/Flags.h" 3 4
   _Bool 
# 110 "includes/rts/Flags.h"
        squeeze;
    
# 111 "includes/rts/Flags.h" 3 4
   _Bool 
# 111 "includes/rts/Flags.h"
        hpc;
    
# 112 "includes/rts/Flags.h" 3 4
   _Bool 
# 112 "includes/rts/Flags.h"
        sparks;
    
# 113 "includes/rts/Flags.h" 3 4
   _Bool 
# 113 "includes/rts/Flags.h"
        numa;
    
# 114 "includes/rts/Flags.h" 3 4
   _Bool 
# 114 "includes/rts/Flags.h"
        compact;
} DEBUG_FLAGS;


typedef struct _COST_CENTRE_FLAGS {
    uint32_t doCostCentres;
#define COST_CENTRES_NONE 0
#define COST_CENTRES_SUMMARY 1
#define COST_CENTRES_VERBOSE 2
#define COST_CENTRES_ALL 3
#define COST_CENTRES_JSON 4

    int profilerTicks;
    int msecsPerTick;
    char const *outputFileNameStem;
} COST_CENTRE_FLAGS;


typedef struct _PROFILING_FLAGS {
    uint32_t doHeapProfile;
#define NO_HEAP_PROFILING 0
#define HEAP_BY_CCS 1
#define HEAP_BY_MOD 2
#define HEAP_BY_DESCR 4
#define HEAP_BY_TYPE 5
#define HEAP_BY_RETAINER 6
#define HEAP_BY_LDV 7

#define HEAP_BY_CLOSURE_TYPE 8
#define HEAP_BY_INFO_TABLE 9

    Time heapProfileInterval;
    uint32_t heapProfileIntervalTicks;
    
# 147 "includes/rts/Flags.h" 3 4
   _Bool 
# 147 "includes/rts/Flags.h"
               startHeapProfileAtStartup;


    
# 150 "includes/rts/Flags.h" 3 4
   _Bool 
# 150 "includes/rts/Flags.h"
         showCCSOnException;

    uint32_t maxRetainerSetSize;

    uint32_t ccsLength;

    const char* modSelector;
    const char* descrSelector;
    const char* typeSelector;
    const char* ccSelector;
    const char* ccsSelector;
    const char* retainerSelector;
    const char* bioSelector;

} PROFILING_FLAGS;

#define TRACE_NONE 0
#define TRACE_EVENTLOG 1
#define TRACE_STDERR 2


typedef struct _TRACE_FLAGS {
    int tracing;
    
# 173 "includes/rts/Flags.h" 3 4
   _Bool 
# 173 "includes/rts/Flags.h"
        timestamp;
    
# 174 "includes/rts/Flags.h" 3 4
   _Bool 
# 174 "includes/rts/Flags.h"
        scheduler;
    
# 175 "includes/rts/Flags.h" 3 4
   _Bool 
# 175 "includes/rts/Flags.h"
        gc;
    
# 176 "includes/rts/Flags.h" 3 4
   _Bool 
# 176 "includes/rts/Flags.h"
        nonmoving_gc;
    
# 177 "includes/rts/Flags.h" 3 4
   _Bool 
# 177 "includes/rts/Flags.h"
        sparks_sampled;
    
# 178 "includes/rts/Flags.h" 3 4
   _Bool 
# 178 "includes/rts/Flags.h"
        sparks_full;
    
# 179 "includes/rts/Flags.h" 3 4
   _Bool 
# 179 "includes/rts/Flags.h"
        ticky;
    
# 180 "includes/rts/Flags.h" 3 4
   _Bool 
# 180 "includes/rts/Flags.h"
        user;
    Time eventlogFlushTime;
    int eventlogFlushTicks;
    char *trace_output;
    
# 184 "includes/rts/Flags.h" 3 4
   _Bool 
# 184 "includes/rts/Flags.h"
        nullWriter;
} TRACE_FLAGS;


typedef struct _CONCURRENT_FLAGS {
    Time ctxtSwitchTime;
    int ctxtSwitchTicks;
} CONCURRENT_FLAGS;
# 200 "includes/rts/Flags.h"
#define DEFAULT_TICK_INTERVAL USToTime(10000)
# 212 "includes/rts/Flags.h"
#define DEFAULT_LINKER_ALWAYS_PIC false



typedef enum _IO_MANAGER { IO_MNGR_NATIVE, IO_MNGR_POSIX } IO_MANAGER;


typedef struct _MISC_FLAGS {
    Time tickInterval;
    
# 221 "includes/rts/Flags.h" 3 4
   _Bool 
# 221 "includes/rts/Flags.h"
        install_signal_handlers;
    
# 222 "includes/rts/Flags.h" 3 4
   _Bool 
# 222 "includes/rts/Flags.h"
        install_seh_handlers;
    
# 223 "includes/rts/Flags.h" 3 4
   _Bool 
# 223 "includes/rts/Flags.h"
        generate_dump_file;
    
# 224 "includes/rts/Flags.h" 3 4
   _Bool 
# 224 "includes/rts/Flags.h"
        generate_stack_trace;
    
# 225 "includes/rts/Flags.h" 3 4
   _Bool 
# 225 "includes/rts/Flags.h"
        machineReadable;
    
# 226 "includes/rts/Flags.h" 3 4
   _Bool 
# 226 "includes/rts/Flags.h"
        disableDelayedOsMemoryReturn;





    
# 232 "includes/rts/Flags.h" 3 4
   _Bool 
# 232 "includes/rts/Flags.h"
        internalCounters;
    
# 233 "includes/rts/Flags.h" 3 4
   _Bool 
# 233 "includes/rts/Flags.h"
        linkerAlwaysPic;
    StgWord linkerMemBase;

    IO_MANAGER ioManager;
    uint32_t numIoWorkerThreads;
} MISC_FLAGS;


typedef struct _PAR_FLAGS {
  uint32_t nCapabilities;
  
# 243 "includes/rts/Flags.h" 3 4
 _Bool 
# 243 "includes/rts/Flags.h"
                migrate;
  uint32_t maxLocalSparks;
  
# 245 "includes/rts/Flags.h" 3 4
 _Bool 
# 245 "includes/rts/Flags.h"
                parGcEnabled;
  uint32_t parGcGen;

  
# 248 "includes/rts/Flags.h" 3 4
 _Bool 
# 248 "includes/rts/Flags.h"
                parGcLoadBalancingEnabled;


  uint32_t parGcLoadBalancingGen;



  uint32_t parGcNoSyncWithIdle;






  uint32_t parGcThreads;



  
# 266 "includes/rts/Flags.h" 3 4
 _Bool 
# 266 "includes/rts/Flags.h"
                setAffinity;
} PAR_FLAGS;


typedef struct _TICKY_FLAGS {
    
# 271 "includes/rts/Flags.h" 3 4
   _Bool 
# 271 "includes/rts/Flags.h"
        showTickyStats;
    FILE *tickyFile;
} TICKY_FLAGS;




typedef struct _RTS_FLAGS {

    GC_FLAGS GcFlags;
    CONCURRENT_FLAGS ConcFlags;
    MISC_FLAGS MiscFlags;
    DEBUG_FLAGS DebugFlags;
    COST_CENTRE_FLAGS CcFlags;
    PROFILING_FLAGS ProfFlags;
    TRACE_FLAGS TraceFlags;
    TICKY_FLAGS TickyFlags;
    PAR_FLAGS ParFlags;
} RTS_FLAGS;
# 301 "includes/rts/Flags.h"
extern RTS_FLAGS RtsFlags;
# 310 "includes/rts/Flags.h"
#define STATS_FILENAME_MAXLEN 128

#define GR_FILENAME_FMT "%0.124s.gr"
#define HP_FILENAME_FMT "%0.124s.hp"
#define LIFE_FILENAME_FMT "%0.122s.life"
#define PROF_FILENAME_FMT "%0.122s.prof"
#define PROF_FILENAME_FMT_GUM "%0.118s.%03d.prof"
#define QP_FILENAME_FMT "%0.124s.qp"
#define STAT_FILENAME_FMT "%0.122s.stat"
#define TICKY_FILENAME_FMT "%0.121s.ticky"
#define TIME_FILENAME_FMT "%0.122s.time"
#define TIME_FILENAME_FMT_GUM "%0.118s.%03d.time"






extern int rts_argc;
extern char **rts_argv;
# 217 "includes/Rts.h" 2


# 1 "includes/rts/prof/CCS.h" 1
# 14 "includes/rts/prof/CCS.h"
       
# 28 "includes/rts/prof/CCS.h"
typedef struct CostCentre_ {
    StgInt ccID;

    char * label;
    char * module;
    char * srcloc;


    StgWord64 mem_alloc;
    StgWord time_ticks;

    StgBool is_caf;

    struct CostCentre_ *link;
} CostCentre;

typedef struct CostCentreStack_ {
    StgInt ccsID;

    CostCentre *cc;

    struct CostCentreStack_ *prevStack;
    struct IndexTable_ *indexTable;
    struct CostCentreStack_ *root;
    StgWord depth;

    StgWord64 scc_count;


    StgWord selected;



    StgWord time_ticks;


    StgWord64 mem_alloc;


    StgWord64 inherited_alloc;



    StgWord inherited_ticks;

} CostCentreStack;
# 82 "includes/rts/prof/CCS.h"
void stopProfTimer ( void );
void startProfTimer ( void );
# 95 "includes/rts/prof/CCS.h"
#define EMPTY_STACK NULL
#define EMPTY_TABLE NULL


#define CC_IS_CAF true
#define CC_NOT_CAF false
# 110 "includes/rts/prof/CCS.h"
typedef struct IndexTable_ {


    CostCentre *cc;
    CostCentreStack *ccs;
    struct IndexTable_ *next;



    
# 119 "includes/rts/prof/CCS.h" 3 4
   _Bool 
# 119 "includes/rts/prof/CCS.h"
        back_edge;
} IndexTable;
# 146 "includes/rts/prof/CCS.h"
extern CostCentre CC_MAIN[];
extern CostCentreStack CCS_MAIN[];

extern CostCentre CC_SYSTEM[];
extern CostCentreStack CCS_SYSTEM[];

extern CostCentre CC_GC[];
extern CostCentreStack CCS_GC[];

extern CostCentre CC_OVERHEAD[];
extern CostCentreStack CCS_OVERHEAD[];

extern CostCentre CC_DONT_CARE[];
extern CostCentreStack CCS_DONT_CARE[];

extern CostCentre CC_PINNED[];
extern CostCentreStack CCS_PINNED[];

extern CostCentre CC_IDLE[];
extern CostCentreStack CCS_IDLE[];



extern unsigned int era;





CostCentreStack * pushCostCentre (CostCentreStack *, CostCentre *);
void enterFunCCS (StgRegTable *reg, CostCentreStack *);
CostCentre *mkCostCentre (char *label, char *module, char *srcloc);

extern CostCentre * CC_LIST;





#define CC_DECLARE(cc_ident,name,mod,loc,caf,is_local) is_local CostCentre cc_ident[1] = {{ .ccID = 0, .label = name, .module = mod, .srcloc = loc, .time_ticks = 0, .mem_alloc = 0, .link = 0, .is_caf = caf }};
# 197 "includes/rts/prof/CCS.h"
#define CCS_DECLARE(ccs_ident,cc_ident,is_local) is_local CostCentreStack ccs_ident[1] = {{ .ccsID = 0, .cc = cc_ident, .prevStack = NULL, .indexTable = NULL, .root = NULL, .depth = 0, .selected = 0, .scc_count = 0, .time_ticks = 0, .mem_alloc = 0, .inherited_ticks = 0, .inherited_alloc = 0 }};
# 218 "includes/rts/prof/CCS.h"
#define CCS_ALLOC(ccs,size) (ccs)->mem_alloc += ((size)-sizeofW(StgProfHeader))
#define ENTER_CCS_THUNK(cap,p) cap->r.rCCCS = p->header.prof.ccs
# 220 "includes/Rts.h" 2
# 1 "includes/rts/prof/Heap.h" 1
# 14 "includes/rts/prof/Heap.h"
       







void requestHeapCensus ( void );
void startHeapProfTimer ( void );
void stopHeapProfTimer ( void );
# 221 "includes/Rts.h" 2
# 1 "includes/rts/prof/LDV.h" 1
# 14 "includes/rts/prof/LDV.h"
       




#define LDVW(c) (((StgClosure *)(c))->header.prof.hp.ldvw)
# 35 "includes/rts/prof/LDV.h"
#define LDV_RECORD_CREATE(c) LDVW((c)) = ((StgWord)RTS_DEREF(era) << LDV_SHIFT) | LDV_STATE_CREATE
# 222 "includes/Rts.h" 2


# 1 "includes/rts/OSThreads.h" 1
# 15 "includes/rts/OSThreads.h"
       
# 27 "includes/rts/OSThreads.h"
# 1 "/usr/include/pthread.h" 1 3 4
# 19 "/usr/include/pthread.h" 3 4
#define _PTHREAD_H 1



# 1 "/usr/include/sched.h" 1 3 4
# 20 "/usr/include/sched.h" 3 4
#define _SCHED_H 1






#define __need_size_t 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 161 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_size_t
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_wchar_t
# 401 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 29 "/usr/include/sched.h" 2 3 4


#define __need_time_t 
#define __need_timespec 

# 1 "/usr/include/time.h" 1 3 4
# 66 "/usr/include/time.h" 3 4
#undef __need_clock_t
# 82 "/usr/include/time.h" 3 4
#undef __need_time_t
# 94 "/usr/include/time.h" 3 4
#undef __clockid_time_t
# 106 "/usr/include/time.h" 3 4
#undef __need_timer_t
# 127 "/usr/include/time.h" 3 4
#undef __need_timespec
# 35 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
#define SCHED_OTHER 0
#define SCHED_FIFO 1
#define SCHED_RR 2

#define SCHED_BATCH 3
#define SCHED_IDLE 5

#define SCHED_RESET_ON_FORK 0x40000000




#define CSIGNAL 0x000000ff
#define CLONE_VM 0x00000100
#define CLONE_FS 0x00000200
#define CLONE_FILES 0x00000400
#define CLONE_SIGHAND 0x00000800
#define CLONE_PTRACE 0x00002000
#define CLONE_VFORK 0x00004000

#define CLONE_PARENT 0x00008000

#define CLONE_THREAD 0x00010000
#define CLONE_NEWNS 0x00020000
#define CLONE_SYSVSEM 0x00040000
#define CLONE_SETTLS 0x00080000
#define CLONE_PARENT_SETTID 0x00100000

#define CLONE_CHILD_CLEARTID 0x00200000

#define CLONE_DETACHED 0x00400000
#define CLONE_UNTRACED 0x00800000

#define CLONE_CHILD_SETTID 0x01000000

#define CLONE_NEWUTS 0x04000000
#define CLONE_NEWIPC 0x08000000
#define CLONE_NEWUSER 0x10000000
#define CLONE_NEWPID 0x20000000
#define CLONE_NEWNET 0x40000000
#define CLONE_IO 0x80000000




# 72 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };





extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) __attribute__ ((__nothrow__ , __leaf__));


extern int unshare (int __flags) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getcpu (void) __attribute__ ((__nothrow__ , __leaf__));


extern int setns (int __fd, int __nstype) __attribute__ ((__nothrow__ , __leaf__));









#define __defined_schedparam 1

struct __sched_param
  {
    int __sched_priority;
  };
#undef __need_schedparam




#define __cpu_set_t_defined 

#define __CPU_SETSIZE 1024
#define __NCPUBITS (8 * sizeof (__cpu_mask))


typedef unsigned long int __cpu_mask;


#define __CPUELT(cpu) ((cpu) / __NCPUBITS)
#define __CPUMASK(cpu) ((__cpu_mask) 1 << ((cpu) % __NCPUBITS))


typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;



#define __CPU_ZERO_S(setsize,cpusetp) do __builtin_memset (cpusetp, '\0', setsize); while (0)
# 144 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
#define __CPU_SET_S(cpu,setsize,cpusetp) (__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] |= __CPUMASK (__cpu)) : 0; }))






#define __CPU_CLR_S(cpu,setsize,cpusetp) (__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] &= ~__CPUMASK (__cpu)) : 0; }))






#define __CPU_ISSET_S(cpu,setsize,cpusetp) (__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? ((((const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] & __CPUMASK (__cpu))) != 0 : 0; }))







#define __CPU_COUNT_S(setsize,cpusetp) __sched_cpucount (setsize, cpusetp)



#define __CPU_EQUAL_S(setsize,cpusetp1,cpusetp2) (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)
# 185 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
#define __CPU_OP_S(setsize,destset,srcset1,srcset2,op) (__extension__ ({ cpu_set_t *__dest = (destset); const __cpu_mask *__arr1 = (srcset1)->__bits; const __cpu_mask *__arr2 = (srcset2)->__bits; size_t __imax = (setsize) / sizeof (__cpu_mask); size_t __i; for (__i = 0; __i < __imax; ++__i) ((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i]; __dest; }))
# 196 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
#define __CPU_ALLOC_SIZE(count) ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))

#define __CPU_ALLOC(count) __sched_cpualloc (count)
#define __CPU_FREE(cpuset) __sched_cpufree (cpuset)



extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 44 "/usr/include/sched.h" 2 3 4

#define sched_priority __sched_priority





extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));




#define CPU_SETSIZE __CPU_SETSIZE
#define CPU_SET(cpu,cpusetp) __CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_CLR(cpu,cpusetp) __CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_ISSET(cpu,cpusetp) __CPU_ISSET_S (cpu, sizeof (cpu_set_t), cpusetp)

#define CPU_ZERO(cpusetp) __CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)
#define CPU_COUNT(cpusetp) __CPU_COUNT_S (sizeof (cpu_set_t), cpusetp)

#define CPU_SET_S(cpu,setsize,cpusetp) __CPU_SET_S (cpu, setsize, cpusetp)
#define CPU_CLR_S(cpu,setsize,cpusetp) __CPU_CLR_S (cpu, setsize, cpusetp)
#define CPU_ISSET_S(cpu,setsize,cpusetp) __CPU_ISSET_S (cpu, setsize, cpusetp)

#define CPU_ZERO_S(setsize,cpusetp) __CPU_ZERO_S (setsize, cpusetp)
#define CPU_COUNT_S(setsize,cpusetp) __CPU_COUNT_S (setsize, cpusetp)

#define CPU_EQUAL(cpusetp1,cpusetp2) __CPU_EQUAL_S (sizeof (cpu_set_t), cpusetp1, cpusetp2)

#define CPU_EQUAL_S(setsize,cpusetp1,cpusetp2) __CPU_EQUAL_S (setsize, cpusetp1, cpusetp2)


#define CPU_AND(destset,srcset1,srcset2) __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &)

#define CPU_OR(destset,srcset1,srcset2) __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)

#define CPU_XOR(destset,srcset1,srcset2) __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)

#define CPU_AND_S(setsize,destset,srcset1,srcset2) __CPU_OP_S (setsize, destset, srcset1, srcset2, &)

#define CPU_OR_S(setsize,destset,srcset1,srcset2) __CPU_OP_S (setsize, destset, srcset1, srcset2, |)

#define CPU_XOR_S(setsize,destset,srcset1,srcset2) __CPU_OP_S (setsize, destset, srcset1, srcset2, ^)


#define CPU_ALLOC_SIZE(count) __CPU_ALLOC_SIZE (count)
#define CPU_ALLOC(count) __CPU_ALLOC (count)
#define CPU_FREE(cpuset) __CPU_FREE (cpuset)



extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));



# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 26 "/usr/include/time.h" 3 4
#define _TIME_H 1








#define __need_size_t 
#define __need_NULL 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 161 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_size_t
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_wchar_t
# 401 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 40 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
#define _BITS_TIME_H 1







#define CLOCKS_PER_SEC ((clock_t) 1000000)
# 61 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
#define CLOCK_REALTIME 0

#define CLOCK_MONOTONIC 1

#define CLOCK_PROCESS_CPUTIME_ID 2

#define CLOCK_THREAD_CPUTIME_ID 3

#define CLOCK_MONOTONIC_RAW 4

#define CLOCK_REALTIME_COARSE 5

#define CLOCK_MONOTONIC_COARSE 6

#define CLOCK_BOOTTIME 7

#define CLOCK_REALTIME_ALARM 8

#define CLOCK_BOOTTIME_ALARM 9

#define CLOCK_TAI 11


#define TIMER_ABSTIME 1



# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
#define _BITS_TIMEX_H 1





struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};


#define ADJ_OFFSET 0x0001
#define ADJ_FREQUENCY 0x0002
#define ADJ_MAXERROR 0x0004
#define ADJ_ESTERROR 0x0008
#define ADJ_STATUS 0x0010
#define ADJ_TIMECONST 0x0020
#define ADJ_TAI 0x0080
#define ADJ_SETOFFSET 0x0100
#define ADJ_MICRO 0x1000
#define ADJ_NANO 0x2000
#define ADJ_TICK 0x4000
#define ADJ_OFFSET_SINGLESHOT 0x8001
#define ADJ_OFFSET_SS_READ 0xa001


#define MOD_OFFSET ADJ_OFFSET
#define MOD_FREQUENCY ADJ_FREQUENCY
#define MOD_MAXERROR ADJ_MAXERROR
#define MOD_ESTERROR ADJ_ESTERROR
#define MOD_STATUS ADJ_STATUS
#define MOD_TIMECONST ADJ_TIMECONST
#define MOD_CLKB ADJ_TICK
#define MOD_CLKA ADJ_OFFSET_SINGLESHOT
#define MOD_TAI ADJ_TAI
#define MOD_MICRO ADJ_MICRO
#define MOD_NANO ADJ_NANO



#define STA_PLL 0x0001
#define STA_PPSFREQ 0x0002
#define STA_PPSTIME 0x0004
#define STA_FLL 0x0008

#define STA_INS 0x0010
#define STA_DEL 0x0020
#define STA_UNSYNC 0x0040
#define STA_FREQHOLD 0x0080

#define STA_PPSSIGNAL 0x0100
#define STA_PPSJITTER 0x0200
#define STA_PPSWANDER 0x0400
#define STA_PPSERROR 0x0800

#define STA_CLOCKERR 0x1000
#define STA_NANO 0x2000
#define STA_MODE 0x4000
#define STA_CLK 0x8000


#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
# 89 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));







#undef __need_timeval
# 42 "/usr/include/time.h" 2 3 4
# 66 "/usr/include/time.h" 3 4
#undef __need_clock_t
# 82 "/usr/include/time.h" 3 4
#undef __need_time_t
# 94 "/usr/include/time.h" 3 4
#undef __clockid_time_t
# 106 "/usr/include/time.h" 3 4
#undef __need_timer_t
# 127 "/usr/include/time.h" 3 4
#undef __need_timespec





struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 182 "/usr/include/time.h" 3 4
#define TIME_UTC 1






extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));






extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));





#define __isleap(year) ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 25 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
#define _BITS_SETJMP_H 1





# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64





#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4



#define __WORDSIZE 64





#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,
#define PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_JOINABLE
  PTHREAD_CREATE_DETACHED
#define PTHREAD_CREATE_DETACHED PTHREAD_CREATE_DETACHED
};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};




#define PTHREAD_MUTEX_INITIALIZER { { 0, 0, 0, 0, 0, __PTHREAD_SPINS, { 0, 0 } } }


#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, __PTHREAD_SPINS, { 0, 0 } } }

#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP { { 0, 0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, __PTHREAD_SPINS, { 0, 0 } } }

#define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP { { 0, 0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __PTHREAD_SPINS, { 0, 0 } } }
# 114 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 132 "/usr/include/pthread.h" 3 4
#define PTHREAD_RWLOCK_INITIALIZER { { 0, 0, 0, 0, 0, 0, 0, 0, __PTHREAD_RWLOCK_ELISION_EXTRA, 0, 0 } }



#define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP { { 0, 0, 0, 0, 0, 0, 0, 0, __PTHREAD_RWLOCK_ELISION_EXTRA, 0, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP } }
# 155 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,
#define PTHREAD_INHERIT_SCHED PTHREAD_INHERIT_SCHED
  PTHREAD_EXPLICIT_SCHED
#define PTHREAD_EXPLICIT_SCHED PTHREAD_EXPLICIT_SCHED
};



enum
{
  PTHREAD_SCOPE_SYSTEM,
#define PTHREAD_SCOPE_SYSTEM PTHREAD_SCOPE_SYSTEM
  PTHREAD_SCOPE_PROCESS
#define PTHREAD_SCOPE_PROCESS PTHREAD_SCOPE_PROCESS
};



enum
{
  PTHREAD_PROCESS_PRIVATE,
#define PTHREAD_PROCESS_PRIVATE PTHREAD_PROCESS_PRIVATE
  PTHREAD_PROCESS_SHARED
#define PTHREAD_PROCESS_SHARED PTHREAD_PROCESS_SHARED
};




#define PTHREAD_COND_INITIALIZER { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }



struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,
#define PTHREAD_CANCEL_ENABLE PTHREAD_CANCEL_ENABLE
  PTHREAD_CANCEL_DISABLE
#define PTHREAD_CANCEL_DISABLE PTHREAD_CANCEL_DISABLE
};
enum
{
  PTHREAD_CANCEL_DEFERRED,
#define PTHREAD_CANCEL_DEFERRED PTHREAD_CANCEL_DEFERRED
  PTHREAD_CANCEL_ASYNCHRONOUS
#define PTHREAD_CANCEL_ASYNCHRONOUS PTHREAD_CANCEL_ASYNCHRONOUS
};
#define PTHREAD_CANCELED ((void *) -1)



#define PTHREAD_ONCE_INIT 0






#define PTHREAD_BARRIER_SERIAL_THREAD -1








extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__ , __leaf__));







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));



extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__ , __leaf__));







extern int pthread_yield (void) __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 494 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 506 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));



#define __cleanup_fct_attribute 




struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 664 "/usr/include/pthread.h" 3 4
#define pthread_cleanup_push(routine,arg) do { __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (arg); int __not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *) __cancel_buf.__cancel_jmp_buf, 0); if (__glibc_unlikely (__not_first_call)) { __cancel_routine (__cancel_arg); __pthread_unwind_next (&__cancel_buf); } __pthread_register_cancel (&__cancel_buf); do {
# 680 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;



#define pthread_cleanup_pop(execute) do { } while (0); } while (0); __pthread_unregister_cancel (&__cancel_buf); if (execute) __cancel_routine (__cancel_arg); } while (0)






extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;





#define pthread_cleanup_push_defer_np(routine,arg) do { __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (arg); int __not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *) __cancel_buf.__cancel_jmp_buf, 0); if (__glibc_unlikely (__not_first_call)) { __cancel_routine (__cancel_arg); __pthread_unwind_next (&__cancel_buf); } __pthread_register_cancel_defer (&__cancel_buf); do {
# 715 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     ;




#define pthread_cleanup_pop_restore_np(execute) do { } while (0); } while (0); __pthread_unregister_cancel_restore (&__cancel_buf); if (execute) __cancel_routine (__cancel_arg); } while (0)






extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 806 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 888 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1000 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1044 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1111 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 1145 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));
# 1159 "/usr/include/pthread.h" 3 4

# 28 "includes/rts/OSThreads.h" 2
# 1 "/usr/include/errno.h" 1 3 4
# 27 "/usr/include/errno.h" 3 4
#define _ERRNO_H 1







# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
#undef EDOM
#undef EILSEQ
#undef ERANGE
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4

#define _ASM_GENERIC_ERRNO_H 

# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4

#define _ASM_GENERIC_ERRNO_BASE_H 

#define EPERM 1
#define ENOENT 2
#define ESRCH 3
#define EINTR 4
#define EIO 5
#define ENXIO 6
#define E2BIG 7
#define ENOEXEC 8
#define EBADF 9
#define ECHILD 10
#define EAGAIN 11
#define ENOMEM 12
#define EACCES 13
#define EFAULT 14
#define ENOTBLK 15
#define EBUSY 16
#define EEXIST 17
#define EXDEV 18
#define ENODEV 19
#define ENOTDIR 20
#define EISDIR 21
#define EINVAL 22
#define ENFILE 23
#define EMFILE 24
#define ENOTTY 25
#define ETXTBSY 26
#define EFBIG 27
#define ENOSPC 28
#define ESPIPE 29
#define EROFS 30
#define EMLINK 31
#define EPIPE 32
#define EDOM 33
#define ERANGE 34
# 5 "/usr/include/asm-generic/errno.h" 2 3 4

#define EDEADLK 35
#define ENAMETOOLONG 36
#define ENOLCK 37
# 17 "/usr/include/asm-generic/errno.h" 3 4
#define ENOSYS 38

#define ENOTEMPTY 39
#define ELOOP 40
#define EWOULDBLOCK EAGAIN
#define ENOMSG 42
#define EIDRM 43
#define ECHRNG 44
#define EL2NSYNC 45
#define EL3HLT 46
#define EL3RST 47
#define ELNRNG 48
#define EUNATCH 49
#define ENOCSI 50
#define EL2HLT 51
#define EBADE 52
#define EBADR 53
#define EXFULL 54
#define ENOANO 55
#define EBADRQC 56
#define EBADSLT 57

#define EDEADLOCK EDEADLK

#define EBFONT 59
#define ENOSTR 60
#define ENODATA 61
#define ETIME 62
#define ENOSR 63
#define ENONET 64
#define ENOPKG 65
#define EREMOTE 66
#define ENOLINK 67
#define EADV 68
#define ESRMNT 69
#define ECOMM 70
#define EPROTO 71
#define EMULTIHOP 72
#define EDOTDOT 73
#define EBADMSG 74
#define EOVERFLOW 75
#define ENOTUNIQ 76
#define EBADFD 77
#define EREMCHG 78
#define ELIBACC 79
#define ELIBBAD 80
#define ELIBSCN 81
#define ELIBMAX 82
#define ELIBEXEC 83
#define EILSEQ 84
#define ERESTART 85
#define ESTRPIPE 86
#define EUSERS 87
#define ENOTSOCK 88
#define EDESTADDRREQ 89
#define EMSGSIZE 90
#define EPROTOTYPE 91
#define ENOPROTOOPT 92
#define EPROTONOSUPPORT 93
#define ESOCKTNOSUPPORT 94
#define EOPNOTSUPP 95
#define EPFNOSUPPORT 96
#define EAFNOSUPPORT 97
#define EADDRINUSE 98
#define EADDRNOTAVAIL 99
#define ENETDOWN 100
#define ENETUNREACH 101
#define ENETRESET 102
#define ECONNABORTED 103
#define ECONNRESET 104
#define ENOBUFS 105
#define EISCONN 106
#define ENOTCONN 107
#define ESHUTDOWN 108
#define ETOOMANYREFS 109
#define ETIMEDOUT 110
#define ECONNREFUSED 111
#define EHOSTDOWN 112
#define EHOSTUNREACH 113
#define EALREADY 114
#define EINPROGRESS 115
#define ESTALE 116
#define EUCLEAN 117
#define ENOTNAM 118
#define ENAVAIL 119
#define EISNAM 120
#define EREMOTEIO 121
#define EDQUOT 122

#define ENOMEDIUM 123
#define EMEDIUMTYPE 124
#define ECANCELED 125
#define ENOKEY 126
#define EKEYEXPIRED 127
#define EKEYREVOKED 128
#define EKEYREJECTED 129


#define EOWNERDEAD 130
#define ENOTRECOVERABLE 131

#define ERFKILL 132

#define EHWPOISON 133
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4


#define ENOTSUP EOPNOTSUPP
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



#define errno (*__errno_location ())
# 36 "/usr/include/errno.h" 2 3 4
#undef __need_Emath
# 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;




# 68 "/usr/include/errno.h" 3 4
typedef int error_t;
#define __error_t_defined 1

#undef __need_error_t
# 29 "includes/rts/OSThreads.h" 2


# 30 "includes/rts/OSThreads.h"
typedef struct {
    pthread_cond_t cond;
# 40 "includes/rts/OSThreads.h"
} Condition;
typedef pthread_mutex_t Mutex;
typedef pthread_t OSThreadId;
typedef pthread_key_t ThreadLocalKey;

#define OSThreadProcAttr 

#define INIT_COND_VAR PTHREAD_COND_INITIALIZER





#define LOCK_DEBUG_BELCH(what,mutex) 



#define OS_ACQUIRE_LOCK(mutex) { LOCK_DEBUG_BELCH("ACQUIRE_LOCK", mutex); int __r = pthread_mutex_lock(mutex); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", __FILE__, __LINE__, __r); } }







inline int OS_TRY_ACQUIRE_LOCK(pthread_mutex_t *mutex);
inline int OS_TRY_ACQUIRE_LOCK(pthread_mutex_t *mutex)
{
    ;
    return pthread_mutex_trylock(mutex);
}

#define OS_RELEASE_LOCK(mutex) LOCK_DEBUG_BELCH("RELEASE_LOCK", mutex); if (pthread_mutex_unlock(mutex) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", __FILE__,__LINE__); }
# 83 "includes/rts/OSThreads.h"
#define OS_ASSERT_LOCK_HELD(mutex) ASSERT(pthread_mutex_lock(mutex) == EDEADLK)
# 169 "includes/rts/OSThreads.h"
extern OSThreadId osThreadId ( void );
extern void shutdownThread ( void ) __attribute__((__noreturn__));
extern void yieldThread ( void );

typedef void* OSThreadProc(void *);

extern int createOSThread ( OSThreadId* tid, char *name,
                                    OSThreadProc *startProc, void *param);
extern 
# 177 "includes/rts/OSThreads.h" 3 4
      _Bool 
# 177 "includes/rts/OSThreads.h"
           osThreadIsAlive ( OSThreadId id );
extern void interruptOSThread ( OSThreadId id );
extern void joinOSThread ( OSThreadId id );




extern void initCondition ( Condition* pCond );
extern void closeCondition ( Condition* pCond );
extern void broadcastCondition ( Condition* pCond );
extern void signalCondition ( Condition* pCond );
extern void waitCondition ( Condition* pCond, Mutex* pMut );

extern 
# 190 "includes/rts/OSThreads.h" 3 4
      _Bool 
# 190 "includes/rts/OSThreads.h"
           timedWaitCondition ( Condition* pCond, Mutex* pMut, Time timeout);




extern void initMutex ( Mutex* pMut );
extern void closeMutex ( Mutex* pMut );




void newThreadLocalKey (ThreadLocalKey *key);
void *getThreadLocalVar (ThreadLocalKey *key);
void setThreadLocalVar (ThreadLocalKey *key, void *value);
void freeThreadLocalKey (ThreadLocalKey *key);


void setThreadAffinity (uint32_t n, uint32_t m);
void setThreadNode (uint32_t node);
void releaseThreadNode (void);




#define ACQUIRE_LOCK(l) OS_ACQUIRE_LOCK(l)
#define TRY_ACQUIRE_LOCK(l) OS_TRY_ACQUIRE_LOCK(l)
#define RELEASE_LOCK(l) OS_RELEASE_LOCK(l)
#define ASSERT_LOCK_HELD(l) OS_ASSERT_LOCK_HELD(l)
# 233 "includes/rts/OSThreads.h"
int forkOS_createThread ( HsStablePtr entry );




void freeThreadingResources(void);




uint32_t getNumberOfProcessors (void);
# 262 "includes/rts/OSThreads.h"
typedef StgWord64 KernelThreadId;


KernelThreadId kernelThreadId (void);
# 225 "includes/Rts.h" 2
# 1 "includes/rts/TSANUtils.h" 1
# 61 "includes/rts/TSANUtils.h"
#define TSAN_ANNOTATE_HAPPENS_BEFORE(addr) 
#define TSAN_ANNOTATE_HAPPENS_AFTER(addr) 
#define TSAN_ANNOTATE_BENIGN_RACE_SIZED(addr,size,desc) 


#define TSAN_ANNOTATE_BENIGN_RACE(addr,desc) TSAN_ANNOTATE_BENIGN_RACE_SIZED((void*)(addr), sizeof(*addr), desc)
# 226 "includes/Rts.h" 2
# 1 "includes/rts/SpinLock.h" 1
# 22 "includes/rts/SpinLock.h"
       



typedef struct SpinLock_
{
    StgWord lock;

    StgWord64 spin;
    StgWord64 yield;

} SpinLock;



#define IF_PROF_SPIN(x) x




void acquire_spin_lock_slow_path(SpinLock * p);


static inline void ACQUIRE_SPIN_LOCK(SpinLock * p)
{
    StgWord32 r = cas((StgVolatilePtr)&(p->lock), 1, 0);
    if (__builtin_expect((r == 0),0))
        acquire_spin_lock_slow_path(p);
}


static inline void RELEASE_SPIN_LOCK(SpinLock * p)
{
    __atomic_store_n(&p->lock, 1, 3);
}


static inline void initSpinLock(SpinLock * p)
{
    p->spin = 0;
    p->yield = 0;
    __atomic_store_n(&p->lock, 1, 3);
}
# 227 "includes/Rts.h" 2

# 1 "includes/rts/Messages.h" 1
# 17 "includes/rts/Messages.h"
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 31 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
#define _STDARG_H 
#define _ANSI_STDARG_H_ 

#undef __need___va_list
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
#define va_start(v,l) __builtin_va_start(v,l)
#define va_end(v) __builtin_va_end(v)
#define va_arg(v,l) __builtin_va_arg(v,l)


#define va_copy(d,s) __builtin_va_copy(d,s)

#define __va_copy(d,s) __builtin_va_copy(d,s)
# 105 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
#define _VA_LIST_ 


#define _VA_LIST 





#define _VA_LIST_T_H 


#define __va_list__ 
# 20 "includes/rts/Messages.h" 2







#define PRINTF printf
# 42 "includes/rts/Messages.h"
void barf(const char *s, ...)
   __attribute__((__noreturn__))
   __attribute__((format(printf, 1, 2)));

void vbarf(const char *s, va_list ap)
   __attribute__((__noreturn__));
# 59 "includes/rts/Messages.h"
void errorBelch(const char *s, ...)
   __attribute__((format (printf, 1, 2)));

void verrorBelch(const char *s, va_list ap);
# 73 "includes/rts/Messages.h"
void sysErrorBelch(const char *s, ...)
   __attribute__((format (printf, 1, 2)));

void vsysErrorBelch(const char *s, va_list ap);
# 85 "includes/rts/Messages.h"
void debugBelch(const char *s, ...)
   __attribute__((format (printf, 1, 2)));

int vdebugBelch(const char *s, va_list ap);




typedef void RtsMsgFunction(const char *, va_list);
typedef int RtsMsgFunctionRetLen(const char *, va_list);

extern RtsMsgFunction *fatalInternalErrorFn;
extern RtsMsgFunctionRetLen *debugMsgFn;
extern RtsMsgFunction *errorMsgFn;



extern RtsMsgFunction rtsFatalInternalErrorFn;
extern RtsMsgFunctionRetLen rtsDebugMsgFn;
extern RtsMsgFunction rtsErrorMsgFn;
extern RtsMsgFunction rtsSysErrorMsgFn;
# 229 "includes/Rts.h" 2
# 1 "includes/rts/Threads.h" 1
# 15 "includes/rts/Threads.h"
       
# 24 "includes/rts/Threads.h"
StgTSO *createThread (Capability *cap, W_ stack_size);





void scheduleWaitThread ( StgTSO *tso,
                                     HaskellObj* ret,
                                     Capability **cap);

StgTSO *createGenThread (Capability *cap, W_ stack_size,
                               StgClosure *closure);
StgTSO *createIOThread (Capability *cap, W_ stack_size,
                               StgClosure *closure);
StgTSO *createStrictIOThread (Capability *cap, W_ stack_size,
                               StgClosure *closure);


void * suspendThread (StgRegTable *, 
# 42 "includes/rts/Threads.h" 3 4
                                           _Bool 
# 42 "includes/rts/Threads.h"
                                                interruptible);
StgRegTable * resumeThread (void *);





# 48 "includes/rts/Threads.h" 3 4
_Bool 
# 48 "includes/rts/Threads.h"
       eq_thread (StgPtr tso1, StgPtr tso2);
int cmp_thread (StgPtr tso1, StgPtr tso2);
long rts_getThreadId (StgPtr tso);
void rts_enableThreadAllocationLimit (StgPtr tso);
void rts_disableThreadAllocationLimit (StgPtr tso);


pid_t forkProcess (HsStablePtr *entry);





HsBool rtsSupportsBoundThreads (void);




extern unsigned int n_capabilities;

static inline unsigned int getNumCapabilities(void)
{ return __atomic_load_n(&n_capabilities, 0); }


extern uint32_t enabled_capabilities;


extern Capability MainCapability;






extern void setNumCapabilities (uint32_t new_);
# 230 "includes/Rts.h" 2


# 1 "includes/rts/storage/FunTypes.h" 1
# 9 "includes/rts/storage/FunTypes.h"
       


#define ARG_GEN 0


#define ARG_GEN_BIG 1


#define ARG_BCO 2
# 29 "includes/rts/storage/FunTypes.h"
#define ARG_NONE 3
#define ARG_N 4
#define ARG_P 5
#define ARG_F 6
#define ARG_D 7
#define ARG_L 8
#define ARG_V16 9
#define ARG_V32 10
#define ARG_V64 11
#define ARG_NN 12
#define ARG_NP 13
#define ARG_PN 14
#define ARG_PP 15
#define ARG_NNN 16
#define ARG_NNP 17
#define ARG_NPN 18
#define ARG_NPP 19
#define ARG_PNN 20
#define ARG_PNP 21
#define ARG_PPN 22
#define ARG_PPP 23
#define ARG_PPPP 24
#define ARG_PPPPP 25
#define ARG_PPPPPP 26
#define ARG_PPPPPPP 27
#define ARG_PPPPPPPP 28
# 233 "includes/Rts.h" 2
# 1 "includes/rts/storage/InfoTables.h" 1
# 9 "includes/rts/storage/InfoTables.h"
       
# 31 "includes/rts/storage/InfoTables.h"
#define OFFSET_FIELD(n) StgHalfInt n; StgHalfWord __pad_ ##n
# 40 "includes/rts/storage/InfoTables.h"
typedef struct {




    StgHalfInt closure_type_off; StgHalfWord __pad_closure_type_off;
    StgHalfInt closure_desc_off; StgHalfWord __pad_closure_desc_off;

} StgProfInfo;







#define _HNF (1<<0)
#define _BTM (1<<1)
#define _NS (1<<2)
#define _THU (1<<3)
#define _MUT (1<<4)
#define _UPT (1<<5)
#define _SRT (1<<6)
#define _IND (1<<7)

#define isMUTABLE(flags) ((flags) &_MUT)
#define isBITMAP(flags) ((flags) &_BTM)
#define isTHUNK(flags) ((flags) &_THU)
#define isUNPOINTED(flags) ((flags) &_UPT)
#define hasSRT(flags) ((flags) &_SRT)

extern StgWord16 closure_flags[];

#define closureFlags(c) (closure_flags[get_itbl (UNTAG_CONST_CLOSURE(c))->type])


#define closure_HNF(c) ( closureFlags(c) & _HNF)
#define closure_BITMAP(c) ( closureFlags(c) & _BTM)
#define closure_NON_SPARK(c) ( (closureFlags(c) & _NS))
#define closure_SHOULD_SPARK(c) (!(closureFlags(c) & _NS))
#define closure_THUNK(c) ( closureFlags(c) & _THU)
#define closure_MUTABLE(c) ( closureFlags(c) & _MUT)
#define closure_UNPOINTED(c) ( closureFlags(c) & _UPT)
#define closure_SRT(c) ( closureFlags(c) & _SRT)
#define closure_IND(c) ( closureFlags(c) & _IND)


#define ipFlags(ip) (closure_flags[ip->type])

#define ip_HNF(ip) ( ipFlags(ip) & _HNF)
#define ip_BITMAP(ip) ( ipFlags(ip) & _BTM)
#define ip_SHOULD_SPARK(ip) (!(ipFlags(ip) & _NS))
#define ip_THUNK(ip) ( ipFlags(ip) & _THU)
#define ip_MUTABLE(ip) ( ipFlags(ip) & _MUT)
#define ip_UNPOINTED(ip) ( ipFlags(ip) & _UPT)
#define ip_SRT(ip) ( ipFlags(ip) & _SRT)
#define ip_IND(ip) ( ipFlags(ip) & _IND)
# 114 "includes/rts/storage/InfoTables.h"
#define MK_SMALL_BITMAP(size,bits) (((bits)<<BITMAP_BITS_SHIFT) | (size))

#define BITMAP_SIZE(bitmap) ((bitmap) & BITMAP_SIZE_MASK)
#define BITMAP_BITS(bitmap) ((bitmap) >> BITMAP_BITS_SHIFT)




typedef struct {
  StgWord size;
  StgWord bitmap[];
} StgLargeBitmap;
# 136 "includes/rts/storage/InfoTables.h"
typedef union {
    struct {
        StgHalfWord ptrs;
        StgHalfWord nptrs;
    } payload;

    StgWord bitmap;





    StgHalfInt large_bitmap_offset; StgHalfWord __pad_large_bitmap_offset;


    StgWord selector_offset;

} StgClosureInfo;
# 162 "includes/rts/storage/InfoTables.h"
#define USE_INLINE_SRT_FIELD 




typedef StgHalfInt StgSRTField;
# 177 "includes/rts/storage/InfoTables.h"
typedef struct StgInfoTable_ {






    StgProfInfo prof;


    StgClosureInfo layout;

    StgHalfWord type;
    StgSRTField srt;
# 201 "includes/rts/storage/InfoTables.h"
    StgCode code[];

} *StgInfoTablePtr;
# 232 "includes/rts/storage/InfoTables.h"
typedef struct StgFunInfoExtraRev_ {
    StgHalfInt slow_apply_offset; StgHalfWord __pad_slow_apply_offset;
    union {
        StgWord bitmap;
        StgHalfInt bitmap_offset; StgHalfWord __pad_bitmap_offset;
    } b;



    StgHalfWord fun_type;
    StgHalfWord arity;
} StgFunInfoExtraRev;

typedef struct StgFunInfoExtraFwd_ {
    StgHalfWord fun_type;
    StgHalfWord arity;
    StgClosure *srt;
    union {
        StgWord bitmap;
    } b;
    StgFun *slow_apply;
} StgFunInfoExtraFwd;

typedef struct {

    StgFunInfoExtraRev f;
    StgInfoTable i;




} StgFunInfoTable;


extern const StgWord stg_arg_bitmaps[];
# 277 "includes/rts/storage/InfoTables.h"
typedef struct {




    StgInfoTable i;




} StgRetInfoTable;
# 298 "includes/rts/storage/InfoTables.h"
typedef struct StgThunkInfoTable_ {




    StgInfoTable i;




} StgThunkInfoTable;





typedef struct StgConInfoTable_ {





    StgHalfInt con_desc; StgHalfWord __pad_con_desc;






    StgInfoTable i;

} StgConInfoTable;
# 342 "includes/rts/storage/InfoTables.h"
#define GET_SRT(info) ((StgClosure*) (((StgWord) ((info)+1)) + (info)->i.srt))
# 357 "includes/rts/storage/InfoTables.h"
#define GET_CON_DESC(info) ((const char *)((StgWord)((info)+1) + ((info)->con_desc)))
# 369 "includes/rts/storage/InfoTables.h"
#define GET_FUN_SRT(info) ((StgClosure*) (((StgWord) ((info)+1)) + (info)->i.srt))
# 380 "includes/rts/storage/InfoTables.h"
#define GET_LARGE_BITMAP(info) ((StgLargeBitmap*) (((StgWord) ((info)+1)) + (info)->layout.large_bitmap_offset))






#define GET_FUN_LARGE_BITMAP(info) ((StgLargeBitmap*) (((StgWord) ((info)+1)) + (info)->f.b.bitmap_offset))
# 397 "includes/rts/storage/InfoTables.h"
#define GET_PROF_TYPE(info) ((char *)((StgWord)((info)+1) + (info->prof.closure_type_off)))




#define GET_PROF_DESC(info) ((char *)((StgWord)((info)+1) + (info->prof.closure_desc_off)))
# 234 "includes/Rts.h" 2
# 1 "includes/rts/storage/Closures.h" 1
# 9 "includes/rts/storage/Closures.h"
       
# 20 "includes/rts/storage/Closures.h"
typedef struct {
  CostCentreStack *ccs;
  union {
    StgWord trav;
    StgWord ldvw;
  } hp;




} StgProfHeader;
# 45 "includes/rts/storage/Closures.h"
typedef struct {
    StgWord pad;
} StgSMPThunkHeader;
# 56 "includes/rts/storage/Closures.h"
typedef struct {





    const StgInfoTable* info;

    StgProfHeader prof;

} StgHeader;

typedef struct {
    const StgInfoTable* info;

    StgProfHeader prof;

    StgSMPThunkHeader smp;
} StgThunkHeader;

#define THUNK_EXTRA_HEADER_W (sizeofW(StgThunkHeader)-sizeofW(StgHeader))
# 88 "includes/rts/storage/Closures.h"
typedef struct StgClosure_ {
    StgHeader header;
    struct StgClosure_ *payload[];
} *StgClosurePtr;

typedef struct StgThunk_ {
    StgThunkHeader header;
    struct StgClosure_ *payload[];
} StgThunk;

typedef struct {
    StgThunkHeader header;
    StgClosure *selectee;
} StgSelector;







typedef struct {
    StgHeader header;
    StgHalfWord arity;
    StgHalfWord n_args;
    StgClosure *fun;
    StgClosure *payload[];
} StgPAP;

typedef struct {
    StgThunkHeader header;
    StgHalfWord arity;
    StgHalfWord n_args;
    StgClosure *fun;
    StgClosure *payload[];
} StgAP;

typedef struct {
    StgThunkHeader header;
    StgWord size;
    StgClosure *fun;
    StgClosure *payload[];
} StgAP_STACK;

typedef struct {
    StgHeader header;
    StgClosure *indirectee;
} StgInd;

typedef struct {
    StgHeader header;
    StgClosure *indirectee;
    StgClosure *static_link;
    const StgInfoTable *saved_info;


} StgIndStatic;

typedef struct StgBlockingQueue_ {
    StgHeader header;
    struct StgBlockingQueue_ *link;


    StgClosure *bh;
    StgTSO *owner;
    struct MessageBlackHole_ *queue;

} StgBlockingQueue;

typedef struct {
    StgHeader header;
    StgWord bytes;
    StgWord payload[];
} StgArrBytes;

typedef struct {
    StgHeader header;
    StgWord ptrs;
    StgWord size;
    StgClosure *payload[];

} StgMutArrPtrs;

typedef struct {
    StgHeader header;
    StgWord ptrs;
    StgClosure *payload[];
} StgSmallMutArrPtrs;

typedef struct {
    StgHeader header;
    StgClosure *var;
} StgMutVar;

typedef struct _StgUpdateFrame {
    StgHeader header;
    StgClosure *updatee;
} StgUpdateFrame;

typedef struct {
    StgHeader header;
    StgClosure *c;
} StgKeepAliveFrame;

typedef struct {
    StgHeader header;
    StgWord exceptions_blocked;
    StgClosure *handler;
} StgCatchFrame;

typedef struct {
    const StgInfoTable* info;
    struct StgStack_ *next_chunk;
} StgUnderflowFrame;

typedef struct {
    StgHeader header;
} StgStopFrame;

typedef struct {
  StgHeader header;
  StgWord data;
} StgIntCharlikeClosure;


typedef struct {
  StgHeader header;
} StgRetry;

typedef struct _StgStableName {
  StgHeader header;
  StgWord sn;
} StgStableName;

typedef struct _StgWeak {
  StgHeader header;
  StgClosure *cfinalizers;
  StgClosure *key;
  StgClosure *value;
  StgClosure *finalizer;
  struct _StgWeak *link;
} StgWeak;

typedef struct _StgCFinalizerList {
  StgHeader header;
  StgClosure *link;
  void (*fptr)(void);
  void *ptr;
  void *eptr;
  StgWord flag;
} StgCFinalizerList;
# 261 "includes/rts/storage/Closures.h"
typedef struct {
    StgHeader header;
    StgArrBytes *instrs;
    StgArrBytes *literals;
    StgMutArrPtrs *ptrs;
    StgHalfWord arity;
    StgHalfWord size;
    StgWord bitmap[];
} StgBCO;

#define BCO_BITMAP(bco) ((StgLargeBitmap *)((StgBCO *)(bco))->bitmap)
#define BCO_BITMAP_SIZE(bco) (BCO_BITMAP(bco)->size)
#define BCO_BITMAP_BITS(bco) (BCO_BITMAP(bco)->bitmap)
#define BCO_BITMAP_SIZEW(bco) ((BCO_BITMAP_SIZE(bco) + BITS_IN(StgWord) - 1) / BITS_IN(StgWord))
# 287 "includes/rts/storage/Closures.h"
typedef struct {
    const StgInfoTable* info;
    StgWord size;
    StgClosure * fun;
    StgClosure * payload[];
} StgRetFun;



typedef struct StgMVarTSOQueue_ {
    StgHeader header;
    struct StgMVarTSOQueue_ *link;
    struct StgTSO_ *tso;
} StgMVarTSOQueue;

typedef struct {
    StgHeader header;
    struct StgMVarTSOQueue_ *head;
    struct StgMVarTSOQueue_ *tail;
    StgClosure* value;
} StgMVar;
# 333 "includes/rts/storage/Closures.h"
typedef struct StgTRecHeader_ StgTRecHeader;

typedef struct StgTVarWatchQueue_ {
  StgHeader header;
  StgClosure *closure;
  struct StgTVarWatchQueue_ *next_queue_entry;
  struct StgTVarWatchQueue_ *prev_queue_entry;
} StgTVarWatchQueue;

typedef struct {
  StgHeader header;
  StgClosure *current_value;
  StgTVarWatchQueue *first_watch_queue_entry;
  StgInt num_updates;
} StgTVar;



typedef struct {
  StgTVar *tvar;
  StgClosure *expected_value;
  StgClosure *new_value;

  StgInt num_updates;

} TRecEntry;

#define TREC_CHUNK_NUM_ENTRIES 16

typedef struct StgTRecChunk_ {
  StgHeader header;
  struct StgTRecChunk_ *prev_chunk;
  StgWord next_entry_idx;
  TRecEntry entries[16];
} StgTRecChunk;

typedef enum {
  TREC_ACTIVE,
  TREC_CONDEMNED,
  TREC_COMMITTED,
  TREC_ABORTED,
  TREC_WAITING,
} TRecState;

struct StgTRecHeader_ {
  StgHeader header;
  struct StgTRecHeader_ *enclosing_trec;
  StgTRecChunk *current_chunk;
  TRecState state;
};

typedef struct {
  StgHeader header;
  StgClosure *code;
  StgClosure *result;
} StgAtomicallyFrame;

typedef struct {
  StgHeader header;
  StgClosure *code;
  StgClosure *handler;
} StgCatchSTMFrame;

typedef struct {
  StgHeader header;
  StgWord running_alt_code;
  StgClosure *first_code;
  StgClosure *alt_code;
} StgCatchRetryFrame;





typedef struct Message_ {
    StgHeader header;
    struct Message_ *link;
} Message;

typedef struct MessageWakeup_ {
    StgHeader header;
    Message *link;
    StgTSO *tso;
} MessageWakeup;

typedef struct MessageThrowTo_ {
    StgHeader header;
    struct MessageThrowTo_ *link;
    StgTSO *source;
    StgTSO *target;
    StgClosure *exception;
} MessageThrowTo;

typedef struct MessageBlackHole_ {
    StgHeader header;
    struct MessageBlackHole_ *link;


    StgTSO *tso;
    StgClosure *bh;
} MessageBlackHole;
# 448 "includes/rts/storage/Closures.h"
typedef struct StgCompactNFDataBlock_ {
    struct StgCompactNFDataBlock_ *self;







    struct StgCompactNFData_ *owner;

    struct StgCompactNFDataBlock_ *next;

} StgCompactNFDataBlock;




typedef struct StgCompactNFData_ {
    StgHeader header;



    StgWord totalW;

    StgWord autoBlockW;

    StgPtr hp, hpLim;



    StgCompactNFDataBlock *nursery;

    StgCompactNFDataBlock *last;


    struct hashtable *hash;


    StgClosure *result;


    struct StgCompactNFData_ *link;


} StgCompactNFData;
# 235 "includes/Rts.h" 2
# 1 "includes/rts/storage/Heap.h" 1
# 9 "includes/rts/storage/Heap.h"
       



StgMutArrPtrs *heap_view_closurePtrs(Capability *cap, StgClosure *closure);

void heap_view_closure_ptrs_in_pap_payload(StgClosure *ptrs[], StgWord *nptrs
                        , StgClosure *fun, StgClosure **payload, StgWord size);

StgWord heap_view_closureSize(StgClosure *closure);
# 31 "includes/rts/storage/Heap.h"
StgWord collect_pointers(StgClosure *closure, StgClosure *ptrs[]);
# 236 "includes/Rts.h" 2
# 1 "includes/rts/storage/ClosureTypes.h" 1
# 10 "includes/rts/storage/ClosureTypes.h"
       
# 22 "includes/rts/storage/ClosureTypes.h"
#define INVALID_OBJECT 0
#define CONSTR 1
#define CONSTR_1_0 2
#define CONSTR_0_1 3
#define CONSTR_2_0 4
#define CONSTR_1_1 5
#define CONSTR_0_2 6
#define CONSTR_NOCAF 7
#define FUN 8
#define FUN_1_0 9
#define FUN_0_1 10
#define FUN_2_0 11
#define FUN_1_1 12
#define FUN_0_2 13
#define FUN_STATIC 14
#define THUNK 15
#define THUNK_1_0 16
#define THUNK_0_1 17
#define THUNK_2_0 18
#define THUNK_1_1 19
#define THUNK_0_2 20
#define THUNK_STATIC 21
#define THUNK_SELECTOR 22
#define BCO 23
#define AP 24
#define PAP 25
#define AP_STACK 26
#define IND 27
#define IND_STATIC 28
#define RET_BCO 29
#define RET_SMALL 30
#define RET_BIG 31
#define RET_FUN 32
#define UPDATE_FRAME 33
#define CATCH_FRAME 34
#define UNDERFLOW_FRAME 35
#define STOP_FRAME 36
#define BLOCKING_QUEUE 37
#define BLACKHOLE 38
#define MVAR_CLEAN 39
#define MVAR_DIRTY 40
#define TVAR 41
#define ARR_WORDS 42
#define MUT_ARR_PTRS_CLEAN 43
#define MUT_ARR_PTRS_DIRTY 44
#define MUT_ARR_PTRS_FROZEN_DIRTY 45
#define MUT_ARR_PTRS_FROZEN_CLEAN 46
#define MUT_VAR_CLEAN 47
#define MUT_VAR_DIRTY 48
#define WEAK 49
#define PRIM 50
#define MUT_PRIM 51
#define TSO 52
#define STACK 53
#define TREC_CHUNK 54
#define ATOMICALLY_FRAME 55
#define CATCH_RETRY_FRAME 56
#define CATCH_STM_FRAME 57
#define WHITEHOLE 58
#define SMALL_MUT_ARR_PTRS_CLEAN 59
#define SMALL_MUT_ARR_PTRS_DIRTY 60
#define SMALL_MUT_ARR_PTRS_FROZEN_DIRTY 61
#define SMALL_MUT_ARR_PTRS_FROZEN_CLEAN 62
#define COMPACT_NFDATA 63
#define N_CLOSURE_TYPES 64
# 237 "includes/Rts.h" 2
# 1 "includes/rts/storage/TSO.h" 1
# 9 "includes/rts/storage/TSO.h"
       




typedef struct {
  CostCentreStack *cccs;
} StgTSOProfInfo;
# 25 "includes/rts/storage/TSO.h"
typedef StgWord64 StgThreadID;

#define tsoLocked(tso) ((tso)->flags & TSO_LOCKED)






typedef unsigned int StgThreadReturnCode;
# 46 "includes/rts/storage/TSO.h"
typedef union {
  StgClosure *closure;
  StgTSO *prev;
  struct MessageBlackHole_ *bh;
  struct MessageThrowTo_ *throwto;
  struct MessageWakeup_ *wakeup;
  StgInt fd;
# 63 "includes/rts/storage/TSO.h"
} StgTSOBlockInfo;
# 80 "includes/rts/storage/TSO.h"
typedef struct StgTSO_ {
    StgHeader header;




    struct StgTSO_* _link;
# 102 "includes/rts/storage/TSO.h"
    struct StgTSO_* global_link;





    struct StgStack_ *stackobj;
# 124 "includes/rts/storage/TSO.h"
    StgWord16 what_next;
    StgWord16 why_blocked;
    StgWord32 flags;
    StgTSOBlockInfo block_info;
    StgThreadID id;
    StgWord32 saved_errno;
    StgWord32 dirty;
    struct InCall_* bound;
    struct Capability_* cap;

    struct StgTRecHeader_ * trec;




    struct MessageThrowTo_ * blocked_exceptions;





    struct StgBlockingQueue_ *bq;
# 161 "includes/rts/storage/TSO.h"
    StgInt64 alloc_limit;
# 174 "includes/rts/storage/TSO.h"
    StgWord32 tot_stack_size;





    StgTSOProfInfo prof;





} *StgTSOPtr;
# 239 "includes/rts/storage/TSO.h"
#define STACK_DIRTY 1

#define STACK_SANE 64

typedef struct StgStack_ {
    StgHeader header;





    StgWord32 stack_size;

    StgWord8 dirty;
    StgWord8 marking;






    StgPtr sp;
    StgWord stack[];
} StgStack;



static inline StgPtr tso_SpLim (StgTSO* tso)
{
    return tso->stackobj->stack + 21;
}





void dirty_TSO (Capability *cap, StgTSO *tso);
void setTSOLink (Capability *cap, StgTSO *tso, StgTSO *target);
void setTSOPrev (Capability *cap, StgTSO *tso, StgTSO *target);

void dirty_STACK (Capability *cap, StgStack *stack);
# 329 "includes/rts/storage/TSO.h"
#define END_TSO_QUEUE ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)
# 238 "includes/Rts.h" 2
# 1 "includes/stg/MiscClosures.h" 1
# 20 "includes/stg/MiscClosures.h"
       
# 30 "includes/stg/MiscClosures.h"
#define RTS_RET_INFO(i) extern DLL_IMPORT_RTS const StgRetInfoTable i
#define RTS_FUN_INFO(i) extern DLL_IMPORT_RTS const StgFunInfoTable i
#define RTS_THUNK_INFO(i) extern DLL_IMPORT_RTS const StgThunkInfoTable i
#define RTS_INFO(i) extern DLL_IMPORT_RTS const StgInfoTable i
#define RTS_CLOSURE(i) extern DLL_IMPORT_RTS StgClosure i
#define RTS_FUN_DECL(f) extern DLL_IMPORT_RTS StgFunPtr f(void)



#define RTS_RET(f) RTS_INFO(f ##_info)
#define RTS_ENTRY(f) RTS_INFO(f ##_info)
#define RTS_FUN(f) RTS_FUN_INFO(f ##_info)
#define RTS_THUNK(f) RTS_THUNK_INFO(f ##_info)
# 51 "includes/stg/MiscClosures.h"
extern const StgInfoTable stg_upd_frame_info;
extern const StgInfoTable stg_bh_upd_frame_info;
extern const StgInfoTable stg_marked_upd_frame_info;
extern const StgInfoTable stg_noupd_frame_info;
extern const StgInfoTable stg_catch_frame_info;
extern const StgInfoTable stg_catch_retry_frame_info;
extern const StgInfoTable stg_atomically_frame_info;
extern const StgInfoTable stg_atomically_waiting_frame_info;
extern const StgInfoTable stg_catch_stm_frame_info;
extern const StgInfoTable stg_unmaskAsyncExceptionszh_ret_info;
extern const StgInfoTable stg_maskUninterruptiblezh_ret_info;
extern const StgInfoTable stg_maskAsyncExceptionszh_ret_info;
extern const StgInfoTable stg_stack_underflow_frame_info;
extern const StgInfoTable stg_keepAlive_frame_info;
extern const StgInfoTable stg_restore_cccs_info;
extern const StgInfoTable stg_restore_cccs_eval_info;
# 83 "includes/stg/MiscClosures.h"
extern const StgInfoTable stg_ctoi_R1p_info;
extern const StgInfoTable stg_ctoi_R1unpt_info;
extern const StgInfoTable stg_ctoi_R1n_info;
extern const StgInfoTable stg_ctoi_F1_info;
extern const StgInfoTable stg_ctoi_D1_info;
extern const StgInfoTable stg_ctoi_L1_info;
extern const StgInfoTable stg_ctoi_V_info;

extern StgFunPtr stg_ctoi_t(void);
extern const StgInfoTable stg_ctoi_t0_info;
extern const StgInfoTable stg_ctoi_t1_info;
extern const StgInfoTable stg_ctoi_t2_info;
extern const StgInfoTable stg_ctoi_t3_info;
extern const StgInfoTable stg_ctoi_t4_info;
extern const StgInfoTable stg_ctoi_t5_info;
extern const StgInfoTable stg_ctoi_t6_info;
extern const StgInfoTable stg_ctoi_t7_info;
extern const StgInfoTable stg_ctoi_t8_info;
extern const StgInfoTable stg_ctoi_t9_info;

extern const StgInfoTable stg_ctoi_t10_info;
extern const StgInfoTable stg_ctoi_t11_info;
extern const StgInfoTable stg_ctoi_t12_info;
extern const StgInfoTable stg_ctoi_t13_info;
extern const StgInfoTable stg_ctoi_t14_info;
extern const StgInfoTable stg_ctoi_t15_info;
extern const StgInfoTable stg_ctoi_t16_info;
extern const StgInfoTable stg_ctoi_t17_info;
extern const StgInfoTable stg_ctoi_t18_info;
extern const StgInfoTable stg_ctoi_t19_info;

extern const StgInfoTable stg_ctoi_t20_info;
extern const StgInfoTable stg_ctoi_t21_info;
extern const StgInfoTable stg_ctoi_t22_info;
extern const StgInfoTable stg_ctoi_t23_info;
extern const StgInfoTable stg_ctoi_t24_info;
extern const StgInfoTable stg_ctoi_t25_info;
extern const StgInfoTable stg_ctoi_t26_info;
extern const StgInfoTable stg_ctoi_t27_info;
extern const StgInfoTable stg_ctoi_t28_info;
extern const StgInfoTable stg_ctoi_t29_info;

extern const StgInfoTable stg_ctoi_t30_info;
extern const StgInfoTable stg_ctoi_t31_info;
extern const StgInfoTable stg_ctoi_t32_info;
extern const StgInfoTable stg_ctoi_t33_info;
extern const StgInfoTable stg_ctoi_t34_info;
extern const StgInfoTable stg_ctoi_t35_info;
extern const StgInfoTable stg_ctoi_t36_info;
extern const StgInfoTable stg_ctoi_t37_info;
extern const StgInfoTable stg_ctoi_t38_info;
extern const StgInfoTable stg_ctoi_t39_info;

extern const StgInfoTable stg_ctoi_t40_info;
extern const StgInfoTable stg_ctoi_t41_info;
extern const StgInfoTable stg_ctoi_t42_info;
extern const StgInfoTable stg_ctoi_t43_info;
extern const StgInfoTable stg_ctoi_t44_info;
extern const StgInfoTable stg_ctoi_t45_info;
extern const StgInfoTable stg_ctoi_t46_info;
extern const StgInfoTable stg_ctoi_t47_info;
extern const StgInfoTable stg_ctoi_t48_info;
extern const StgInfoTable stg_ctoi_t49_info;

extern const StgInfoTable stg_ctoi_t50_info;
extern const StgInfoTable stg_ctoi_t51_info;
extern const StgInfoTable stg_ctoi_t52_info;
extern const StgInfoTable stg_ctoi_t53_info;
extern const StgInfoTable stg_ctoi_t54_info;
extern const StgInfoTable stg_ctoi_t55_info;
extern const StgInfoTable stg_ctoi_t56_info;
extern const StgInfoTable stg_ctoi_t57_info;
extern const StgInfoTable stg_ctoi_t58_info;
extern const StgInfoTable stg_ctoi_t59_info;

extern const StgInfoTable stg_ctoi_t60_info;
extern const StgInfoTable stg_ctoi_t61_info;
extern const StgInfoTable stg_ctoi_t62_info;

extern const StgInfoTable stg_apply_interp_info;

extern const StgInfoTable stg_IND_info;
extern const StgInfoTable stg_IND_STATIC_info;
extern const StgInfoTable stg_BLACKHOLE_info;
extern const StgInfoTable stg_CAF_BLACKHOLE_info;
extern const StgInfoTable __stg_EAGER_BLACKHOLE_info;
extern const StgInfoTable stg_WHITEHOLE_info;
extern const StgInfoTable stg_BLOCKING_QUEUE_CLEAN_info;
extern const StgInfoTable stg_BLOCKING_QUEUE_DIRTY_info;

extern const StgFunInfoTable stg_BCO_info;
extern const StgInfoTable stg_EVACUATED_info;
extern const StgInfoTable stg_WEAK_info;
extern const StgInfoTable stg_DEAD_WEAK_info;
extern const StgInfoTable stg_C_FINALIZER_LIST_info;
extern const StgInfoTable stg_STABLE_NAME_info;
extern const StgInfoTable stg_MVAR_CLEAN_info;
extern const StgInfoTable stg_MVAR_DIRTY_info;
extern const StgInfoTable stg_TVAR_CLEAN_info;
extern const StgInfoTable stg_TVAR_DIRTY_info;
extern const StgInfoTable stg_TSO_info;
extern const StgInfoTable stg_STACK_info;
extern const StgInfoTable stg_RUBBISH_ENTRY_info;
extern const StgInfoTable stg_ARR_WORDS_info;
extern const StgInfoTable stg_MUT_ARR_WORDS_info;
extern const StgInfoTable stg_MUT_ARR_PTRS_CLEAN_info;
extern const StgInfoTable stg_MUT_ARR_PTRS_DIRTY_info;
extern const StgInfoTable stg_MUT_ARR_PTRS_FROZEN_CLEAN_info;
extern const StgInfoTable stg_MUT_ARR_PTRS_FROZEN_DIRTY_info;
extern const StgInfoTable stg_SMALL_MUT_ARR_PTRS_CLEAN_info;
extern const StgInfoTable stg_SMALL_MUT_ARR_PTRS_DIRTY_info;
extern const StgInfoTable stg_SMALL_MUT_ARR_PTRS_FROZEN_CLEAN_info;
extern const StgInfoTable stg_SMALL_MUT_ARR_PTRS_FROZEN_DIRTY_info;
extern const StgInfoTable stg_MUT_VAR_CLEAN_info;
extern const StgInfoTable stg_MUT_VAR_DIRTY_info;
extern const StgInfoTable stg_END_TSO_QUEUE_info;
extern const StgInfoTable stg_GCD_CAF_info;
extern const StgInfoTable stg_STM_AWOKEN_info;
extern const StgInfoTable stg_MSG_TRY_WAKEUP_info;
extern const StgInfoTable stg_MSG_THROWTO_info;
extern const StgInfoTable stg_MSG_BLACKHOLE_info;
extern const StgInfoTable stg_MSG_NULL_info;
extern const StgInfoTable stg_MVAR_TSO_QUEUE_info;
extern const StgInfoTable stg_catch_info;
extern const StgInfoTable stg_PAP_info;
extern const StgInfoTable stg_AP_info;
extern const StgInfoTable stg_AP_NOUPD_info;
extern const StgInfoTable stg_AP_STACK_info;
extern const StgInfoTable stg_AP_STACK_NOUPD_info;
extern const StgInfoTable stg_dummy_ret_info;
extern const StgInfoTable stg_raise_info;
extern const StgInfoTable stg_raise_ret_info;
extern const StgInfoTable stg_atomically_info;
extern const StgInfoTable stg_TVAR_WATCH_QUEUE_info;
extern const StgInfoTable stg_TREC_CHUNK_info;
extern const StgInfoTable stg_TREC_HEADER_info;
extern const StgInfoTable stg_END_STM_WATCH_QUEUE_info;
extern const StgInfoTable stg_END_STM_CHUNK_LIST_info;
extern const StgInfoTable stg_NO_TREC_info;
extern const StgInfoTable stg_COMPACT_NFDATA_CLEAN_info;
extern const StgInfoTable stg_COMPACT_NFDATA_DIRTY_info;
extern const StgInfoTable stg_SRT_1_info;
extern const StgInfoTable stg_SRT_2_info;
extern const StgInfoTable stg_SRT_3_info;
extern const StgInfoTable stg_SRT_4_info;
extern const StgInfoTable stg_SRT_5_info;
extern const StgInfoTable stg_SRT_6_info;
extern const StgInfoTable stg_SRT_7_info;
extern const StgInfoTable stg_SRT_8_info;
extern const StgInfoTable stg_SRT_9_info;
extern const StgInfoTable stg_SRT_10_info;
extern const StgInfoTable stg_SRT_11_info;
extern const StgInfoTable stg_SRT_12_info;
extern const StgInfoTable stg_SRT_13_info;
extern const StgInfoTable stg_SRT_14_info;
extern const StgInfoTable stg_SRT_15_info;
extern const StgInfoTable stg_SRT_16_info;



extern StgClosure stg_END_TSO_QUEUE_closure;
extern StgClosure stg_STM_AWOKEN_closure;
extern StgClosure stg_NO_FINALIZER_closure;
extern StgClosure stg_dummy_ret_closure;
extern StgClosure stg_forceIO_closure;

extern StgClosure stg_END_STM_WATCH_QUEUE_closure;
extern StgClosure stg_END_STM_CHUNK_LIST_closure;
extern StgClosure stg_NO_TREC_closure;

extern const StgInfoTable stg_NO_FINALIZER_info;





extern StgIntCharlikeClosure stg_CHARLIKE_closure[];
extern StgIntCharlikeClosure stg_INTLIKE_closure[];




extern const StgInfoTable stg_forceIO_info;
extern const StgInfoTable stg_noforceIO_info;





extern const StgInfoTable stg_sel_0_upd_info;
extern const StgInfoTable stg_sel_1_upd_info;
extern const StgInfoTable stg_sel_2_upd_info;
extern const StgInfoTable stg_sel_3_upd_info;
extern const StgInfoTable stg_sel_4_upd_info;
extern const StgInfoTable stg_sel_5_upd_info;
extern const StgInfoTable stg_sel_6_upd_info;
extern const StgInfoTable stg_sel_7_upd_info;
extern const StgInfoTable stg_sel_8_upd_info;
extern const StgInfoTable stg_sel_9_upd_info;
extern const StgInfoTable stg_sel_10_upd_info;
extern const StgInfoTable stg_sel_11_upd_info;
extern const StgInfoTable stg_sel_12_upd_info;
extern const StgInfoTable stg_sel_13_upd_info;
extern const StgInfoTable stg_sel_14_upd_info;
extern const StgInfoTable stg_sel_15_upd_info;

extern const StgInfoTable stg_sel_0_noupd_info;
extern const StgInfoTable stg_sel_1_noupd_info;
extern const StgInfoTable stg_sel_2_noupd_info;
extern const StgInfoTable stg_sel_3_noupd_info;
extern const StgInfoTable stg_sel_4_noupd_info;
extern const StgInfoTable stg_sel_5_noupd_info;
extern const StgInfoTable stg_sel_6_noupd_info;
extern const StgInfoTable stg_sel_7_noupd_info;
extern const StgInfoTable stg_sel_8_noupd_info;
extern const StgInfoTable stg_sel_9_noupd_info;
extern const StgInfoTable stg_sel_10_noupd_info;
extern const StgInfoTable stg_sel_11_noupd_info;
extern const StgInfoTable stg_sel_12_noupd_info;
extern const StgInfoTable stg_sel_13_noupd_info;
extern const StgInfoTable stg_sel_14_noupd_info;
extern const StgInfoTable stg_sel_15_noupd_info;



extern const StgThunkInfoTable stg_ap_1_upd_info;
extern const StgThunkInfoTable stg_ap_2_upd_info;
extern const StgThunkInfoTable stg_ap_3_upd_info;
extern const StgThunkInfoTable stg_ap_4_upd_info;
extern const StgThunkInfoTable stg_ap_5_upd_info;
extern const StgThunkInfoTable stg_ap_6_upd_info;
extern const StgThunkInfoTable stg_ap_7_upd_info;




extern const StgInfoTable stg_ap_v_info;
extern const StgInfoTable stg_ap_f_info;
extern const StgInfoTable stg_ap_d_info;
extern const StgInfoTable stg_ap_l_info;
extern const StgInfoTable stg_ap_v16_info;
extern const StgInfoTable stg_ap_v32_info;
extern const StgInfoTable stg_ap_v64_info;
extern const StgInfoTable stg_ap_n_info;
extern const StgInfoTable stg_ap_p_info;
extern const StgInfoTable stg_ap_pv_info;
extern const StgInfoTable stg_ap_pp_info;
extern const StgInfoTable stg_ap_ppv_info;
extern const StgInfoTable stg_ap_ppp_info;
extern const StgInfoTable stg_ap_pppv_info;
extern const StgInfoTable stg_ap_pppp_info;
extern const StgInfoTable stg_ap_ppppp_info;
extern const StgInfoTable stg_ap_pppppp_info;

extern StgFunPtr stg_ap_0_fast(void);
extern StgFunPtr stg_ap_v_fast(void);
extern StgFunPtr stg_ap_f_fast(void);
extern StgFunPtr stg_ap_d_fast(void);
extern StgFunPtr stg_ap_l_fast(void);
extern StgFunPtr stg_ap_v16_fast(void);
extern StgFunPtr stg_ap_v32_fast(void);
extern StgFunPtr stg_ap_v64_fast(void);
extern StgFunPtr stg_ap_n_fast(void);
extern StgFunPtr stg_ap_p_fast(void);
extern StgFunPtr stg_ap_pv_fast(void);
extern StgFunPtr stg_ap_pp_fast(void);
extern StgFunPtr stg_ap_ppv_fast(void);
extern StgFunPtr stg_ap_ppp_fast(void);
extern StgFunPtr stg_ap_pppv_fast(void);
extern StgFunPtr stg_ap_pppp_fast(void);
extern StgFunPtr stg_ap_ppppp_fast(void);
extern StgFunPtr stg_ap_pppppp_fast(void);
extern StgFunPtr stg_PAP_apply(void);



extern StgFunPtr stg_gc_noregs(void);

extern const StgInfoTable stg_ret_v_info;
extern const StgInfoTable stg_ret_p_info;
extern const StgInfoTable stg_ret_n_info;
extern const StgInfoTable stg_ret_f_info;
extern const StgInfoTable stg_ret_d_info;
extern const StgInfoTable stg_ret_l_info;
extern const StgInfoTable stg_ret_t_info;

extern StgFunPtr stg_gc_prim(void);
extern StgFunPtr stg_gc_prim_p(void);
extern StgFunPtr stg_gc_prim_pp(void);
extern StgFunPtr stg_gc_prim_n(void);

extern const StgInfoTable stg_gc_prim_p_ll_ret_info;
extern StgFunPtr stg_gc_prim_p_ll(void);

extern const StgInfoTable stg_enter_info;
extern StgFunPtr __stg_gc_enter_1(void);

extern StgFunPtr stg_gc_unpt_r1(void);
extern StgFunPtr stg_gc_unbx_r1(void);
extern StgFunPtr stg_gc_f1(void);
extern StgFunPtr stg_gc_d1(void);
extern StgFunPtr stg_gc_l1(void);
extern StgFunPtr stg_gc_pp(void);
extern StgFunPtr stg_gc_ppp(void);
extern StgFunPtr stg_gc_pppp(void);

extern const StgInfoTable stg_gc_fun_info;
extern StgFunPtr __stg_gc_fun(void);

extern StgFunPtr stg_yield_noregs(void);
extern StgFunPtr stg_yield_to_interpreter(void);
extern StgFunPtr stg_block_noregs(void);
extern StgFunPtr stg_block_blackhole(void);
extern StgFunPtr stg_block_blackhole_finally(void);
extern StgFunPtr stg_block_takemvar(void);
extern StgFunPtr stg_block_readmvar(void);
extern const StgInfoTable stg_block_takemvar_info;
extern const StgInfoTable stg_block_readmvar_info;
extern StgFunPtr stg_block_putmvar(void);
extern const StgInfoTable stg_block_putmvar_info;






extern StgFunPtr stg_block_stmwait(void);
extern StgFunPtr stg_block_throwto(void);
extern const StgInfoTable stg_block_throwto_info;

extern StgFunPtr stg_readIOPortzh(void);
extern StgFunPtr stg_writeIOPortzh(void);
extern StgFunPtr stg_newIOPortzh(void);



extern const StgInfoTable stg_stop_thread_info;

extern StgFunPtr stg_returnToStackTop(void);
extern StgFunPtr stg_returnToSched(void);
extern StgFunPtr stg_returnToSchedNotPaused(void);
extern StgFunPtr stg_returnToSchedButFirst(void);
extern StgFunPtr stg_threadFinished(void);

extern StgFunPtr StgReturn(void);





extern StgFunPtr stg_decodeFloatzuIntzh(void);
extern StgFunPtr stg_decodeDoublezu2Intzh(void);
extern StgFunPtr stg_decodeDoublezuInt64zh(void);

extern StgFunPtr stg_unsafeThawArrayzh(void);
extern StgFunPtr stg_casArrayzh(void);
extern StgFunPtr stg_newByteArrayzh(void);
extern StgFunPtr stg_newPinnedByteArrayzh(void);
extern StgFunPtr stg_newAlignedPinnedByteArrayzh(void);
extern StgFunPtr stg_isByteArrayPinnedzh(void);
extern StgFunPtr stg_isMutableByteArrayPinnedzh(void);
extern StgFunPtr stg_shrinkMutableByteArrayzh(void);
extern StgFunPtr stg_resizzeMutableByteArrayzh(void);
extern StgFunPtr stg_shrinkSmallMutableArrayzh(void);
extern StgFunPtr stg_casIntArrayzh(void);
extern StgFunPtr stg_newArrayzh(void);
extern StgFunPtr stg_newArrayArrayzh(void);
extern StgFunPtr stg_copyArrayzh(void);
extern StgFunPtr stg_copyMutableArrayzh(void);
extern StgFunPtr stg_copyArrayArrayzh(void);
extern StgFunPtr stg_copyMutableArrayArrayzh(void);
extern StgFunPtr stg_cloneArrayzh(void);
extern StgFunPtr stg_cloneMutableArrayzh(void);
extern StgFunPtr stg_freezzeArrayzh(void);
extern StgFunPtr stg_thawArrayzh(void);

extern StgFunPtr stg_newSmallArrayzh(void);
extern StgFunPtr stg_unsafeThawSmallArrayzh(void);
extern StgFunPtr stg_cloneSmallArrayzh(void);
extern StgFunPtr stg_cloneSmallMutableArrayzh(void);
extern StgFunPtr stg_freezzeSmallArrayzh(void);
extern StgFunPtr stg_thawSmallArrayzh(void);
extern StgFunPtr stg_copySmallArrayzh(void);
extern StgFunPtr stg_copySmallMutableArrayzh(void);
extern StgFunPtr stg_casSmallArrayzh(void);

extern StgFunPtr stg_newMutVarzh(void);
extern StgFunPtr stg_atomicModifyMutVar2zh(void);
extern StgFunPtr stg_atomicModifyMutVarzuzh(void);
extern StgFunPtr stg_casMutVarzh(void);

extern StgFunPtr stg_isEmptyMVarzh(void);
extern StgFunPtr stg_newMVarzh(void);
extern StgFunPtr stg_takeMVarzh(void);
extern StgFunPtr stg_putMVarzh(void);
extern StgFunPtr stg_readMVarzh(void);
extern StgFunPtr stg_tryTakeMVarzh(void);
extern StgFunPtr stg_tryPutMVarzh(void);
extern StgFunPtr stg_tryReadMVarzh(void);

extern StgFunPtr stg_waitReadzh(void);
extern StgFunPtr stg_waitWritezh(void);
extern StgFunPtr stg_delayzh(void);






extern StgFunPtr stg_catchzh(void);
extern StgFunPtr stg_raisezh(void);
extern StgFunPtr stg_raiseDivZZerozh(void);
extern StgFunPtr stg_raiseUnderflowzh(void);
extern StgFunPtr stg_raiseOverflowzh(void);
extern StgFunPtr stg_raiseIOzh(void);
extern StgFunPtr stg_paniczh(void);
extern StgFunPtr stg_keepAlivezh(void);
extern StgFunPtr stg_absentErrorzh(void);

extern StgFunPtr stg_makeStableNamezh(void);
extern StgFunPtr stg_makeStablePtrzh(void);
extern StgFunPtr stg_deRefStablePtrzh(void);

extern StgFunPtr stg_compactAddzh(void);
extern StgFunPtr stg_compactAddWithSharingzh(void);
extern StgFunPtr stg_compactNewzh(void);
extern StgFunPtr stg_compactAppendzh(void);
extern StgFunPtr stg_compactResizzezh(void);
extern StgFunPtr stg_compactGetRootzh(void);
extern StgFunPtr stg_compactContainszh(void);
extern StgFunPtr stg_compactContainsAnyzh(void);
extern StgFunPtr stg_compactGetFirstBlockzh(void);
extern StgFunPtr stg_compactGetNextBlockzh(void);
extern StgFunPtr stg_compactAllocateBlockzh(void);
extern StgFunPtr stg_compactFixupPointerszh(void);
extern StgFunPtr stg_compactSizzezh(void);

extern StgFunPtr stg_forkzh(void);
extern StgFunPtr stg_forkOnzh(void);
extern StgFunPtr stg_yieldzh(void);
extern StgFunPtr stg_killMyself(void);
extern StgFunPtr stg_killThreadzh(void);
extern StgFunPtr stg_getMaskingStatezh(void);
extern StgFunPtr stg_maskAsyncExceptionszh(void);
extern StgFunPtr stg_maskUninterruptiblezh(void);
extern StgFunPtr stg_unmaskAsyncExceptionszh(void);
extern StgFunPtr stg_myThreadIdzh(void);
extern StgFunPtr stg_labelThreadzh(void);
extern StgFunPtr stg_isCurrentThreadBoundzh(void);
extern StgFunPtr stg_threadStatuszh(void);

extern StgFunPtr stg_mkWeakzh(void);
extern StgFunPtr stg_mkWeakNoFinalizzerzh(void);
extern StgFunPtr stg_mkWeakForeignzh(void);
extern StgFunPtr stg_addCFinalizzerToWeakzh(void);
extern StgFunPtr stg_finalizzeWeakzh(void);
extern StgFunPtr stg_deRefWeakzh(void);

extern StgFunPtr stg_runRWzh(void);

extern StgFunPtr stg_newBCOzh(void);
extern StgFunPtr stg_mkApUpd0zh(void);

extern StgFunPtr stg_retryzh(void);
extern StgFunPtr stg_catchRetryzh(void);
extern StgFunPtr stg_catchSTMzh(void);
extern StgFunPtr stg_atomicallyzh(void);
extern StgFunPtr stg_newTVarzh(void);
extern StgFunPtr stg_readTVarzh(void);
extern StgFunPtr stg_readTVarIOzh(void);
extern StgFunPtr stg_writeTVarzh(void);

extern StgFunPtr stg_unpackClosurezh(void);
extern StgFunPtr stg_closureSizzezh(void);
extern StgFunPtr stg_whereFromzh(void);
extern StgFunPtr stg_getApStackValzh(void);
extern StgFunPtr stg_getSparkzh(void);
extern StgFunPtr stg_numSparkszh(void);

extern StgFunPtr stg_noDuplicatezh(void);

extern StgFunPtr stg_traceCcszh(void);
extern StgFunPtr stg_clearCCSzh(void);
extern StgFunPtr stg_traceEventzh(void);
extern StgFunPtr stg_traceBinaryEventzh(void);
extern StgFunPtr stg_traceMarkerzh(void);
extern StgFunPtr stg_getThreadAllocationCounterzh(void);
extern StgFunPtr stg_setThreadAllocationCounterzh(void);
# 239 "includes/Rts.h" 2
# 1 "includes/rts/storage/Block.h" 1
# 9 "includes/rts/storage/Block.h"
       
# 20 "includes/rts/storage/Block.h"
#define UNIT 1UL
# 30 "includes/rts/storage/Block.h"
#define BLOCK_SIZE (UNIT<<BLOCK_SHIFT)



#define BLOCK_SIZE_W (BLOCK_SIZE/sizeof(W_))
#define BLOCK_MASK (BLOCK_SIZE-1)

#define BLOCK_ROUND_UP(p) (((W_)(p)+BLOCK_SIZE-1) & ~BLOCK_MASK)
#define BLOCK_ROUND_DOWN(p) ((void *) ((W_)(p) & ~BLOCK_MASK))






#define MBLOCK_SIZE (UNIT<<MBLOCK_SHIFT)



#define MBLOCK_SIZE_W (MBLOCK_SIZE/sizeof(W_))
#define MBLOCK_MASK (MBLOCK_SIZE-1)

#define MBLOCK_ROUND_UP(p) ((void *)(((W_)(p)+MBLOCK_SIZE-1) & ~MBLOCK_MASK))
#define MBLOCK_ROUND_DOWN(p) ((void *)((W_)(p) & ~MBLOCK_MASK ))





#define LARGE_OBJECT_THRESHOLD ((uint32_t)(BLOCK_SIZE * 8 / 10))
# 89 "includes/rts/storage/Block.h"
struct NonmovingSegmentInfo {
  StgWord8 log_block_size;
  StgWord16 next_free_snap;
};

typedef struct bdescr_ {

    StgPtr start;


    union {
        StgPtr free;
# 111 "includes/rts/storage/Block.h"
        struct NonmovingSegmentInfo nonmoving_segment;
    };

    struct bdescr_ *link;

    union {
        struct bdescr_ *back;
        StgWord *bitmap;
        StgPtr scan;
    } u;

    struct generation_ *gen;

    StgWord16 gen_no;
    StgWord16 dest_no;
    StgWord16 node;

    StgWord16 flags;

    StgWord32 blocks;



    StgWord32 _padding[3];



} bdescr;



#define BDESCR_SIZE 0x40
#define BDESCR_MASK 0x3f
#define BDESCR_SHIFT 6







#define BF_EVACUATED 1

#define BF_LARGE 2

#define BF_PINNED 4


#define BF_MARKED 8

#define BF_EXEC 32

#define BF_FRAGMENTED 64

#define BF_KNOWN 128

#define BF_SWEPT 256

#define BF_COMPACT 512

#define BF_NONMOVING 1024



#define BF_NONMOVING_SWEEPING 2048

#define BF_FLAG_MAX (1 << 15)
# 189 "includes/rts/storage/Block.h"
inline bdescr *Bdescr(StgPtr p);
inline bdescr *Bdescr(StgPtr p)
{
  return (bdescr *)
    ((((W_)p & ((1UL<<20)-1) & ~((1UL<<12)-1)) >> (12 -6))
     | ((W_)p & ~((1UL<<20)-1))
     );
}







#define FIRST_BLOCK_OFF ((W_)BLOCK_ROUND_UP(BDESCR_SIZE * (MBLOCK_SIZE / BLOCK_SIZE)))




#define FIRST_BLOCK(m) ((void *)(FIRST_BLOCK_OFF + (W_)(m)))



#define LAST_BLOCK(m) ((void *)(MBLOCK_SIZE-BLOCK_SIZE + (W_)(m)))



#define FIRST_BDESCR(m) ((bdescr *)((FIRST_BLOCK_OFF>>(BLOCK_SHIFT-BDESCR_SHIFT)) + (W_)(m)))




#define LAST_BDESCR(m) ((bdescr *)(((MBLOCK_SIZE-BLOCK_SIZE)>>(BLOCK_SHIFT-BDESCR_SHIFT)) + (W_)(m)))





#define BLOCKS_PER_MBLOCK ((MBLOCK_SIZE - FIRST_BLOCK_OFF) / BLOCK_SIZE)




#define MBLOCK_GROUP_BLOCKS(n) (BLOCKS_PER_MBLOCK + (n-1) * (MBLOCK_SIZE / BLOCK_SIZE))




#define BLOCKS_TO_MBLOCKS(n) (1 + (W_)MBLOCK_ROUND_UP((n-BLOCKS_PER_MBLOCK) * BLOCK_SIZE) / MBLOCK_SIZE)
# 247 "includes/rts/storage/Block.h"
static inline void
dbl_link_onto(bdescr *bd, bdescr **list)
{
  bd->link = *list;
  bd->u.back = 
# 251 "includes/rts/storage/Block.h" 3 4
              ((void *)0)
# 251 "includes/rts/storage/Block.h"
                  ;
  if (*list) {
    (*list)->u.back = bd;
  }
  *list = bd;
}

static inline void
dbl_link_remove(bdescr *bd, bdescr **list)
{
    if (bd->u.back) {
        bd->u.back->link = bd->link;
    } else {
        *list = bd->link;
    }
    if (bd->link) {
        bd->link->u.back = bd->u.back;
    }
}

static inline void
dbl_link_insert_after(bdescr *bd, bdescr *after)
{
    bd->link = after->link;
    bd->u.back = after;
    if (after->link) {
        after->link->u.back = bd;
    }
    after->link = bd;
}

static inline void
dbl_link_replace(bdescr *new_, bdescr *old, bdescr **list)
{
    new_->link = old->link;
    new_->u.back = old->u.back;
    if (old->link) {
        old->link->u.back = new_;
    }
    if (old->u.back) {
        old->u.back->link = new_;
    } else {
        *list = new_;
    }
}



extern void initBlockAllocator(void);



bdescr *allocGroup(W_ n);

inline bdescr* allocBlock(void);
inline bdescr* allocBlock(void)
{
    return allocGroup(1);
}

bdescr *allocGroupOnNode(uint32_t node, W_ n);






bdescr *allocAlignedGroupOnNode(uint32_t node, W_ n);

inline bdescr* allocBlockOnNode(uint32_t node);
inline bdescr* allocBlockOnNode(uint32_t node)
{
    return allocGroupOnNode(node,1);
}


bdescr *allocGroup_lock(W_ n);
bdescr *allocBlock_lock(void);

bdescr *allocGroupOnNode_lock(uint32_t node, W_ n);
bdescr *allocBlockOnNode_lock(uint32_t node);



void freeGroup(bdescr *p);
void freeChain(bdescr *p);


void freeGroup_lock(bdescr *p);
void freeChain_lock(bdescr *p);





static inline StgWord
round_to_mblocks(StgWord words)
{
    if (words > (((1UL<<20) - ((W_)(((W_)(0x40 * ((1UL<<20) / (1UL<<12)))+(1UL<<12)-1) & ~((1UL<<12)-1)))) / (1UL<<12)) * ((1UL<<12)/sizeof(W_))) {



        words += ((W_)(((W_)(0x40 * ((1UL<<20) / (1UL<<12)))+(1UL<<12)-1) & ~((1UL<<12)-1)))/sizeof(W_);

        if ((words % ((1UL<<20)/sizeof(W_))) < (((1UL<<20)/sizeof(W_)) / 2)) {
            words = (words / ((1UL<<20)/sizeof(W_))) * ((1UL<<20)/sizeof(W_));
        } else {
            words = ((words / ((1UL<<20)/sizeof(W_))) + 1) * ((1UL<<20)/sizeof(W_));
        }

        words -= ((W_)(((W_)(0x40 * ((1UL<<20) / (1UL<<12)))+(1UL<<12)-1) & ~((1UL<<12)-1)))/sizeof(W_);
    }
    return words;
}
# 240 "includes/Rts.h" 2
# 1 "includes/rts/storage/ClosureMacros.h" 1
# 9 "includes/rts/storage/ClosureMacros.h"
       
# 48 "includes/rts/storage/ClosureMacros.h"
static inline void SET_INFO(StgClosure *c, const StgInfoTable *info) {
    __atomic_store_n(&c->header.info, info, 0);
}
static inline void SET_INFO_RELEASE(StgClosure *c, const StgInfoTable *info) {
    __atomic_store_n(&c->header.info, info, 3);
}
static inline const StgInfoTable *GET_INFO(StgClosure *c) {
    return __atomic_load_n(&c->header.info, 0);
}


inline StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info);
inline StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgInfoTable *)info - 1;}
inline StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info);
inline StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgRetInfoTable *)info - 1;}
static inline StgFunInfoTable *FUN_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgFunInfoTable *)info - 1;}
static inline StgThunkInfoTable *THUNK_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgThunkInfoTable *)info - 1;}
static inline StgConInfoTable *CON_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgConInfoTable *)info - 1;}
static inline StgFunInfoTable *itbl_to_fun_itbl(const StgInfoTable *i) {return (StgFunInfoTable *)(i + 1) - 1;}
static inline StgRetInfoTable *itbl_to_ret_itbl(const StgInfoTable *i) {return (StgRetInfoTable *)(i + 1) - 1;}
static inline StgThunkInfoTable *itbl_to_thunk_itbl(const StgInfoTable *i) {return (StgThunkInfoTable *)(i + 1) - 1;}
static inline StgConInfoTable *itbl_to_con_itbl(const StgInfoTable *i) {return (StgConInfoTable *)(i + 1) - 1;}
# 84 "includes/rts/storage/ClosureMacros.h"
inline const StgInfoTable *get_itbl(const StgClosure *c);
inline const StgInfoTable *get_itbl(const StgClosure *c)
{
    return INFO_PTR_TO_STRUCT(__atomic_load_n(&c->header.info, 0));
}

inline const StgRetInfoTable *get_ret_itbl(const StgClosure *c);
inline const StgRetInfoTable *get_ret_itbl(const StgClosure *c)
{
    return RET_INFO_PTR_TO_STRUCT(__atomic_load_n(&c->header.info, 0));
}

static inline const StgFunInfoTable *get_fun_itbl(const StgClosure *c)
{
    return FUN_INFO_PTR_TO_STRUCT(__atomic_load_n(&c->header.info, 0));
}

static inline const StgThunkInfoTable *get_thunk_itbl(const StgClosure *c)
{
    return THUNK_INFO_PTR_TO_STRUCT(__atomic_load_n(&c->header.info, 0));
}

static inline const StgConInfoTable *get_con_itbl(const StgClosure *c)
{
    return CON_INFO_PTR_TO_STRUCT(__atomic_load_n(&c->header.info, 0));
}

static inline StgHalfWord GET_TAG(const StgClosure *con)
{
    return get_itbl(con)->srt;
}
# 134 "includes/rts/storage/ClosureMacros.h"
#define SET_PROF_HDR(c,ccs_) ((c)->header.prof.ccs = ccs_, LDV_RECORD_CREATE((c)))






#define SET_HDR(c,_info,ccs) { SET_PROF_HDR((StgClosure *)(c),ccs); RELAXED_STORE(&(c)->header.info, _info); }





#define SET_HDR_RELEASE(c,_info,ccs) { SET_PROF_HDR((StgClosure *)(c),ccs); RELEASE_STORE(&(c)->header.info, _info); }





#define SET_ARR_HDR(c,info,costCentreStack,n_bytes) (c)->bytes = n_bytes; SET_HDR(c,info,costCentreStack);




#define OVERWRITE_INFO(c,new_info) OVERWRITING_CLOSURE((StgClosure *)(c)); SET_INFO((StgClosure *)(c), (new_info)); LDV_RECORD_CREATE(c);
# 168 "includes/rts/storage/ClosureMacros.h"
#define THUNK_STATIC_LINK(p) (&(p)->payload[1])
#define IND_STATIC_LINK(p) (&(p)->payload[1])

static inline StgClosure **
STATIC_LINK(const StgInfoTable *info, StgClosure *p)
{
    switch (info->type) {
    case 21:
        return (&(p)->payload[1]);
    case 28:
        return (&(p)->payload[1]);
    default:
        return &p->payload[info->layout.payload.ptrs +
                           info->layout.payload.nptrs];
    }
}





static inline P_ CHARLIKE_CLOSURE(int n) {
    return (P_)&stg_CHARLIKE_closure[(n)-0];
}
static inline P_ INTLIKE_CLOSURE(int n) {
    return (P_)&stg_INTLIKE_closure[(n)-(-16)];
}






static inline StgWord
GET_CLOSURE_TAG(const StgClosure * p)
{
    return (StgWord)p & ((1 << 3) - 1);
}

static inline StgClosure *
UNTAG_CLOSURE(StgClosure * p)
{
    return (StgClosure*)((StgWord)p & ~((1 << 3) - 1));
}

static inline const StgClosure *
UNTAG_CONST_CLOSURE(const StgClosure * p)
{
    return (const StgClosure*)((StgWord)p & ~((1 << 3) - 1));
}

static inline StgClosure *
TAG_CLOSURE(StgWord tag,StgClosure * p)
{
    return (StgClosure*)((StgWord)p | tag);
}





#define IS_FORWARDING_PTR(p) ((((StgWord)p) & 1) != 0)
#define MK_FORWARDING_PTR(p) (((StgWord)p) | 1)
#define UN_FORWARDING_PTR(p) (((StgWord)p) - 1)
# 250 "includes/rts/storage/ClosureMacros.h"
static inline 
# 250 "includes/rts/storage/ClosureMacros.h" 3 4
             _Bool 
# 250 "includes/rts/storage/ClosureMacros.h"
                  LOOKS_LIKE_INFO_PTR_NOT_NULL (StgWord p)
{
    StgInfoTable *info = INFO_PTR_TO_STRUCT((StgInfoTable *)p);
    return info->type != 0 && info->type < 64;
}

static inline 
# 256 "includes/rts/storage/ClosureMacros.h" 3 4
             _Bool 
# 256 "includes/rts/storage/ClosureMacros.h"
                  LOOKS_LIKE_INFO_PTR (StgWord p)
{
    return p && (((((StgWord)p) & 1) != 0) || LOOKS_LIKE_INFO_PTR_NOT_NULL(p));
}

static inline 
# 261 "includes/rts/storage/ClosureMacros.h" 3 4
             _Bool 
# 261 "includes/rts/storage/ClosureMacros.h"
                  LOOKS_LIKE_CLOSURE_PTR (const void *p)
{
    const StgInfoTable *info = __atomic_load_n(&UNTAG_CONST_CLOSURE((const StgClosure *) (p))->header.info, 0);
    return LOOKS_LIKE_INFO_PTR((StgWord) info);
}





inline StgOffset PAP_sizeW ( uint32_t n_args );
inline StgOffset PAP_sizeW ( uint32_t n_args )
{ return (((sizeof(StgPAP)) + sizeof(W_) - 1) / sizeof(W_)) + n_args; }

inline StgOffset AP_sizeW ( uint32_t n_args );
inline StgOffset AP_sizeW ( uint32_t n_args )
{ return (((sizeof(StgAP)) + sizeof(W_) - 1) / sizeof(W_)) + n_args; }

inline StgOffset AP_STACK_sizeW ( uint32_t size );
inline StgOffset AP_STACK_sizeW ( uint32_t size )
{ return (((sizeof(StgAP_STACK)) + sizeof(W_) - 1) / sizeof(W_)) + size; }

inline StgOffset CONSTR_sizeW( uint32_t p, uint32_t np );
inline StgOffset CONSTR_sizeW( uint32_t p, uint32_t np )
{ return (((sizeof(StgHeader)) + sizeof(W_) - 1) / sizeof(W_)) + p + np; }

inline StgOffset THUNK_SELECTOR_sizeW ( void );
inline StgOffset THUNK_SELECTOR_sizeW ( void )
{ return (((sizeof(StgSelector)) + sizeof(W_) - 1) / sizeof(W_)); }

inline StgOffset BLACKHOLE_sizeW ( void );
inline StgOffset BLACKHOLE_sizeW ( void )
{ return (((sizeof(StgInd)) + sizeof(W_) - 1) / sizeof(W_)); }





inline StgOffset sizeW_fromITBL( const StgInfoTable* itbl );
inline StgOffset sizeW_fromITBL( const StgInfoTable* itbl )
{ return (((sizeof(StgClosure)) + sizeof(W_) - 1) / sizeof(W_))
       + (((sizeof(StgPtr)) + sizeof(W_) - 1) / sizeof(W_)) * itbl->layout.payload.ptrs
       + (((sizeof(StgWord)) + sizeof(W_) - 1) / sizeof(W_)) * itbl->layout.payload.nptrs; }

inline StgOffset thunk_sizeW_fromITBL( const StgInfoTable* itbl );
inline StgOffset thunk_sizeW_fromITBL( const StgInfoTable* itbl )
{ return (((sizeof(StgThunk)) + sizeof(W_) - 1) / sizeof(W_))
       + (((sizeof(StgPtr)) + sizeof(W_) - 1) / sizeof(W_)) * itbl->layout.payload.ptrs
       + (((sizeof(StgWord)) + sizeof(W_) - 1) / sizeof(W_)) * itbl->layout.payload.nptrs; }

inline StgOffset ap_stack_sizeW( StgAP_STACK* x );
inline StgOffset ap_stack_sizeW( StgAP_STACK* x )
{ return AP_STACK_sizeW(x->size); }

inline StgOffset ap_sizeW( StgAP* x );
inline StgOffset ap_sizeW( StgAP* x )
{ return AP_sizeW(x->n_args); }

inline StgOffset pap_sizeW( StgPAP* x );
inline StgOffset pap_sizeW( StgPAP* x )
{ return PAP_sizeW(x->n_args); }

inline StgWord arr_words_words( StgArrBytes* x);
inline StgWord arr_words_words( StgArrBytes* x)
{ return (((x->bytes) + sizeof(W_) - 1) / sizeof(W_)); }

inline StgOffset arr_words_sizeW( StgArrBytes* x );
inline StgOffset arr_words_sizeW( StgArrBytes* x )
{ return (((sizeof(StgArrBytes)) + sizeof(W_) - 1) / sizeof(W_)) + arr_words_words(x); }

inline StgOffset mut_arr_ptrs_sizeW( StgMutArrPtrs* x );
inline StgOffset mut_arr_ptrs_sizeW( StgMutArrPtrs* x )
{ return (((sizeof(StgMutArrPtrs)) + sizeof(W_) - 1) / sizeof(W_)) + x->size; }

inline StgOffset small_mut_arr_ptrs_sizeW( StgSmallMutArrPtrs* x );
inline StgOffset small_mut_arr_ptrs_sizeW( StgSmallMutArrPtrs* x )
{ return (((sizeof(StgSmallMutArrPtrs)) + sizeof(W_) - 1) / sizeof(W_)) + x->ptrs; }

inline StgWord stack_sizeW ( StgStack *stack );
inline StgWord stack_sizeW ( StgStack *stack )
{ return (((sizeof(StgStack)) + sizeof(W_) - 1) / sizeof(W_)) + stack->stack_size; }

inline StgWord bco_sizeW ( StgBCO *bco );
inline StgWord bco_sizeW ( StgBCO *bco )
{ return bco->size; }

inline StgWord compact_nfdata_full_sizeW ( StgCompactNFData *str );
inline StgWord compact_nfdata_full_sizeW ( StgCompactNFData *str )
{ return str->totalW; }






inline uint32_t
closure_sizeW_ (const StgClosure *p, const StgInfoTable *info);
inline uint32_t
closure_sizeW_ (const StgClosure *p, const StgInfoTable *info)
{
    switch (info->type) {
    case 17:
    case 16:
        return (((sizeof(StgThunk)) + sizeof(W_) - 1) / sizeof(W_)) + 1;
    case 10:
    case 3:
    case 9:
    case 2:
        return (((sizeof(StgHeader)) + sizeof(W_) - 1) / sizeof(W_)) + 1;
    case 20:
    case 19:
    case 18:
        return (((sizeof(StgThunk)) + sizeof(W_) - 1) / sizeof(W_)) + 2;
    case 13:
    case 6:
    case 12:
    case 5:
    case 11:
    case 4:
        return (((sizeof(StgHeader)) + sizeof(W_) - 1) / sizeof(W_)) + 2;
    case 15:
        return thunk_sizeW_fromITBL(info);
    case 22:
        return THUNK_SELECTOR_sizeW();
    case 26:
        return ap_stack_sizeW((StgAP_STACK *)p);
    case 24:
        return ap_sizeW((StgAP *)p);
    case 25:
        return pap_sizeW((StgPAP *)p);
    case 27:
        return (((sizeof(StgInd)) + sizeof(W_) - 1) / sizeof(W_));
    case 42:
        return arr_words_sizeW((StgArrBytes *)p);
    case 43:
    case 44:
    case 46:
    case 45:
        return mut_arr_ptrs_sizeW((StgMutArrPtrs*)p);
    case 59:
    case 60:
    case 62:
    case 61:
        return small_mut_arr_ptrs_sizeW((StgSmallMutArrPtrs*)p);
    case 52:
        return (((sizeof(StgTSO)) + sizeof(W_) - 1) / sizeof(W_));
    case 53:
        return stack_sizeW((StgStack*)p);
    case 23:
        return bco_sizeW((StgBCO *)p);
    case 54:
        return (((sizeof(StgTRecChunk)) + sizeof(W_) - 1) / sizeof(W_));
    default:
        return sizeW_fromITBL(info);
    }
}


inline uint32_t closure_sizeW (const StgClosure *p);
inline uint32_t closure_sizeW (const StgClosure *p)
{
    return closure_sizeW_(p, get_itbl(p));
}





inline StgWord stack_frame_sizeW( StgClosure *frame );
inline StgWord stack_frame_sizeW( StgClosure *frame )
{
    const StgRetInfoTable *info;

    info = get_ret_itbl(frame);
    switch (info->i.type) {

    case 32:
        return (((sizeof(StgRetFun)) + sizeof(W_) - 1) / sizeof(W_)) + ((StgRetFun *)frame)->size;

    case 31:
        return 1 + ((StgLargeBitmap*) (((StgWord) ((&info->i)+1)) + (&info->i)->layout.large_bitmap_offset))->size;

    case 29:
        return 2 + (((StgLargeBitmap *)((StgBCO *)((StgBCO *)((P_)frame)[1]))->bitmap)->size);

    default:
        return 1 + ((info->i.layout.bitmap) & 0x3f);
    }
}
# 461 "includes/rts/storage/ClosureMacros.h"
static inline W_ mutArrPtrsCards (W_ elems)
{
    return (W_)((elems + (1 << 7) - 1)
                           >> 7);
}


static inline W_ mutArrPtrsCardTableSize (W_ elems)
{
    return (((mutArrPtrsCards(elems)) + sizeof(W_) - 1) / sizeof(W_));
}


static inline StgWord8 *mutArrPtrsCard (StgMutArrPtrs *a, W_ n)
{
    return ((StgWord8 *)&(a->payload[a->ptrs]) + n);
}
# 521 "includes/rts/storage/ClosureMacros.h"
#define OVERWRITING_CLOSURE(c) overwritingClosure(c)

#define OVERWRITING_CLOSURE_SIZE(c,size) overwritingClosureSize(c, size)

#define OVERWRITING_CLOSURE_MUTABLE(c,off) overwritingMutableClosureOfs(c, off)
# 537 "includes/rts/storage/ClosureMacros.h"
void LDV_recordDead (const StgClosure *c, uint32_t size);
__attribute__((visibility("hidden"))) 
# 538 "includes/rts/storage/ClosureMacros.h" 3 4
           _Bool 
# 538 "includes/rts/storage/ClosureMacros.h"
                isInherentlyUsed ( StgHalfWord closure_type );


inline void
zeroSlop (
    StgClosure *p,
    uint32_t offset,
    uint32_t size,
    
# 546 "includes/rts/storage/ClosureMacros.h" 3 4
   _Bool 
# 546 "includes/rts/storage/ClosureMacros.h"
        known_mutable
    );

inline void
zeroSlop (StgClosure *p, uint32_t offset, uint32_t size, 
# 550 "includes/rts/storage/ClosureMacros.h" 3 4
                                                        _Bool 
# 550 "includes/rts/storage/ClosureMacros.h"
                                                             known_mutable)
{


    const 
# 554 "includes/rts/storage/ClosureMacros.h" 3 4
         _Bool 
# 554 "includes/rts/storage/ClosureMacros.h"
              want_to_zero_immutable_slop = 
# 554 "includes/rts/storage/ClosureMacros.h" 3 4
                                            0

        
# 556 "includes/rts/storage/ClosureMacros.h"
       || RtsFlags.DebugFlags.sanity


        || era > 0

        ;

    const 
# 563 "includes/rts/storage/ClosureMacros.h" 3 4
         _Bool 
# 563 "includes/rts/storage/ClosureMacros.h"
              can_zero_immutable_slop =

        RtsFlags.ParFlags.nCapabilities <= 1;

    const 
# 567 "includes/rts/storage/ClosureMacros.h" 3 4
         _Bool 
# 567 "includes/rts/storage/ClosureMacros.h"
              zero_slop_immutable =
        want_to_zero_immutable_slop && can_zero_immutable_slop;

    const 
# 570 "includes/rts/storage/ClosureMacros.h" 3 4
         _Bool 
# 570 "includes/rts/storage/ClosureMacros.h"
              zero_slop_mutable =
# 579 "includes/rts/storage/ClosureMacros.h"
        
# 579 "includes/rts/storage/ClosureMacros.h" 3 4
       1



        
# 583 "includes/rts/storage/ClosureMacros.h"
       ;

    const 
# 585 "includes/rts/storage/ClosureMacros.h" 3 4
         _Bool 
# 585 "includes/rts/storage/ClosureMacros.h"
              zero_slop =


        known_mutable ? zero_slop_mutable : zero_slop_immutable;

    if(!zero_slop)
        return;

    for (uint32_t i = offset; i < size; i++) {
        ((StgWord *)p)[i] = 0;
    }
}

inline void overwritingClosure (StgClosure *p);
inline void overwritingClosure (StgClosure *p)
{
    W_ size = closure_sizeW(p);

    if(era > 0 && !isInherentlyUsed(get_itbl(p)->type))
        LDV_recordDead(p, size);

    zeroSlop(p, (((sizeof(StgThunkHeader)) + sizeof(W_) - 1) / sizeof(W_)), size, 
# 606 "includes/rts/storage/ClosureMacros.h" 3 4
                                                                0
# 606 "includes/rts/storage/ClosureMacros.h"
                                                                     );
}





inline void
overwritingMutableClosureOfs (StgClosure *p, uint32_t offset);

inline void
overwritingMutableClosureOfs (StgClosure *p, uint32_t offset)
{
# 628 "includes/rts/storage/ClosureMacros.h"
    if (__builtin_expect(!!(isInherentlyUsed(get_itbl(p)->type) == 
# 628 "includes/rts/storage/ClosureMacros.h" 3 4
   1
# 628 "includes/rts/storage/ClosureMacros.h"
   ), 1)) ; else _assertFail("includes/rts/storage/ClosureMacros.h", 628);

    zeroSlop(p, offset, closure_sizeW(p), 
# 630 "includes/rts/storage/ClosureMacros.h" 3 4
                                                           1
# 630 "includes/rts/storage/ClosureMacros.h"
                                                               );
}


inline void overwritingClosureSize (StgClosure *p, uint32_t size );
inline void overwritingClosureSize (StgClosure *p, uint32_t size)
{



    if (__builtin_expect(!!(isInherentlyUsed(get_itbl(p)->type) == 
# 640 "includes/rts/storage/ClosureMacros.h" 3 4
   0
# 640 "includes/rts/storage/ClosureMacros.h"
   ), 1)) ; else _assertFail("includes/rts/storage/ClosureMacros.h", 640);
    if(era > 0)
        LDV_recordDead(p, size);

    zeroSlop(p, (((sizeof(StgThunkHeader)) + sizeof(W_) - 1) / sizeof(W_)), size, 
# 644 "includes/rts/storage/ClosureMacros.h" 3 4
                                                                0
# 644 "includes/rts/storage/ClosureMacros.h"
                                                                     );
}
# 241 "includes/Rts.h" 2
# 1 "includes/rts/storage/MBlock.h" 1
# 12 "includes/rts/storage/MBlock.h"
       

extern W_ peak_mblocks_allocated;
extern W_ mblocks_allocated;

extern void initMBlocks(void);
extern void * getMBlock(void);
extern void * getMBlocks(uint32_t n);
extern void * getMBlockOnNode(uint32_t node);
extern void * getMBlocksOnNode(uint32_t node, uint32_t n);
extern void freeMBlocks(void *addr, uint32_t n);
extern void releaseFreeMemory(void);
extern void freeAllMBlocks(void);

extern void *getFirstMBlock(void **state);
extern void *getNextMBlock(void **state, void *mblock);



extern SpinLock gc_alloc_block_sync;
# 242 "includes/Rts.h" 2
# 1 "includes/rts/storage/GC.h" 1
# 9 "includes/rts/storage/GC.h"
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 12 "includes/rts/storage/GC.h" 2
# 55 "includes/rts/storage/GC.h"
typedef StgWord memcount;

typedef struct nursery_ {
    bdescr * blocks;
    memcount n_blocks;
} nursery;
# 83 "includes/rts/storage/GC.h"
typedef struct generation_ {
    uint32_t no;

    bdescr * blocks;
    memcount n_blocks;
    memcount n_words;

    bdescr * large_objects;
    memcount n_large_blocks;
    memcount n_large_words;
    memcount n_new_large_words;


    bdescr * compact_objects;





    memcount n_compact_blocks;
    bdescr * compact_blocks_in_import;





    memcount n_compact_blocks_in_import;







    memcount max_blocks;

    StgTSO * threads;

    StgWeak * weak_ptr_list;

    struct generation_ *to;


    uint32_t collections;
    uint32_t par_collections;
    uint32_t failed_promotions;





    char pad[128];

    SpinLock sync;



    int mark;
    int compact;




    bdescr * old_blocks;
    memcount n_old_blocks;
    memcount live_estimate;

    bdescr * scavenged_large_objects;
    memcount n_scavenged_large_blocks;

    bdescr * live_compact_objects;
    memcount n_live_compact_blocks;

    bdescr * bitmap;

    StgTSO * old_threads;
    StgWeak * old_weak_ptr_list;
} generation;

extern generation * generations;
extern generation * g0;
extern generation * oldest_gen;

typedef void(*ListBlocksCb)(void *user, bdescr *);
void listAllBlocks(ListBlocksCb cb, void *user);
# 198 "includes/rts/storage/GC.h"
StgPtr allocate ( Capability *cap, W_ n );
StgPtr allocateMightFail ( Capability *cap, W_ n );
StgPtr allocatePinned ( Capability *cap, W_ n, W_ alignment, W_ align_off);


typedef void* AdjustorWritable;
typedef void* AdjustorExecutable;

void flushExec(W_ len, AdjustorExecutable exec_addr);


extern W_ large_alloc_lim;





void performGC(void);
void performMajorGC(void);





StgInd *newCAF (StgRegTable *reg, StgIndStatic *caf);
StgInd *newRetainedCAF (StgRegTable *reg, StgIndStatic *caf);
StgInd *newGCdCAF (StgRegTable *reg, StgIndStatic *caf);
void revertCAFs (void);



void setKeepCAFs (void);



void setHighMemDynamic (void);
# 242 "includes/rts/storage/GC.h"
void dirty_MUT_VAR(StgRegTable *reg, StgMutVar *mv, StgClosure *old);



extern 
# 246 "includes/rts/storage/GC.h" 3 4
      _Bool 
# 246 "includes/rts/storage/GC.h"
           keepCAFs;



static inline void initBdescr(bdescr *bd, generation *gen, generation *dest)
{
    __atomic_store_n(&bd->gen, gen, 0);
    __atomic_store_n(&bd->gen_no, gen->no, 0);
    __atomic_store_n(&bd->dest_no, dest->no, 0);



    if (__builtin_expect(!!(gen->no < RtsFlags.GcFlags.generations), 1)) ; else _assertFail("includes/rts/storage/GC.h", 258);
    if (__builtin_expect(!!(dest->no < RtsFlags.GcFlags.generations), 1)) ; else _assertFail("includes/rts/storage/GC.h", 259);

}
# 243 "includes/Rts.h" 2
# 1 "includes/rts/NonMoving.h" 1
# 14 "includes/rts/NonMoving.h"
       


struct StgClosure_;
struct StgThunk_;
struct Capability_;


extern
void updateRemembSetPushClosure_(StgRegTable *reg, struct StgClosure_ *p);

extern
void updateRemembSetPushThunk_(StgRegTable *reg, struct StgThunk_ *p);


StgFunPtr stg_copyArray_barrier(void);




extern StgWord nonmoving_write_barrier_enabled;



#define IF_NONMOVING_WRITE_BARRIER_ENABLED if (RTS_UNLIKELY(nonmoving_write_barrier_enabled))
# 244 "includes/Rts.h" 2


# 1 "includes/rts/ForeignExports.h" 1
# 14 "includes/rts/ForeignExports.h"
       

struct _ObjectCode;



struct ForeignExportsList {


    struct ForeignExportsList *next;

    int n_entries;


    struct _ObjectCode *oc;



    StgStablePtr **stable_ptrs;

    StgPtr exports[];
};

void registerForeignExports(struct ForeignExportsList *exports);
# 247 "includes/Rts.h" 2


# 1 "includes/rts/ExecPage.h" 1




       

typedef struct {
    char contents;
} ExecPage;


ExecPage *allocateExecPage(void);


void freezeExecPage(ExecPage *page);


void freeExecPage(ExecPage *page);
# 250 "includes/Rts.h" 2
# 1 "includes/rts/Parallel.h" 1
# 14 "includes/rts/Parallel.h"
       

StgInt newSpark (StgRegTable *reg, StgClosure *p);
# 251 "includes/Rts.h" 2
# 1 "includes/rts/Signals.h" 1
# 14 "includes/rts/Signals.h"
       




#define STG_SIG_DFL (-1)
#define STG_SIG_IGN (-2)
#define STG_SIG_ERR (-3)
#define STG_SIG_HAN (-4)
#define STG_SIG_RST (-5)
# 252 "includes/Rts.h" 2
# 1 "includes/rts/BlockSignals.h" 1
# 14 "includes/rts/BlockSignals.h"
       
# 27 "includes/rts/BlockSignals.h"
void blockUserSignals(void);






void unblockUserSignals(void);
# 253 "includes/Rts.h" 2
# 1 "includes/rts/Hpc.h" 1
# 14 "includes/rts/Hpc.h"
       


typedef struct _HpcModuleInfo {
  char *modName;
  StgWord32 tickCount;
  StgWord32 hashNo;
  StgWord64 *tixArr;
  
# 22 "includes/rts/Hpc.h" 3 4
 _Bool 
# 22 "includes/rts/Hpc.h"
      from_file;
  struct _HpcModuleInfo *next;
} HpcModuleInfo;

void hs_hpc_module (char *modName,
                    StgWord32 modCount,
                    StgWord32 modHashNo,
                    StgWord64 *tixArr);

HpcModuleInfo * hs_hpc_rootModule (void);

void startupHpc(void);
void exitHpc(void);
# 254 "includes/Rts.h" 2
# 1 "includes/rts/Adjustor.h" 1
# 14 "includes/rts/Adjustor.h"
       


void* createAdjustor (int cconv,
                      StgStablePtr hptr,
                      StgFunPtr wptr,
                      char *typeString);

void freeHaskellFunctionPtr (void* ptr);
# 255 "includes/Rts.h" 2
# 1 "includes/rts/FileLock.h" 1
# 30 "includes/rts/FileLock.h"
       





int lockFile(StgWord64 id, StgWord64 dev, StgWord64 ino, int for_writing);
int unlockFile(StgWord64 id);
# 256 "includes/Rts.h" 2
# 1 "includes/rts/GetTime.h" 1
# 14 "includes/rts/GetTime.h"
       

StgWord64 getMonotonicNSec (void);
# 257 "includes/Rts.h" 2
# 1 "includes/rts/Globals.h" 1
# 17 "includes/rts/Globals.h"
       

#define mkStoreAccessorPrototype(name) StgStablePtr getOrSet ##name(StgStablePtr ptr);



StgStablePtr getOrSetGHCConcSignalSignalHandlerStore(StgStablePtr ptr);
StgStablePtr getOrSetGHCConcWindowsPendingDelaysStore(StgStablePtr ptr);
StgStablePtr getOrSetGHCConcWindowsIOManagerThreadStore(StgStablePtr ptr);
StgStablePtr getOrSetGHCConcWindowsProddingStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemEventThreadEventManagerStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemEventThreadIOManagerThreadStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemTimerThreadEventManagerStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemTimerThreadIOManagerThreadStore(StgStablePtr ptr);
StgStablePtr getOrSetLibHSghcFastStringTable(StgStablePtr ptr);
StgStablePtr getOrSetLibHSghcGlobalHasPprDebug(StgStablePtr ptr);
StgStablePtr getOrSetLibHSghcGlobalHasNoDebugOutput(StgStablePtr ptr);
StgStablePtr getOrSetLibHSghcGlobalHasNoStateHack(StgStablePtr ptr);
# 258 "includes/Rts.h" 2
# 1 "includes/rts/IOInterface.h" 1
# 14 "includes/rts/IOInterface.h"
       
# 34 "includes/rts/IOInterface.h"
void setIOManagerControlFd (uint32_t cap_no, int fd);
void setTimerManagerControlFd(int fd);
void setIOManagerWakeupFd (int fd);
# 259 "includes/Rts.h" 2
# 1 "includes/rts/Linker.h" 1
# 14 "includes/rts/Linker.h"
       





typedef char pathchar;
#define PATH_FMT "s"



void initLinker (void);
# 42 "includes/rts/Linker.h"
void initLinker_ (int retain_cafs);


HsInt insertSymbol(pathchar* obj_name, char* key, void* data);


void *lookupSymbol( char *lbl );


typedef enum {
    OBJECT_LOADED,
    OBJECT_NEEDED,
    OBJECT_RESOLVED,
    OBJECT_UNLOADED,
    OBJECT_DONT_RESOLVE,
    OBJECT_NOT_LOADED

} OStatus;


OStatus getObjectLoadStatus( pathchar *path );


HsInt unloadObj( pathchar *path );


HsInt purgeObj( pathchar *path );


HsInt loadObj( pathchar *path );


HsInt loadArchive( pathchar *path );


HsInt resolveObjs( void );






void *loadNativeObj( pathchar *path, char **errmsg );





HsInt unloadNativeObj( void *handle );


const char *addDLL( pathchar* dll_name );


HsPtr addLibrarySearchPath(pathchar* dll_path);



HsBool removeLibrarySearchPath(HsPtr dll_path_index);



void warnMissingKBLibraryPaths( void );






pathchar* findSystemLibrary(pathchar* dll_name);


StgStablePtr foreignExportStablePtr (StgPtr p);
# 260 "includes/Rts.h" 2
# 1 "includes/rts/Ticky.h" 1
# 14 "includes/rts/Ticky.h"
       





typedef struct _StgEntCounter {


    StgWord registeredp;
    StgInt arity;
    StgInt allocd;

    char *str;
    char *arg_kinds;
    StgInt entry_count;
    StgInt allocs;
    struct _StgEntCounter *link;
} StgEntCounter;
# 261 "includes/Rts.h" 2
# 1 "includes/rts/Timer.h" 1
# 14 "includes/rts/Timer.h"
       

void startTimer (void);
void stopTimer (void);
int rtsTimerSignal (void);
# 262 "includes/Rts.h" 2
# 1 "includes/rts/StablePtr.h" 1
# 14 "includes/rts/StablePtr.h"
       

__attribute__((always_inline)) inline StgPtr deRefStablePtr (StgStablePtr stable_ptr);
StgStablePtr getStablePtr (StgPtr p);





typedef struct {
    StgPtr addr;


} spEntry;

extern spEntry *stable_ptr_table;

__attribute__((always_inline)) inline
StgPtr deRefStablePtr(StgStablePtr sp)
{


    const spEntry *spt = __atomic_load_n(&stable_ptr_table, 2);

    return __atomic_load_n(&spt[(StgWord)sp].addr, 2);
}
# 263 "includes/Rts.h" 2
# 1 "includes/rts/StableName.h" 1
# 14 "includes/rts/StableName.h"
       





typedef struct {
    StgPtr addr;




    StgPtr old;

    StgClosure *sn_obj;

} snEntry;

extern snEntry *stable_name_table;
# 264 "includes/Rts.h" 2
# 1 "includes/rts/TTY.h" 1
# 14 "includes/rts/TTY.h"
       

void* __hscore_get_saved_termios(int fd);
void __hscore_set_saved_termios(int fd, void* ts);
# 265 "includes/Rts.h" 2
# 1 "includes/rts/Utils.h" 1
# 13 "includes/rts/Utils.h"
       


int genericRaise(int sig);
# 266 "includes/Rts.h" 2
# 1 "includes/rts/PrimFloat.h" 1
# 12 "includes/rts/PrimFloat.h"
       

StgDouble __int_encodeDouble (I_ j, I_ e);
StgFloat __int_encodeFloat (I_ j, I_ e);
StgDouble __word_encodeDouble (W_ j, I_ e);
StgFloat __word_encodeFloat (W_ j, I_ e);
# 267 "includes/Rts.h" 2
# 1 "includes/rts/Main.h" 1
# 9 "includes/rts/Main.h"
       





int hs_main (int argc, char *argv[],
             StgClosure *main_closure,
             RtsConfig rts_config)
   __attribute__((__noreturn__));
# 268 "includes/Rts.h" 2
# 1 "includes/rts/Profiling.h" 1
# 14 "includes/rts/Profiling.h"
       

void registerCcList(CostCentre **cc_list);
void registerCcsList(CostCentreStack **cc_list);
# 269 "includes/Rts.h" 2
# 1 "includes/rts/IPE.h" 1
# 14 "includes/rts/IPE.h"
       


typedef struct InfoProv_{
    char * table_name;
    char * closure_desc;
    char * ty_desc;
    char * label;
    char * module;
    char * srcloc;
} InfoProv;

typedef struct InfoProvEnt_ {
    StgInfoTable * info;
    InfoProv prov;
    struct InfoProvEnt_ *link;
} InfoProvEnt;

extern InfoProvEnt * IPE_LIST;

void registerInfoProvList(InfoProvEnt **cc_list);
InfoProvEnt * lookupIPE(StgInfoTable *info);
# 270 "includes/Rts.h" 2
# 1 "includes/rts/StaticPtrTable.h" 1
# 14 "includes/rts/StaticPtrTable.h"
       
# 28 "includes/rts/StaticPtrTable.h"
void hs_spt_insert (StgWord64 key[2],void* spe_closure);







void hs_spt_insert_stableptr(StgWord64 key[2], StgStablePtr *entry);







void hs_spt_remove (StgWord64 key[2]);
# 271 "includes/Rts.h" 2
# 1 "includes/rts/Libdw.h" 1
# 9 "includes/rts/Libdw.h"
       






#define BACKTRACE_CHUNK_SZ 256
# 50 "includes/rts/Libdw.h"
typedef struct BacktraceChunk_ {
    StgWord n_frames;
    struct BacktraceChunk_ *next;
    StgPtr frames[256];

} __attribute__((packed)) BacktraceChunk;
# 65 "includes/rts/Libdw.h"
typedef struct Backtrace_ {
    StgWord n_frames;
    BacktraceChunk *last;

} Backtrace;


typedef struct Location_ {
    const char *object_file;
    const char *function;


    const char *source_file;
    StgWord32 lineno;
    StgWord32 colno;
} __attribute__((packed)) Location;

struct LibdwSession_;
typedef struct LibdwSession_ LibdwSession;


void backtraceFree(Backtrace *bt);



Backtrace *libdwGetBacktrace(LibdwSession *session);



int libdwLookupLocation(LibdwSession *session, Location *loc, StgPtr pc);


void libdwPrintBacktrace(LibdwSession *session, FILE *file, Backtrace *bt);
# 272 "includes/Rts.h" 2
# 1 "includes/rts/LibdwPool.h" 1
# 9 "includes/rts/LibdwPool.h"
       


LibdwSession *libdwPoolTake(void);


void libdwPoolRelease(LibdwSession *sess);



void libdwPoolClear(void);
# 273 "includes/Rts.h" 2


 extern char **prog_argv;
 extern int prog_argc;
 extern char *prog_name;

void reportStackOverflow(StgTSO* tso);
void reportHeapOverflow(void);

void stg_exit(int n) __attribute__((__noreturn__));


int stg_sig_install (int, int, void *);







int rts_isProfiled(void);


int rts_isDynamic(void);


int rts_isThreaded(void);


int rts_isDebugged(void);


int rts_isTracing(void);






#define EXIT_INTERNAL_ERROR 254
#define EXIT_DEADLOCK 253
#define EXIT_INTERRUPTED 252
#define EXIT_HEAPOVERFLOW 251
#define EXIT_KILLED 250






#define TICK_VAR(arity) extern StgInt SLOW_CALLS_ ##arity; extern StgInt RIGHT_ARITY_ ##arity; extern StgInt TAGGED_PTR_ ##arity;




extern StgInt TOTAL_CALLS;

extern StgInt SLOW_CALLS_1; extern StgInt RIGHT_ARITY_1; extern StgInt TAGGED_PTR_1;
extern StgInt SLOW_CALLS_2; extern StgInt RIGHT_ARITY_2; extern StgInt TAGGED_PTR_2;






#define IF_RTSFLAGS(c,s) if (RtsFlags.c) { s; } doNothing()






#define IF_DEBUG(c,s) if (RtsFlags.DebugFlags.c) { s; } doNothing()






#define DEBUG_ONLY(s) s





#define DEBUG_IS_ON 1
# 368 "includes/Rts.h"
#define SUPPORTS_TYPEOF 



#define stg_min(a,b) ({typeof(a) _a = (a), _b = (b); _a <= _b ? _a : _b; })
#define stg_max(a,b) ({typeof(a) _a = (a), _b = (b); _a <= _b ? _b : _a; })
# 21 "rts/Capability.c" 2

# 1 "rts/Capability.h" 1
# 21 "rts/Capability.h"
       

# 1 "rts/sm/GC.h" 1
# 14 "rts/sm/GC.h"
       

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 17 "rts/sm/GC.h" 2

# 1 "rts/sm/HeapAlloc.h" 1
# 9 "rts/sm/HeapAlloc.h"
       

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 12 "rts/sm/HeapAlloc.h" 2
# 53 "rts/sm/HeapAlloc.h"
struct mblock_address_range {
    W_ begin, end;
    W_ padding[6];
} __attribute__((aligned(64)));
extern struct mblock_address_range mblock_address_space;

#define HEAP_ALLOCED(p) ((W_)(p) >= mblock_address_space.begin && (W_)(p) < (mblock_address_space.end))

#define HEAP_ALLOCED_GC(p) HEAP_ALLOCED(p)
# 224 "rts/sm/HeapAlloc.h"
# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 224 "rts/sm/HeapAlloc.h" 2
# 19 "rts/sm/GC.h" 2

void GarbageCollect (uint32_t collect_gen,
                     
# 21 "rts/sm/GC.h" 3 4
                    _Bool 
# 21 "rts/sm/GC.h"
                         do_heap_census,
                     
# 22 "rts/sm/GC.h" 3 4
                    _Bool 
# 22 "rts/sm/GC.h"
                         is_overflow_gc,
                     
# 23 "rts/sm/GC.h" 3 4
                    _Bool 
# 23 "rts/sm/GC.h"
                         deadlock_detect,
                     uint32_t gc_type,
                     Capability *cap,
                     
# 26 "rts/sm/GC.h" 3 4
                    _Bool 
# 26 "rts/sm/GC.h"
                         idle_cap[]);

typedef void (*evac_fn)(void *user, StgClosure **root);

StgClosure * isAlive ( StgClosure *p );
void markCAFs ( evac_fn evac, void *user );


# 33 "rts/sm/GC.h" 3 4
_Bool 
# 33 "rts/sm/GC.h"
    doIdleGCWork(Capability *cap, 
# 33 "rts/sm/GC.h" 3 4
                                  _Bool 
# 33 "rts/sm/GC.h"
                                       all);

extern uint32_t N;
extern 
# 36 "rts/sm/GC.h" 3 4
      _Bool 
# 36 "rts/sm/GC.h"
           major_gc;

extern 
# 38 "rts/sm/GC.h" 3 4
      _Bool 
# 38 "rts/sm/GC.h"
           deadlock_detect_gc;
extern 
# 39 "rts/sm/GC.h" 3 4
      _Bool 
# 39 "rts/sm/GC.h"
           unload_mark_needed;

extern bdescr *mark_stack_bd;
extern bdescr *mark_stack_top_bd;
extern StgPtr mark_sp;

extern 
# 45 "rts/sm/GC.h" 3 4
      _Bool 
# 45 "rts/sm/GC.h"
           work_stealing;


extern volatile StgWord64 whitehole_gc_spin;
extern volatile StgWord64 waitForGcThreads_spin;
extern volatile StgWord64 waitForGcThreads_yield;




typedef struct {
    StgWord n_MUTVAR;
    StgWord n_MUTARR;
    StgWord n_MVAR;
    StgWord n_TVAR;
    StgWord n_TREC_CHUNK;
    StgWord n_TVAR_WATCH_QUEUE;
    StgWord n_TREC_HEADER;
    StgWord n_OTHERS;
} MutListScavStats;

extern MutListScavStats mutlist_scav_stats;

void zeroMutListScavStats(MutListScavStats *src);
void addMutListScavStats(const MutListScavStats *src,
                         MutListScavStats *dest);


void gcWorkerThread (Capability *cap);
void initGcThreads (uint32_t from, uint32_t to);
void freeGcThreads (void);

void resizeGenerations (void);


void notifyTodoBlock (void);
void waitForGcThreads (Capability *cap, 
# 81 "rts/sm/GC.h" 3 4
                                       _Bool 
# 81 "rts/sm/GC.h"
                                            idle_cap[]);
void releaseGCThreads (Capability *cap, 
# 82 "rts/sm/GC.h" 3 4
                                       _Bool 
# 82 "rts/sm/GC.h"
                                            idle_cap[]);


#define WORK_UNIT_WORDS 128

# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 87 "rts/sm/GC.h" 2
# 24 "rts/Capability.h" 2
# 1 "rts/Task.h" 1
# 12 "rts/Task.h"
       

# 1 "rts/GetTime.h" 1
# 9 "rts/GetTime.h"
       

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 12 "rts/GetTime.h" 2

void initializeTimer (void);

Time getProcessCPUTime (void);
Time getCurrentThreadCPUTime (void);
void getProcessTimes (Time *user, Time *elapsed);




void getUnixEpochTime (StgWord64 *sec, StgWord32 *nsec);


W_ getPageFaults (void);

# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 27 "rts/GetTime.h" 2
# 15 "rts/Task.h" 2

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 17 "rts/Task.h" 2
# 84 "rts/Task.h"
typedef struct InCall_ {
    StgTSO * tso;

    StgTSO * suspended_tso;


    Capability *suspended_cap;





    SchedulerStatus rstat;
    StgClosure ** ret;

    struct Task_ *task;






    struct InCall_ *prev_stack;


    struct InCall_ *prev;
    struct InCall_ *next;
} InCall;

typedef struct Task_ {

    OSThreadId id;





    uint32_t node;

    Condition cond;
    Mutex lock;





    
# 130 "rts/Task.h" 3 4
   _Bool 
# 130 "rts/Task.h"
        wakeup;
# 143 "rts/Task.h"
    struct Capability_ *cap;


    struct InCall_ *incall;

    uint32_t n_spare_incalls;
    struct InCall_ *spare_incalls;

    
# 151 "rts/Task.h" 3 4
   _Bool 
# 151 "rts/Task.h"
           worker;
    
# 152 "rts/Task.h" 3 4
   _Bool 
# 152 "rts/Task.h"
           stopped;



    
# 156 "rts/Task.h" 3 4
   _Bool 
# 156 "rts/Task.h"
        running_finalizers;


    int preferred_capability;



    struct Task_ *next;


    struct Task_ *all_next;
    struct Task_ *all_prev;

} Task;

static inline 
# 171 "rts/Task.h" 3 4
             _Bool

# 172 "rts/Task.h"
isBoundTask (Task *task)
{
    return (task->incall->tso != 
# 174 "rts/Task.h" 3 4
                                ((void *)0)
# 174 "rts/Task.h"
                                    );
}






static inline 
# 182 "rts/Task.h" 3 4
             _Bool

# 183 "rts/Task.h"
isWorker (Task *task)
{
    return (task->worker && task->incall->prev_stack == 
# 185 "rts/Task.h" 3 4
                                                       ((void *)0)
# 185 "rts/Task.h"
                                                           );
}



extern Task *all_tasks;



extern Mutex all_tasks_mutex;





void initTaskManager (void);
uint32_t freeTaskManager (void);






Task* newBoundTask (void);




Task* getMyTask (void);


void exitMyTask (void);






void freeMyTask(void);







void workerTaskStop (Task *task);





void discardTasksExcept (Task *keep);



static inline Task *myTask (void);
# 250 "rts/Task.h"
void startWorkerTask (Capability *cap);




void interruptWorkerTask (Task *task);




extern uint32_t taskCount;
extern uint32_t workerCount;
extern uint32_t peakWorkerCount;
# 274 "rts/Task.h"
#define MYTASK_USE_TLV 
extern __thread Task *my_task;
# 289 "rts/Task.h"
static inline Task *
myTask (void)
{



    return my_task;

}

static inline void
setMyTask (Task *task)
{



    my_task = task;

}



typedef StgWord64 TaskId;
# 322 "rts/Task.h"
static inline TaskId serialiseTaskId (OSThreadId taskID) {






    return (TaskId) taskID;

}





static inline TaskId
serialisableTaskId (Task *task)
{

    return serialiseTaskId(task->id);



}

# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 347 "rts/Task.h" 2
# 25 "rts/Capability.h" 2
# 1 "rts/Sparks.h" 1
# 9 "rts/Sparks.h"
       

# 1 "rts/WSDeque.h" 1
# 9 "rts/WSDeque.h"
       

typedef struct WSDeque_ {


    StgInt size;
    StgWord moduloSize;


    StgInt top;



    StgInt bottom;





    void ** elements;





} WSDeque;
# 43 "rts/WSDeque.h"
#define ASSERT_WSDEQUE_INVARIANTS(p) ASSERT((p)->size > 0); ASSERT(RELAXED_LOAD(&(p)->elements) != NULL); ASSERT(RELAXED_LOAD(&(p)->elements[0]) || 1); ASSERT(RELAXED_LOAD(&(p)->elements[(p)->size - 1]) || 1);
# 63 "rts/WSDeque.h"
WSDeque * newWSDeque (uint32_t size);
void freeWSDeque (WSDeque *q);



void* popWSDeque (WSDeque *q);




# 72 "rts/WSDeque.h" 3 4
_Bool 
# 72 "rts/WSDeque.h"
    pushWSDeque (WSDeque *q, void *elem);


inline void discardElements (WSDeque *q);




void * stealWSDeque_ (WSDeque *q);



void * stealWSDeque (WSDeque *q);




inline 
# 89 "rts/WSDeque.h" 3 4
             _Bool 
# 89 "rts/WSDeque.h"
                  looksEmptyWSDeque (WSDeque* q);




inline StgInt dequeElements (WSDeque *q);





inline StgInt
dequeElements (WSDeque *q)
{
    StgWord t = __atomic_load_n(&q->top, 2);
    StgWord b = __atomic_load_n(&q->bottom, 2);

    StgInt n = (StgInt)b - (StgInt)t;
    return n > 0 ? n : 0;
}

inline 
# 110 "rts/WSDeque.h" 3 4
             _Bool

# 111 "rts/WSDeque.h"
looksEmptyWSDeque (WSDeque *q)
{
    return (dequeElements(q) <= 0);
}

inline void
discardElements (WSDeque *q)
{
    __atomic_store_n(&q->top, __atomic_load_n(&q->bottom, 0), 0);
}
# 12 "rts/Sparks.h" 2

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 14 "rts/Sparks.h" 2




typedef struct {
    StgWord created;
    StgWord dud;
    StgWord overflowed;
    StgWord converted;
    StgWord gcd;
    StgWord fizzled;
} SparkCounters;



typedef WSDeque SparkPool;


SparkPool *allocSparkPool (void);



static inline StgClosure* reclaimSpark(SparkPool *pool);



static inline 
# 40 "rts/Sparks.h" 3 4
             _Bool 
# 40 "rts/Sparks.h"
                  looksEmpty(SparkPool* deque);

static inline StgClosure * tryStealSpark (SparkPool *pool);
static inline 
# 43 "rts/Sparks.h" 3 4
             _Bool 
# 43 "rts/Sparks.h"
                          fizzledSpark (StgClosure *);

void freeSparkPool (SparkPool *pool);
void createSparkThread (Capability *cap);
void traverseSparkQueue(evac_fn evac, void *user, Capability *cap);
void pruneSparkQueue (
# 48 "rts/Sparks.h" 3 4
                               _Bool 
# 48 "rts/Sparks.h"
                                    nonmovingMarkFinished, Capability *cap);

static inline void discardSparks (SparkPool *pool);
static inline long sparkPoolSize (SparkPool *pool);





static inline StgClosure* reclaimSpark(SparkPool *pool)
{
    return popWSDeque(pool);
}

static inline 
# 62 "rts/Sparks.h" 3 4
             _Bool 
# 62 "rts/Sparks.h"
                  looksEmpty(SparkPool* deque)
{
    return looksEmptyWSDeque(deque);
}

static inline long sparkPoolSize (SparkPool *pool)
{
    return dequeElements(pool);
}

static inline void discardSparks (SparkPool *pool)
{
    discardElements(pool);
}
# 90 "rts/Sparks.h"
static inline StgClosure * tryStealSpark (SparkPool *pool)
{
    return stealWSDeque_(pool);



}

static inline 
# 98 "rts/Sparks.h" 3 4
             _Bool 
# 98 "rts/Sparks.h"
                  fizzledSpark (StgClosure *spark)
{
    return (GET_CLOSURE_TAG(spark) != 0 || !(!((closure_flags[get_itbl (UNTAG_CONST_CLOSURE(spark))->type]) & (1<<2))));
}



# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 105 "rts/Sparks.h" 2
# 26 "rts/Capability.h" 2
# 1 "rts/sm/NonMovingMark.h" 1
# 9 "rts/sm/NonMovingMark.h"
       


# 1 "rts/sm/NonMoving.h" 1
# 9 "rts/sm/NonMoving.h"
       



# 1 "/usr/include/string.h" 1 3 4
# 23 "/usr/include/string.h" 3 4
#define _STRING_H 1






#define __need_size_t 
#define __need_NULL 
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 161 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_size_t
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef __need_wchar_t
# 401 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 33 "/usr/include/string.h" 2 3 4










# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 92 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 106 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 117 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 162 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));




#define strdupa(s) (__extension__ ({ const char *__old = (s); size_t __len = strlen (__old) + 1; char *__new = (char *) __builtin_alloca (__len); (char *) memcpy (__new, __old, __len); }))
# 195 "/usr/include/string.h" 3 4
#define strndupa(s,n) (__extension__ ({ const char *__old = (s); size_t __len = strnlen (__old, (n)); char *__new = (char *) __builtin_alloca (__len + 1); __new[__len] = '\0'; (char *) memcpy (__new, __old, __len); }))
# 206 "/usr/include/string.h" 3 4

# 231 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 258 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 272 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 310 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 337 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 368 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 433 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 484 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 512 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 599 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 658 "/usr/include/string.h" 3 4

# 14 "rts/sm/NonMoving.h" 2



# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 18 "rts/sm/NonMoving.h" 2


#define NONMOVING_SEGMENT_BITS 15

#define NONMOVING_SEGMENT_MASK ((1 << NONMOVING_SEGMENT_BITS) - 1)

#define NONMOVING_SEGMENT_SIZE (1 << NONMOVING_SEGMENT_BITS)

#define NONMOVING_SEGMENT_SIZE_W ((1 << NONMOVING_SEGMENT_BITS) / SIZEOF_VOID_P)

#define NONMOVING_SEGMENT_BLOCKS (NONMOVING_SEGMENT_SIZE / BLOCK_SIZE)


# 30 "rts/sm/NonMoving.h"
_Static_assert((1 << 15) % (1UL<<12) == 0,
               "non-moving segment size must be multiple of block size");


typedef uint16_t nonmoving_block_idx;


#define TRACK_SEGMENT_STATE 






enum NonmovingSegmentState {
    FREE, CURRENT, ACTIVE, FILLED, FILLED_SWEEPING
};

#define SET_SEGMENT_STATE(seg,st) (seg)->state = (st)





struct NonmovingSegment {
    struct NonmovingSegment *link;
    struct NonmovingSegment *todo_link;
    nonmoving_block_idx next_free;

    enum NonmovingSegmentState state;

    uint8_t bitmap[];
# 76 "rts/sm/NonMoving.h"
};



#define END_NONMOVING_TODO_LIST ((struct NonmovingSegment*)1)


struct NonmovingAllocator {
    struct NonmovingSegment *filled;
    struct NonmovingSegment *saved_filled;
    struct NonmovingSegment *active;

};


#define NONMOVING_ALLOCA0 3



#define NONMOVING_ALLOCA_CNT 12


#define NONMOVING_MAX_FREE 16

struct NonmovingHeap {
    struct NonmovingAllocator allocators[12];




    struct NonmovingSegment *free;

    unsigned int n_free;


    unsigned int n_caps;





    struct NonmovingSegment *sweep_list;
};

extern struct NonmovingHeap nonmovingHeap;

extern memcount nonmoving_live_words;


extern 
# 125 "rts/sm/NonMoving.h" 3 4
      _Bool 
# 125 "rts/sm/NonMoving.h"
           concurrent_coll_running;


void nonmovingInit(void);
void nonmovingStop(void);
void nonmovingExit(void);
# 147 "rts/sm/NonMoving.h"
void nonmovingCollect(StgWeak **dead_weaks,
                       StgTSO **resurrected_threads);

void *nonmovingAllocate(Capability *cap, StgWord sz);
void nonmovingInitCapability(Capability *cap);
void nonmovingPushFreeSegment(struct NonmovingSegment *seg);
void nonmovingClearBitmap(struct NonmovingSegment *seg);


static inline struct NonmovingSegmentInfo *nonmovingSegmentInfo(struct NonmovingSegment *seg) {
    return &Bdescr((StgPtr) seg)->nonmoving_segment;
}

static inline uint8_t nonmovingSegmentLogBlockSize(struct NonmovingSegment *seg) {
    return nonmovingSegmentInfo(seg)->log_block_size;
}


static inline void nonmovingPushActiveSegment(struct NonmovingSegment *seg)
{
    struct NonmovingAllocator *alloc =
        &nonmovingHeap.allocators[nonmovingSegmentLogBlockSize(seg) - 3];
    (seg)->state = (ACTIVE);
    while (
# 170 "rts/sm/NonMoving.h" 3 4
          1
# 170 "rts/sm/NonMoving.h"
              ) {
        struct NonmovingSegment *current_active = (struct NonmovingSegment*)(*((StgVolatilePtr)(&alloc->active)));
        seg->link = current_active;
        if (cas((StgVolatilePtr) &alloc->active, (StgWord) current_active, (StgWord) seg) == (StgWord) current_active) {
            break;
        }
    }
}


static inline void nonmovingPushFilledSegment(struct NonmovingSegment *seg)
{
    struct NonmovingAllocator *alloc =
        &nonmovingHeap.allocators[nonmovingSegmentLogBlockSize(seg) - 3];
    (seg)->state = (FILLED);
    while (
# 185 "rts/sm/NonMoving.h" 3 4
          1
# 185 "rts/sm/NonMoving.h"
              ) {
        struct NonmovingSegment *current_filled = (struct NonmovingSegment*)(*((StgVolatilePtr)(&alloc->filled)));
        seg->link = current_filled;
        if (cas((StgVolatilePtr) &alloc->filled, (StgWord) current_filled, (StgWord) seg) == (StgWord) current_filled) {
            break;
        }
    }
}







void assert_in_nonmoving_heap(StgPtr p);


static inline unsigned int nonmovingSegmentBlockSize(struct NonmovingSegment *seg)
{
    return 1 << nonmovingSegmentLogBlockSize(seg);
}


static inline unsigned int nonmovingBlockCount(uint8_t log_block_size)
{
  unsigned int segment_data_size = (1 << 15) - sizeof(struct NonmovingSegment);
  segment_data_size -= segment_data_size % 8;
  unsigned int blk_size = 1 << log_block_size;

  return segment_data_size / (blk_size + 1);
}

unsigned int nonmovingBlockCountFromSize(uint8_t log_block_size);


static inline unsigned int nonmovingSegmentBlockCount(struct NonmovingSegment *seg)
{
  return nonmovingBlockCountFromSize(nonmovingSegmentLogBlockSize(seg));
}




static inline void *nonmovingSegmentGetBlock_(struct NonmovingSegment *seg, uint8_t log_block_size, nonmoving_block_idx i)
{
  if (__builtin_expect(!!(log_block_size == nonmovingSegmentLogBlockSize(seg)), 1)) ; else _assertFail("rts/sm/NonMoving.h", 231);

  unsigned int blk_size = 1 << log_block_size;

  W_ bitmap_size = nonmovingBlockCountFromSize(log_block_size) * sizeof(uint8_t);




  W_ data = (((((W_)seg) + sizeof(struct NonmovingSegment) + bitmap_size) + sizeof(W_) - 1) / sizeof(W_)) * sizeof(W_);
  return (void*)(data + i*blk_size);
}


static inline void *nonmovingSegmentGetBlock(struct NonmovingSegment *seg, nonmoving_block_idx i)
{
  return nonmovingSegmentGetBlock_(seg, nonmovingSegmentLogBlockSize(seg), i);
}



static inline struct NonmovingSegment *nonmovingGetSegment_unchecked(StgPtr p)
{
    const uintptr_t mask = ~((1 << 15) - 1);
    return (struct NonmovingSegment *) (((uintptr_t) p) & mask);
}

static inline struct NonmovingSegment *nonmovingGetSegment(StgPtr p)
{
    if (__builtin_expect(!!(((W_)(p) >= mblock_address_space.begin && (W_)(p) < (mblock_address_space.end)) && (Bdescr(p)->flags & 1024)), 1)) ; else _assertFail("rts/sm/NonMoving.h", 260);
    return nonmovingGetSegment_unchecked(p);
}

static inline nonmoving_block_idx nonmovingGetBlockIdx(StgPtr p)
{
    if (__builtin_expect(!!(((W_)(p) >= mblock_address_space.begin && (W_)(p) < (mblock_address_space.end)) && (Bdescr(p)->flags & 1024)), 1)) ; else _assertFail("rts/sm/NonMoving.h", 266);
    struct NonmovingSegment *seg = nonmovingGetSegment(p);
    ptrdiff_t blk0 = (ptrdiff_t)nonmovingSegmentGetBlock(seg, 0);
    ptrdiff_t offset = (ptrdiff_t)p - blk0;
    return (nonmoving_block_idx) (offset >> nonmovingSegmentLogBlockSize(seg));
}


extern uint8_t nonmovingMarkEpoch;

static inline void nonmovingSetMark(struct NonmovingSegment *seg, nonmoving_block_idx i)
{
    seg->bitmap[i] = nonmovingMarkEpoch;
}

static inline uint8_t nonmovingGetMark(struct NonmovingSegment *seg, nonmoving_block_idx i)
{
    return seg->bitmap[i];
}

static inline void nonmovingSetClosureMark(StgPtr p)
{
    nonmovingSetMark(nonmovingGetSegment(p), nonmovingGetBlockIdx(p));
}

static inline uint8_t nonmovingGetClosureMark(StgPtr p)
{
    struct NonmovingSegment *seg = nonmovingGetSegment(p);
    nonmoving_block_idx blk_idx = nonmovingGetBlockIdx(p);
    return nonmovingGetMark(seg, blk_idx);
}


static inline 
# 299 "rts/sm/NonMoving.h" 3 4
             _Bool 
# 299 "rts/sm/NonMoving.h"
                  nonmovingClosureMarkedThisCycle(StgPtr p)
{
    return nonmovingGetClosureMark(p) == nonmovingMarkEpoch;
}



static inline 
# 306 "rts/sm/NonMoving.h" 3 4
             _Bool 
# 306 "rts/sm/NonMoving.h"
                  nonmovingSegmentBeingSwept(struct NonmovingSegment *seg)
{
    struct NonmovingSegmentInfo *seginfo = nonmovingSegmentInfo(seg);
    unsigned int n = nonmovingBlockCountFromSize(seginfo->log_block_size);
    return seginfo->next_free_snap >= n;
}




static inline 
# 316 "rts/sm/NonMoving.h" 3 4
             _Bool 
# 316 "rts/sm/NonMoving.h"
                  nonmovingClosureBeingSwept(StgClosure *p)
{
    bdescr *bd = Bdescr((StgPtr) p);
    if (((W_)(p) >= mblock_address_space.begin && (W_)(p) < (mblock_address_space.end))) {
        if (bd->flags & 2048) {
            return 
# 321 "rts/sm/NonMoving.h" 3 4
                  1
# 321 "rts/sm/NonMoving.h"
                      ;
        } else if (bd->flags & 1024) {
            struct NonmovingSegment *seg = nonmovingGetSegment((StgPtr) p);
            return nonmovingSegmentBeingSwept(seg);
        } else {

            return 
# 327 "rts/sm/NonMoving.h" 3 4
                  0
# 327 "rts/sm/NonMoving.h"
                       ;
        }
    } else {

        return 
# 331 "rts/sm/NonMoving.h" 3 4
              1
# 331 "rts/sm/NonMoving.h"
                  ;
    }
}




static inline 
# 338 "rts/sm/NonMoving.h" 3 4
             _Bool 
# 338 "rts/sm/NonMoving.h"
                  isNonmovingClosure(StgClosure *p)
{
    return RtsFlags.GcFlags.useNonmoving && (!((W_)(p) >= mblock_address_space.begin && (W_)(p) < (mblock_address_space.end)) || Bdescr((P_)p)->flags & 1024);
}




void nonmovingPrintSegment(struct NonmovingSegment *seg);
void nonmovingPrintAllocator(struct NonmovingAllocator *alloc);
void locate_object(P_ obj);
void nonmovingPrintSweepList(void);

void check_in_mut_list(StgClosure *p);
void print_block_list(bdescr *bd);
void print_thread_list(StgTSO* tso);



# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 358 "rts/sm/NonMoving.h" 2
# 13 "rts/sm/NonMovingMark.h" 2

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 15 "rts/sm/NonMovingMark.h" 2

enum EntryType {
    NULL_ENTRY = 0,
    MARK_CLOSURE = 1,
    MARK_ARRAY = 2
};
# 42 "rts/sm/NonMovingMark.h"
typedef struct {


    union {

        struct {
            void *p;
        } null_entry;
        struct {
            StgClosure *p;
            StgClosure **origin;

        } mark_closure;
        struct {
            const StgMutArrPtrs *array;
            StgWord start_index;
        } mark_array;
    };
} MarkQueueEnt;

static inline enum EntryType nonmovingMarkQueueEntryType(MarkQueueEnt *ent)
{
    uintptr_t tag = (uintptr_t) ent->null_entry.p & ((1 << 3) - 1);
    if (__builtin_expect(!!(tag <= MARK_ARRAY), 1)) ; else _assertFail("rts/sm/NonMovingMark.h", 65);
    return tag;
}

typedef struct {

    uint32_t head;

    MarkQueueEnt entries[];
} MarkQueueBlock;


#define MARK_PREFETCH_QUEUE_DEPTH 5
# 87 "rts/sm/NonMovingMark.h"
typedef struct MarkQueue_ {

    bdescr *blocks;


    MarkQueueBlock *top;


    
# 95 "rts/sm/NonMovingMark.h" 3 4
   _Bool 
# 95 "rts/sm/NonMovingMark.h"
        is_upd_rem_set;



    MarkQueueEnt prefetch_queue[5];

    uint8_t prefetch_head;

} MarkQueue;






typedef struct {
    MarkQueue queue;
} UpdRemSet;



typedef int64_t MarkBudget;
#define UNLIMITED_MARK_BUDGET INT64_MIN


#define MARK_QUEUE_BLOCKS 16


#define MARK_QUEUE_BLOCK_ENTRIES ((MARK_QUEUE_BLOCKS * BLOCK_SIZE - sizeof(MarkQueueBlock)) / sizeof(MarkQueueEnt))

extern bdescr *nonmoving_large_objects, *nonmoving_marked_large_objects,
              *nonmoving_compact_objects, *nonmoving_marked_compact_objects;
extern memcount n_nonmoving_large_blocks, n_nonmoving_marked_large_blocks,
                n_nonmoving_compact_blocks, n_nonmoving_marked_compact_blocks;

extern StgTSO *nonmoving_old_threads;
extern StgWeak *nonmoving_old_weak_ptr_list;
extern StgTSO *nonmoving_threads;
extern StgWeak *nonmoving_weak_ptr_list;


extern StgIndStatic *debug_caf_list_snapshot;


extern MarkQueue *current_mark_queue;
extern bdescr *upd_rem_set_block_list;


void nonmovingMarkInit(void);

void nonmovingInitUpdRemSet(UpdRemSet *rset);
void updateRemembSetPushClosure(Capability *cap, StgClosure *p);
void updateRemembSetPushThunk(Capability *cap, StgThunk *p);
void updateRemembSetPushTSO(Capability *cap, StgTSO *tso);
void updateRemembSetPushStack(Capability *cap, StgStack *stack);


void nonmovingFlushCapUpdRemSetBlocks(Capability *cap);
void nonmovingBeginFlush(Task *task);

# 154 "rts/sm/NonMovingMark.h" 3 4
_Bool 
# 154 "rts/sm/NonMovingMark.h"
    nonmovingWaitForFlush(void);
void nonmovingFinishFlush(Task *task);


void markQueueAddRoot(MarkQueue* q, StgClosure** root);

void initMarkQueue(MarkQueue *queue);
void freeMarkQueue(MarkQueue *queue);
void nonmovingMark(MarkBudget *budget, struct MarkQueue_ *restrict queue);
static inline void nonmovingMarkUnlimitedBudget(struct MarkQueue_ *restrict queue) {
    MarkBudget budget = 
# 164 "rts/sm/NonMovingMark.h" 3 4
                       (-9223372036854775807L -1)
# 164 "rts/sm/NonMovingMark.h"
                                            ;
    nonmovingMark(&budget, queue);
}

void nonmovingMarkWeakPtrList(struct MarkQueue_ *queue);

# 169 "rts/sm/NonMovingMark.h" 3 4
_Bool 
# 169 "rts/sm/NonMovingMark.h"
    nonmovingTidyWeaks(struct MarkQueue_ *queue);
void nonmovingTidyThreads(void);
void nonmovingMarkDeadWeaks(struct MarkQueue_ *queue, StgWeak **dead_weak_ptr_list);
void nonmovingResurrectThreads(struct MarkQueue_ *queue, StgTSO **resurrected_threads);

# 173 "rts/sm/NonMovingMark.h" 3 4
_Bool 
# 173 "rts/sm/NonMovingMark.h"
    nonmovingIsAlive(StgClosure *p);
void nonmovingMarkDeadWeak(struct MarkQueue_ *queue, StgWeak *w);
void nonmovingMarkLiveWeak(struct MarkQueue_ *queue, StgWeak *w);
void nonmovingAddUpdRemSetBlocks(UpdRemSet *rset);

void markQueuePush(MarkQueue *q, const MarkQueueEnt *ent);
void markQueuePushClosureGC(MarkQueue *q, StgClosure *p);
void markQueuePushClosure(MarkQueue *q,
                             StgClosure *p,
                             StgClosure **origin);
void markQueuePushClosure_(MarkQueue *q, StgClosure *p);
void markQueuePushThunkSrt(MarkQueue *q, const StgInfoTable *info);
void markQueuePushFunSrt(MarkQueue *q, const StgInfoTable *info);
void markQueuePushArray(MarkQueue *q, const StgMutArrPtrs *array, StgWord start_index);
void updateRemembSetPushThunkEager(Capability *cap,
                                  const StgThunkInfoTable *orig_info,
                                  StgThunk *thunk);

static inline 
# 191 "rts/sm/NonMovingMark.h" 3 4
             _Bool 
# 191 "rts/sm/NonMovingMark.h"
                  markQueueIsEmpty(MarkQueue *q)
{
    return (q->blocks == 
# 193 "rts/sm/NonMovingMark.h" 3 4
                        ((void *)0)
# 193 "rts/sm/NonMovingMark.h"
                            ) || (q->top->head == 0 && q->blocks->link == 
# 193 "rts/sm/NonMovingMark.h" 3 4
                                                                          ((void *)0)
# 193 "rts/sm/NonMovingMark.h"
                                                                              );
}



void printMarkQueueEntry(MarkQueueEnt *ent);
void printMarkQueue(MarkQueue *q);



# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 203 "rts/sm/NonMovingMark.h" 2
# 27 "rts/Capability.h" 2

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 29 "rts/Capability.h" 2
# 38 "rts/Capability.h"
#define CAPABILITY_ALIGNMENT 64



struct Capability_ {



    StgFunTable f;
    StgRegTable r;

    uint32_t no;
# 58 "rts/Capability.h"
    uint32_t node;





    Task *running_task;



    
# 68 "rts/Capability.h" 3 4
   _Bool 
# 68 "rts/Capability.h"
        in_haskell;


    uint32_t idle;

    
# 73 "rts/Capability.h" 3 4
   _Bool 
# 73 "rts/Capability.h"
        disabled;





    StgTSO *run_queue_hd;
    StgTSO *run_queue_tl;
    uint32_t n_run_queue;







    InCall *suspended_ccalls;
    uint32_t n_suspended_ccalls;






    bdescr **mut_lists;
    bdescr **saved_mut_lists;


    UpdRemSet upd_rem_set;


    struct NonmovingSegment **current_segments;


    bdescr *pinned_object_block;

    bdescr *pinned_object_blocks;

    bdescr *pinned_object_empty;



    StgWeak *weak_ptr_list_hd;
    StgWeak *weak_ptr_list_tl;





    int context_switch;
# 134 "rts/Capability.h"
    int interrupt;



    uint64_t total_allocated;



    Task *spare_workers;
    uint32_t n_spare_workers;







    Mutex lock;






    Task *returning_tasks_hd;
    Task *returning_tasks_tl;
    uint32_t n_returning_tasks;



    Message *inbox;



    struct PutMVar_ *putMVars;

    SparkPool *sparks;


    SparkCounters spark_stats;


    int io_manager_control_wr_fd;




    StgTVarWatchQueue *free_tvar_watch_queues;
    StgTRecChunk *free_trec_chunks;
    StgTRecHeader *free_trec_headers;
    uint32_t transaction_tokens;
}
  __attribute__((aligned(64)))
;



_Static_assert((sizeof(struct Capability_) % 64 == 0), "Capability size does not match cache size");


#define ASSERT_TASK_ID(task) ASSERT(task->id == osThreadId())





#define ASSERT_FULL_CAPABILITY_INVARIANTS(_cap,_task) ASSERT(_cap->running_task != NULL && _cap->running_task == _task); ASSERT(_task->cap == _cap); ASSERT_PARTIAL_CAPABILITY_INVARIANTS(_cap,_task)







#define ASSERT_RETURNING_TASKS(cap,task) ASSERT(cap->returning_tasks_hd == NULL ? cap->returning_tasks_tl == NULL && cap->n_returning_tasks == 0 : 1);
# 221 "rts/Capability.h"
#define ASSERT_PARTIAL_CAPABILITY_INVARIANTS(cap,task) ASSERT(cap->run_queue_hd == END_TSO_QUEUE ? cap->run_queue_tl == END_TSO_QUEUE && cap->n_run_queue == 0 : 1); ASSERT(cap->suspended_ccalls == NULL ? cap->n_suspended_ccalls == 0 : 1); ASSERT(myTask() == task); ASSERT_TASK_ID(task);
# 230 "rts/Capability.h"

# 230 "rts/Capability.h" 3 4
_Bool 
# 230 "rts/Capability.h"
    checkSparkCountInvariant (void);




static inline Capability *
regTableToCapability (StgRegTable *reg)
{
    return (Capability *)((void *)((unsigned char*)reg - ((StgWord)&(((Capability*)0)->r))));
}



void initCapabilities (void);



void moreCapabilities (uint32_t from, uint32_t to);
# 256 "rts/Capability.h"
void releaseCapability (Capability* cap);
void releaseAndWakeupCapability (Capability* cap);
void releaseCapability_ (Capability* cap, 
# 258 "rts/Capability.h" 3 4
                                         _Bool 
# 258 "rts/Capability.h"
                                              always_wakeup);
# 276 "rts/Capability.h"
extern Capability **capabilities;




typedef enum {
    SYNC_OTHER,
    SYNC_GC_SEQ,
    SYNC_GC_PAR,
    SYNC_FLUSH_UPD_REM_SET,
    SYNC_FLUSH_EVENT_LOG
} SyncType;




typedef struct {
    SyncType type;
    
# 294 "rts/Capability.h" 3 4
   _Bool 
# 294 "rts/Capability.h"
        *idle;



    Task *task;
} PendingSync;






extern PendingSync * volatile pending_sync;
# 317 "rts/Capability.h"
void waitForCapability (Capability **cap , Task *task);

inline void recordMutableCap (const StgClosure *p, Capability *cap,
                                        uint32_t gen);

inline void recordClosureMutated (Capability *cap, StgClosure *p);
# 337 "rts/Capability.h"

# 337 "rts/Capability.h" 3 4
_Bool 
# 337 "rts/Capability.h"
    yieldCapability (Capability** pCap, Task *task, 
# 337 "rts/Capability.h" 3 4
                                                    _Bool 
# 337 "rts/Capability.h"
                                                         gcAllowed);




void prodOneCapability (void);
void prodCapability (Capability *cap, Task *task);



void prodAllCapabilities (void);




# 351 "rts/Capability.h" 3 4
_Bool 
# 351 "rts/Capability.h"
    tryGrabCapability (Capability *cap, Task *task);



StgClosure *findSpark (Capability *cap);




# 359 "rts/Capability.h" 3 4
_Bool 
# 359 "rts/Capability.h"
    anySparks (void);

static inline 
# 361 "rts/Capability.h" 3 4
             _Bool 
# 361 "rts/Capability.h"
                  emptySparkPoolCap (Capability *cap);
static inline uint32_t sparkPoolSizeCap (Capability *cap);
static inline void discardSparksCap (Capability *cap);
# 376 "rts/Capability.h"
void shutdownCapabilities(Task *task, 
# 376 "rts/Capability.h" 3 4
                                     _Bool 
# 376 "rts/Capability.h"
                                          wait_foreign);


void contextSwitchAllCapabilities(void);
static inline void contextSwitchCapability(Capability *cap);



void interruptAllCapabilities(void);
static inline void interruptCapability(Capability *cap);


void freeCapabilities (void);


void markCapability (evac_fn evac, void *user, Capability *cap,
                     
# 392 "rts/Capability.h" 3 4
                    _Bool 
# 392 "rts/Capability.h"
                         no_mark_sparks );

void markCapabilities (evac_fn evac, void *user);

void traverseSparkQueues (evac_fn evac, void *user);






extern uint32_t n_numa_nodes;


extern uint32_t numa_map[16];

#define capNoToNumaNode(n) ((n) % n_numa_nodes)





typedef struct PutMVar_ {
    StgStablePtr mvar;
    struct PutMVar_ *link;
} PutMVar;



static inline 
# 421 "rts/Capability.h" 3 4
             _Bool 
# 421 "rts/Capability.h"
                  emptyInbox(Capability *cap);







inline void
recordMutableCap (const StgClosure *p, Capability *cap, uint32_t gen)
{
    bdescr *bd;




    bd = cap->mut_lists[gen];
    if (__atomic_load_n(&bd->free, 0) >= bd->start + ((1UL<<12)/sizeof(W_))) {
        bdescr *new_bd;
        new_bd = allocBlockOnNode_lock(cap->node);
        new_bd->link = bd;
        new_bd->free = new_bd->start;
        bd = new_bd;
        cap->mut_lists[gen] = bd;
    }
    __atomic_store_n(bd->free, (StgWord) p, 0);
    __atomic_store_n(&bd->free, __atomic_load_n(&bd->free, 0) + 1, 0);
}

inline void
recordClosureMutated (Capability *cap, StgClosure *p)
{
    bdescr *bd;
    bd = Bdescr((StgPtr)p);
    if (bd->gen_no != 0) recordMutableCap(p,cap,bd->gen_no);
}



static inline 
# 460 "rts/Capability.h" 3 4
             _Bool

# 461 "rts/Capability.h"
emptySparkPoolCap (Capability *cap)
{ return looksEmpty(cap->sparks); }

static inline uint32_t
sparkPoolSizeCap (Capability *cap)
{ return sparkPoolSize(cap->sparks); }

static inline void
discardSparksCap (Capability *cap)
{ discardSparks(cap->sparks); }


static inline void
stopCapability (Capability *cap)
{





    ;
    __atomic_store_n(&cap->r.rHpLim, 
# 482 "rts/Capability.h" 3 4
   ((void *)0)
# 482 "rts/Capability.h"
   , 5);
}

static inline void
interruptCapability (Capability *cap)
{
    stopCapability(cap);
    __atomic_store_n(&cap->interrupt, 
# 489 "rts/Capability.h" 3 4
   1
# 489 "rts/Capability.h"
   , 5);
}

static inline void
contextSwitchCapability (Capability *cap)
{
    stopCapability(cap);
    __atomic_store_n(&cap->context_switch, 
# 496 "rts/Capability.h" 3 4
   1
# 496 "rts/Capability.h"
   , 5);
}



static inline 
# 501 "rts/Capability.h" 3 4
             _Bool 
# 501 "rts/Capability.h"
                  emptyInbox(Capability *cap)
{


    ;
    return (__atomic_load_n(&cap->inbox, 0) == (Message*)((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure) &&
            __atomic_load_n(&cap->putMVars, 0) == 
# 507 "rts/Capability.h" 3 4
                                           ((void *)0)
# 507 "rts/Capability.h"
                                               );
}



# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 512 "rts/Capability.h" 2
# 23 "rts/Capability.c" 2
# 1 "rts/Schedule.h" 1
# 10 "rts/Schedule.h"
       



# 1 "rts/Trace.h" 1
# 9 "rts/Trace.h"
       

# 1 "rts/eventlog/EventLog.h" 1
# 9 "rts/eventlog/EventLog.h"
       

# 1 "includes/rts/EventLogFormat.h" 1
# 36 "includes/rts/EventLogFormat.h"
       




#define EVENT_HEADER_BEGIN 0x68647262
#define EVENT_HEADER_END 0x68647265

#define EVENT_DATA_BEGIN 0x64617462
#define EVENT_DATA_END 0xffff






#define EVENT_HET_BEGIN 0x68657462
#define EVENT_HET_END 0x68657465

#define EVENT_ET_BEGIN 0x65746200
#define EVENT_ET_END 0x65746500




#define EVENT_CREATE_THREAD 0
#define EVENT_RUN_THREAD 1
#define EVENT_STOP_THREAD 2
#define EVENT_THREAD_RUNNABLE 3
#define EVENT_MIGRATE_THREAD 4

#define EVENT_THREAD_WAKEUP 8
#define EVENT_GC_START 9
#define EVENT_GC_END 10
#define EVENT_REQUEST_SEQ_GC 11
#define EVENT_REQUEST_PAR_GC 12

#define EVENT_CREATE_SPARK_THREAD 15
#define EVENT_LOG_MSG 16

#define EVENT_BLOCK_MARKER 18
#define EVENT_USER_MSG 19
#define EVENT_GC_IDLE 20
#define EVENT_GC_WORK 21
#define EVENT_GC_DONE 22

#define EVENT_CAPSET_CREATE 25
#define EVENT_CAPSET_DELETE 26
#define EVENT_CAPSET_ASSIGN_CAP 27
#define EVENT_CAPSET_REMOVE_CAP 28

#define EVENT_RTS_IDENTIFIER 29

#define EVENT_PROGRAM_ARGS 30
#define EVENT_PROGRAM_ENV 31
#define EVENT_OSPROCESS_PID 32
#define EVENT_OSPROCESS_PPID 33
#define EVENT_SPARK_COUNTERS 34
#define EVENT_SPARK_CREATE 35
#define EVENT_SPARK_DUD 36
#define EVENT_SPARK_OVERFLOW 37
#define EVENT_SPARK_RUN 38
#define EVENT_SPARK_STEAL 39
#define EVENT_SPARK_FIZZLE 40
#define EVENT_SPARK_GC 41
#define EVENT_INTERN_STRING 42
#define EVENT_WALL_CLOCK_TIME 43
#define EVENT_THREAD_LABEL 44
#define EVENT_CAP_CREATE 45
#define EVENT_CAP_DELETE 46
#define EVENT_CAP_DISABLE 47
#define EVENT_CAP_ENABLE 48
#define EVENT_HEAP_ALLOCATED 49
#define EVENT_HEAP_SIZE 50
#define EVENT_HEAP_LIVE 51
#define EVENT_HEAP_INFO_GHC 52


#define EVENT_GC_STATS_GHC 53




#define EVENT_GC_GLOBAL_SYNC 54
#define EVENT_TASK_CREATE 55
#define EVENT_TASK_MIGRATE 56
#define EVENT_TASK_DELETE 57
#define EVENT_USER_MARKER 58
#define EVENT_HACK_BUG_T9003 59





#define EVENT_MEM_RETURN 90
#define EVENT_BLOCKS_SIZE 91







#define EVENT_HEAP_PROF_BEGIN 160
#define EVENT_HEAP_PROF_COST_CENTRE 161
#define EVENT_HEAP_PROF_SAMPLE_BEGIN 162
#define EVENT_HEAP_PROF_SAMPLE_COST_CENTRE 163
#define EVENT_HEAP_PROF_SAMPLE_STRING 164
#define EVENT_HEAP_PROF_SAMPLE_END 165
#define EVENT_HEAP_BIO_PROF_SAMPLE_BEGIN 166
#define EVENT_PROF_SAMPLE_COST_CENTRE 167
#define EVENT_PROF_BEGIN 168
#define EVENT_IPE 169

#define EVENT_USER_BINARY_MSG 181

#define EVENT_CONC_MARK_BEGIN 200
#define EVENT_CONC_MARK_END 201
#define EVENT_CONC_SYNC_BEGIN 202
#define EVENT_CONC_SYNC_END 203
#define EVENT_CONC_SWEEP_BEGIN 204
#define EVENT_CONC_SWEEP_END 205
#define EVENT_CONC_UPD_REM_SET_FLUSH 206
#define EVENT_NONMOVING_HEAP_CENSUS 207

#define EVENT_TICKY_COUNTER_DEF 210
#define EVENT_TICKY_COUNTER_SAMPLE 211
#define EVENT_TICKY_COUNTER_BEGIN_SAMPLE 212






#define NUM_GHC_EVENT_TAGS 213
# 209 "includes/rts/EventLogFormat.h"
#define THREAD_SUSPENDED_FOREIGN_CALL 6




#define CAPSET_TYPE_CUSTOM 1
#define CAPSET_TYPE_OSPROCESS 2
#define CAPSET_TYPE_CLOCKDOMAIN 3




typedef enum {
    HEAP_PROF_BREAKDOWN_COST_CENTRE = 0x1,
    HEAP_PROF_BREAKDOWN_MODULE,
    HEAP_PROF_BREAKDOWN_CLOSURE_DESCR,
    HEAP_PROF_BREAKDOWN_TYPE_DESCR,
    HEAP_PROF_BREAKDOWN_RETAINER,
    HEAP_PROF_BREAKDOWN_BIOGRAPHY,
    HEAP_PROF_BREAKDOWN_CLOSURE_TYPE,
    HEAP_PROF_BREAKDOWN_INFO_TABLE
} HeapProfBreakdown;



typedef StgWord16 EventTypeNum;
typedef StgWord64 EventTimestamp;
typedef StgWord32 EventThreadID;
typedef StgWord16 EventCapNo;
typedef StgWord16 EventPayloadSize;
typedef StgWord16 EventThreadStatus;
typedef StgWord32 EventCapsetID;
typedef StgWord16 EventCapsetType;
typedef StgWord64 EventTaskId;
typedef StgWord64 EventKernelThreadId;

#define EVENT_PAYLOAD_SIZE_MAX STG_WORD16_MAX
# 12 "rts/eventlog/EventLog.h" 2


# 1 "rts/sm/NonMovingCensus.h" 1
# 9 "rts/sm/NonMovingCensus.h"
       



struct NonmovingAllocCensus {
    
# 14 "rts/sm/NonMovingCensus.h" 3 4
   _Bool 
# 14 "rts/sm/NonMovingCensus.h"
        collected_live_words;
    uint32_t n_active_segs;
    uint32_t n_filled_segs;
    uint32_t n_live_blocks;
    uint32_t n_live_words;
};


struct NonmovingAllocCensus
nonmovingAllocatorCensusWithWords(uint32_t alloc_idx);

struct NonmovingAllocCensus
nonmovingAllocatorCensus(uint32_t alloc_idx);

void nonmovingPrintAllocatorCensus(
# 28 "rts/sm/NonMovingCensus.h" 3 4
                                  _Bool 
# 28 "rts/sm/NonMovingCensus.h"
                                       collect_live_words);
void nonmovingTraceAllocatorCensus(void);
# 15 "rts/eventlog/EventLog.h" 2

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 17 "rts/eventlog/EventLog.h" 2






extern char *EventTagDesc[];

extern 
# 25 "rts/eventlog/EventLog.h" 3 4
      _Bool 
# 25 "rts/eventlog/EventLog.h"
           eventlog_enabled;

void initEventLogging(void);
void restartEventLogging(void);
void finishCapEventLogging(void);
void freeEventLogging(void);
void abortEventLogging(void);
void moreCapEventBufs (uint32_t from, uint32_t to);
void flushLocalEventsBuf(Capability *cap);
void flushAllCapsEventsBufs(void);
void flushAllEventsBufs(Capability *cap);

typedef void (*EventlogInitPost)(void);




void postInitEvent(EventlogInitPost post_init);


void resetInitEvents(void);

typedef struct eventlog_init_func {
    EventlogInitPost init_func;
    struct eventlog_init_func * next;
} eventlog_init_func_t;






void postSchedEvent(Capability *cap, EventTypeNum tag,
                    StgThreadID id, StgWord info1, StgWord info2);




void postEvent(Capability *cap, EventTypeNum tag);
void postEventNoCap(EventTypeNum tag);

void postEventAtTimestamp (Capability *cap, EventTimestamp ts,
                           EventTypeNum tag);

void postMsg(char *msg, va_list ap);

void postUserEvent(Capability *cap, EventTypeNum type, char *msg);

void postUserBinaryEvent(Capability *cap, EventTypeNum type,
                         uint8_t *msg, size_t size);

void postCapMsg(Capability *cap, char *msg, va_list ap);




void postCapEvent (EventTypeNum tag,
                   EventCapNo capno);




void postCapsetEvent (EventTypeNum tag,
                      EventCapsetID capset,
                      StgWord info);




void postCapsetStrEvent (EventTypeNum tag,
                         EventCapsetID capset,
                         char *msg);




void postCapsetVecEvent (EventTypeNum tag,
                         EventCapsetID capset,
                         int argc,
                         char *msg[]);

void postWallClockTime (EventCapsetID capset);




void postSparkEvent(Capability *cap, EventTypeNum tag, StgWord info1);




void postSparkCountersEvent (Capability *cap,
                             SparkCounters counters,
                             StgWord remaining);




void postThreadLabel(Capability *cap,
                     EventThreadID id,
                     char *label);




void postHeapEvent (Capability *cap,
                    EventTypeNum tag,
                    EventCapsetID heap_capset,
                    W_ info1);

void postEventHeapInfo (EventCapsetID heap_capset,
                        uint32_t gens,
                        W_ maxHeapSize,
                        W_ allocAreaSize,
                        W_ mblockSize,
                        W_ blockSize);

void postEventGcStats (Capability *cap,
                        EventCapsetID heap_capset,
                        uint32_t gen,
                        W_ copied,
                        W_ slop,
                        W_ fragmentation,
                        uint32_t par_n_threads,
                        W_ par_max_copied,
                        W_ par_tot_copied,
                        W_ par_balanced_copied);

void postEventMemReturn (Capability *cap,
                        EventCapsetID heap_capset,
                         uint32_t current_mblocks,
                         uint32_t needed_mblocks,
                         uint32_t returned_mblocks
                        );

void postTaskCreateEvent (EventTaskId taskId,
                          EventCapNo cap,
                          EventKernelThreadId tid);

void postTaskMigrateEvent (EventTaskId taskId,
                           EventCapNo capno,
                           EventCapNo new_capno);

void postTaskDeleteEvent (EventTaskId taskId);

void postHeapProfBegin(StgWord8 profile_id);

void postHeapProfSampleBegin(StgInt era);
void postHeapBioProfSampleBegin(StgInt era, StgWord64 time_ns);
void postHeapProfSampleEnd(StgInt era);

void postHeapProfSampleString(StgWord8 profile_id,
                              const char *label,
                              StgWord64 residency);


void postHeapProfCostCentre(StgWord32 ccID,
                            const char *label,
                            const char *module,
                            const char *srcloc,
                            StgBool is_caf);

void postHeapProfSampleCostCentre(StgWord8 profile_id,
                                  CostCentreStack *stack,
                                  StgWord64 residency);

void postProfSampleCostCentre(Capability *cap,
                              CostCentreStack *stack,
                              StgWord64 ticks);
void postProfBegin(void);


void postIPE(StgWord64 info,
             const char *table_name,
             const char *closure_desc,
             const char *ty_desc,
             const char *label,
             const char *module,
             const char *srcloc);

void postConcUpdRemSetFlush(Capability *cap);
void postConcMarkEnd(StgWord32 marked_obj_count);
void postNonmovingHeapCensus(int log_blk_size,
                             const struct NonmovingAllocCensus *census);


void postTickyCounterDefs(StgEntCounter *p);
void postTickyCounterSamples(StgEntCounter *p);
# 260 "rts/eventlog/EventLog.h"
# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 260 "rts/eventlog/EventLog.h" 2
# 12 "rts/Trace.h" 2







# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 20 "rts/Trace.h" 2







void initTracing (void);
void endTracing (void);
void freeTracing (void);
void resetTracing (void);
void tracingAddCapapilities (uint32_t from, uint32_t to);



typedef StgWord32 CapsetID;
typedef StgWord16 CapsetType;
enum CapsetType { CapsetTypeCustom = 1,
                  CapsetTypeOsProcess = 2,
                  CapsetTypeClockdomain = 3 };
#define CAPSET_OSPROCESS_DEFAULT ((CapsetID)0)
#define CAPSET_HEAP_DEFAULT ((CapsetID)0)
#define CAPSET_CLOCKDOMAIN_DEFAULT ((CapsetID)1)






#define DEBUG_sched RtsFlags.DebugFlags.scheduler
#define DEBUG_interp RtsFlags.DebugFlags.interp
#define DEBUG_weak RtsFlags.DebugFlags.weak
#define DEBUG_gccafs RtsFlags.DebugFlags.gccafs
#define DEBUG_gc RtsFlags.DebugFlags.gc
#define DEBUG_nonmoving_gc RtsFlags.DebugFlags.nonmoving_gc
#define DEBUG_block_alloc RtsFlags.DebugFlags.alloc
#define DEBUG_sanity RtsFlags.DebugFlags.sanity
#define DEBUG_zero_on_gc RtsFlags.DebugFlags.zero_on_gc
#define DEBUG_stable RtsFlags.DebugFlags.stable
#define DEBUG_stm RtsFlags.DebugFlags.stm
#define DEBUG_prof RtsFlags.DebugFlags.prof
#define DEBUG_gran RtsFlags.DebugFlags.gran
#define DEBUG_par RtsFlags.DebugFlags.par
#define DEBUG_linker RtsFlags.DebugFlags.linker
#define DEBUG_squeeze RtsFlags.DebugFlags.squeeze
#define DEBUG_hpc RtsFlags.DebugFlags.hpc
#define DEBUG_sparks RtsFlags.DebugFlags.sparks
#define DEBUG_compact RtsFlags.DebugFlags.compact


extern int TRACE_sched;
extern int TRACE_gc;
extern int TRACE_spark_sampled;
extern int TRACE_spark_full;

extern int TRACE_cap;
extern int TRACE_nonmoving_gc;
# 89 "rts/Trace.h"
void traceBegin (const char *str, ...);
void traceEnd (void);







#define traceSchedEvent(cap,tag,tso,other) if (RTS_UNLIKELY(TRACE_sched)) { traceSchedEvent_(cap, tag, tso, other, 0); }




#define traceSchedEvent2(cap,tag,tso,info1,info2) if (RTS_UNLIKELY(TRACE_sched)) { traceSchedEvent_(cap, tag, tso, info1, info2); }




void traceSchedEvent_ (Capability *cap, EventTypeNum tag,
                       StgTSO *tso, StgWord info1, StgWord info2);

#define traceInitEvent(event) postInitEvent(event)




#define traceGcEvent(cap,tag) if (RTS_UNLIKELY(TRACE_gc)) { traceGcEvent_(cap, tag); }




void traceGcEvent_ (Capability *cap, EventTypeNum tag);




#define traceGcEventAtT(cap,ts,tag) if (RTS_UNLIKELY(TRACE_gc)) { traceGcEventAtT_(cap, ts, tag); }




void traceGcEventAtT_ (Capability *cap, StgWord64 ts, EventTypeNum tag);




#define traceHeapEvent(cap,tag,heap_capset,info1) if (RTS_UNLIKELY(TRACE_gc)) { traceHeapEvent_(cap, tag, heap_capset, info1); }



void traceHeapEvent_ (Capability *cap,
                      EventTypeNum tag,
                      CapsetID heap_capset,
                      W_ info1);

void traceEventHeapInfo_ (CapsetID heap_capset,
                          uint32_t gens,
                          W_ maxHeapSize,
                          W_ allocAreaSize,
                          W_ mblockSize,
                          W_ blockSize);

void traceEventGcStats_ (Capability *cap,
                          CapsetID heap_capset,
                          uint32_t gen,
                          W_ copied,
                          W_ slop,
                          W_ fragmentation,
                          uint32_t par_n_threads,
                          W_ par_max_copied,
                          W_ par_tot_copied,
                          W_ par_balanced_copied);

void traceEventMemReturn_ (Capability *cap,
                          uint32_t current_mblocks,
                          uint32_t needed_mblocks,
                          uint32_t returned_mblocks );




#define traceSparkEvent(cap,tag) if (RTS_UNLIKELY(TRACE_spark_full)) { traceSparkEvent_(cap, tag, 0); }




#define traceSparkEvent2(cap,tag,other) if (RTS_UNLIKELY(TRACE_spark_full)) { traceSparkEvent_(cap, tag, other); }




void traceSparkEvent_ (Capability *cap, EventTypeNum tag, StgWord info1);
# 190 "rts/Trace.h"
#define traceCap(class,cap,msg,...) if (RTS_UNLIKELY(class)) { traceCap_(cap, msg, ##__VA_ARGS__); }




void traceCap_(Capability *cap, char *msg, ...);




#define trace(class,msg,...) if (RTS_UNLIKELY(class)) { trace_(msg, ##__VA_ARGS__); }




void trace_(char *msg, ...);





void traceUserMsg(Capability *cap, char *msg);





void traceUserMarker(Capability *cap, char *msg);




void traceUserBinaryMsg(Capability *cap, uint8_t *msg, size_t size);





void traceThreadLabel_(Capability *cap,
                       StgTSO *tso,
                       char *label);





#define debugTrace(class,msg,...) if (RTS_UNLIKELY(class)) { trace_(msg, ##__VA_ARGS__); }
# 245 "rts/Trace.h"
#define debugTraceCap(class,cap,msg,...) if (RTS_UNLIKELY(class)) { traceCap_(cap, msg, ##__VA_ARGS__); }
# 256 "rts/Trace.h"
#define traceThreadStatus(class,tso) if (RTS_UNLIKELY(class)) { traceThreadStatus_(tso); }




void traceThreadStatus_ (StgTSO *tso);




#define traceCapEvent(cap,tag) if (RTS_UNLIKELY(TRACE_cap)) { traceCapEvent_(cap, tag); }




void traceCapEvent_ (Capability *cap,
                    EventTypeNum tag);

#define traceCapsetEvent(cap,capset,info) if (RTS_UNLIKELY(TRACE_cap)) { traceCapsetEvent_(cap, capset, info); }




void traceCapsetEvent_ (EventTypeNum tag,
                        CapsetID capset,
                        StgWord info);

void traceWallClockTime_(void);

void traceOSProcessInfo_ (void);

void traceSparkCounters_ (Capability *cap,
                          SparkCounters counters,
                          StgWord remaining);

void traceTaskCreate_ (Task *task,
                       Capability *cap);

void traceTaskMigrate_ (Task *task,
                        Capability *cap,
                        Capability *new_cap);

void traceTaskDelete_ (Task *task);

void traceHeapProfBegin(StgWord8 profile_id);
void traceHeapProfSampleBegin(StgInt era);
void traceHeapBioProfSampleBegin(StgInt era, StgWord64 time);
void traceHeapProfSampleEnd(StgInt era);
void traceHeapProfSampleString(StgWord8 profile_id,
                               const char *label, StgWord residency);

void traceHeapProfCostCentre(StgWord32 ccID,
                             const char *label,
                             const char *module,
                             const char *srcloc,
                             StgBool is_caf);
void traceHeapProfSampleCostCentre(StgWord8 profile_id,
                                   CostCentreStack *stack, StgWord residency);

void traceProfSampleCostCentre(Capability *cap,
                               CostCentreStack *stack, StgWord ticks);
void traceProfBegin(void);


void traceConcMarkBegin(void);
void traceConcMarkEnd(StgWord32 marked_obj_count);
void traceConcSyncBegin(void);
void traceConcSyncEnd(void);
void traceConcSweepBegin(void);
void traceConcSweepEnd(void);
void traceConcUpdRemSetFlush(Capability *cap);
void traceNonmovingHeapCensus(uint32_t log_blk_size,
                              const struct NonmovingAllocCensus *census);

void traceIPE(StgInfoTable *info,
               const char *table_name,
               const char *closure_desc,
               const char *ty_desc,
               const char *label,
               const char *module,
               const char *srcloc );
void flushTrace(void);
# 516 "rts/Trace.h"
#define dtraceCreateThread(cap,tid) 
#define dtraceRunThread(cap,tid) 
#define dtraceStopThread(cap,tid,status,info) 
#define dtraceThreadRunnable(cap,tid) 
#define dtraceMigrateThread(cap,tid,new_cap) 
#define dtraceThreadWakeup(cap,tid,other_cap) 
#define dtraceGcStart(cap) 
#define dtraceGcEnd(cap) 
#define dtraceRequestSeqGc(cap) 
#define dtraceRequestParGc(cap) 
#define dtraceCreateSparkThread(cap,spark_tid) 
#define dtraceThreadLabel(cap,tso,label) 
#define dtraceUserMsg(cap,msg) 
#define dtraceUserMarker(cap,msg) 
#define dtraceGcIdle(cap) 
#define dtraceGcWork(cap) 
#define dtraceGcDone(cap) 
#define dtraceGcGlobalSync(cap) 
#define dtraceEventGcStats(heap_capset,gens,copies,slop,fragmentation,par_n_threads,par_max_copied,par_tot_copied,par_balanced_copied) 





#define dtraceEventMemReturn(current,needed,returned) 
#define dtraceHeapInfo(heap_capset,gens,maxHeapSize,allocAreaSize,mblockSize,blockSize) 


#define dtraceEventHeapAllocated(cap,heap_capset,allocated) 

#define dtraceEventHeapSize(heap_capset,size) 
#define dtraceEventBlocksSize(heap_capset,size) 
#define dtraceEventHeapLive(heap_capset,live) 
#define dtraceCapCreate(cap) 
#define dtraceCapDelete(cap) 
#define dtraceCapEnable(cap) 
#define dtraceCapDisable(cap) 
#define dtraceCapsetCreate(capset,capset_type) 
#define dtraceCapsetDelete(capset) 
#define dtraceCapsetAssignCap(capset,capno) 
#define dtraceCapsetRemoveCap(capset,capno) 
#define dtraceSparkCounters(cap,a,b,c,d,e,f,g) 
#define dtraceSparkCreate(cap) 
#define dtraceSparkDud(cap) 
#define dtraceSparkOverflow(cap) 
#define dtraceSparkRun(cap) 
#define dtraceSparkSteal(cap,victim_cap) 
#define dtraceSparkFizzle(cap) 
#define dtraceSparkGc(cap) 
#define dtraceTaskCreate(taskID,cap,tid) 
#define dtraceTaskMigrate(taskID,cap,new_cap) 
#define dtraceTaskDelete(taskID) 
# 588 "rts/Trace.h"
static inline void traceEventCreateThread(Capability *cap __attribute__((__unused__)),
                                          StgTSO *tso __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_sched),0)) { traceSchedEvent_(cap, 0, tso, tso->stackobj->stack_size, 0); };
    ;
}

static inline void traceEventRunThread(Capability *cap __attribute__((__unused__)),
                                       StgTSO *tso __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_sched),0)) { traceSchedEvent_(cap, 1, tso, tso->what_next, 0); };
    ;
}

static inline void traceEventStopThread(Capability *cap __attribute__((__unused__)),
                                        StgTSO *tso __attribute__((__unused__)),
                                        StgThreadReturnCode status __attribute__((__unused__)),
                                        StgWord32 info __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_sched),0)) { traceSchedEvent_(cap, 2, tso, status, info); };
   
                                                                    ;
}

static inline void traceEventMigrateThread(Capability *cap __attribute__((__unused__)),
                                           StgTSO *tso __attribute__((__unused__)),
                                           uint32_t new_cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_sched),0)) { traceSchedEvent_(cap, 4, tso, new_cap, 0); };
   
                                            ;
}

static inline void traceCapCreate(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_cap),0)) { traceCapEvent_(cap, 45); };
    ;
}

static inline void traceCapDelete(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_cap),0)) { traceCapEvent_(cap, 46); };
    ;
}

static inline void traceCapEnable(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_cap),0)) { traceCapEvent_(cap, 48); };
    ;
}

static inline void traceCapDisable(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_cap),0)) { traceCapEvent_(cap, 47); };
    ;





    if (eventlog_enabled) {
        flushLocalEventsBuf(cap);
    }




}

static inline void traceEventThreadWakeup(Capability *cap __attribute__((__unused__)),
                                          StgTSO *tso __attribute__((__unused__)),
                                          uint32_t other_cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_sched),0)) { traceSchedEvent_(cap, 8, tso, other_cap, 0); };
   
                                             ;
}

static inline void traceThreadLabel(Capability *cap __attribute__((__unused__)),
                                    StgTSO *tso __attribute__((__unused__)),
                                    char *label __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_sched),0)) {
        traceThreadLabel_(cap, tso, label);
    }
    ;
}

static inline void traceEventGcStart(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEvent_(cap, 9); };
    ;
}

static inline void traceEventGcStartAtT(Capability *cap __attribute__((__unused__)),
                                        StgWord64 ts __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEventAtT_(cap, ts, 9); };
    ;
}

static inline void traceEventGcEnd(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEvent_(cap, 10); };
    ;
}

static inline void traceEventGcEndAtT(Capability *cap __attribute__((__unused__)),
                                      StgWord64 ts __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEventAtT_(cap, ts, 10); };
    ;
}

static inline void traceEventRequestSeqGc(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEvent_(cap, 11); };
    ;
}

static inline void traceEventRequestParGc(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEvent_(cap, 12); };
    ;
}

static inline void traceEventGcIdle(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEvent_(cap, 20); };
    ;
}

static inline void traceEventGcWork(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEvent_(cap, 21); };
    ;
}

static inline void traceEventGcDone(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEvent_(cap, 22); };
    ;
}

static inline void traceEventGcGlobalSync(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceGcEvent_(cap, 54); };
    ;
}

static inline void traceEventGcStats(Capability *cap __attribute__((__unused__)),
                                     CapsetID heap_capset __attribute__((__unused__)),
                                     uint32_t gen __attribute__((__unused__)),
                                     W_ copied __attribute__((__unused__)),
                                     W_ slop __attribute__((__unused__)),
                                     W_ fragmentation __attribute__((__unused__)),
                                     uint32_t par_n_threads __attribute__((__unused__)),
                                     W_ par_max_copied __attribute__((__unused__)),
                                     W_ par_tot_copied __attribute__((__unused__)),
                                     W_ par_balanced_copied __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) {
        traceEventGcStats_(cap, heap_capset, gen,
                           copied, slop, fragmentation,
                           par_n_threads, par_max_copied,
                           par_tot_copied, par_balanced_copied);
    }
   


                                                           ;
}

static inline void traceEventMemReturn(Capability *cap __attribute__((__unused__)),
                                     uint32_t current_mblocks __attribute__((__unused__)),
                                     uint32_t needed_mblocks __attribute__((__unused__)),
                                     uint32_t returned_mblocks __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) {
        traceEventMemReturn_(cap, current_mblocks, needed_mblocks, returned_mblocks);
    }
    ;
}

static inline void traceEventHeapInfo(CapsetID heap_capset __attribute__((__unused__)),
                                      uint32_t gens __attribute__((__unused__)),
                                      W_ maxHeapSize __attribute__((__unused__)),
                                      W_ allocAreaSize __attribute__((__unused__)),
                                      W_ mblockSize __attribute__((__unused__)),
                                      W_ blockSize __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) {
        traceEventHeapInfo_(heap_capset, gens,
                            maxHeapSize, allocAreaSize,
                            mblockSize, blockSize);
    }
   

                                         ;
}

static inline void traceEventHeapAllocated(Capability *cap __attribute__((__unused__)),
                                           CapsetID heap_capset __attribute__((__unused__)),
                                           W_ allocated __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceHeapEvent_(cap, 49, heap_capset, allocated); };
    ;
}

static inline void traceEventHeapSize(Capability *cap __attribute__((__unused__)),
                                      CapsetID heap_capset __attribute__((__unused__)),
                                      W_ heap_size __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceHeapEvent_(cap, 50, heap_capset, heap_size); };
    ;
}

static inline void traceEventBlocksSize(Capability *cap __attribute__((__unused__)),
                                        CapsetID heap_capset __attribute__((__unused__)),
                                        W_ heap_size __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceHeapEvent_(cap, 91, heap_capset, heap_size); };
    ;
}

static inline void traceEventHeapLive(Capability *cap __attribute__((__unused__)),
                                      CapsetID heap_capset __attribute__((__unused__)),
                                      W_ heap_live __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_gc),0)) { traceHeapEvent_(cap, 51, heap_capset, heap_live); };
    ;
}

static inline void traceCapsetCreate(CapsetID capset __attribute__((__unused__)),
                                     CapsetType capset_type __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_cap),0)) { traceCapsetEvent_(25, capset, capset_type); };
    ;
}

static inline void traceCapsetDelete(CapsetID capset __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_cap),0)) { traceCapsetEvent_(26, capset, 0); };
    ;
}

static inline void traceCapsetAssignCap(CapsetID capset __attribute__((__unused__)),
                                        uint32_t capno __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_cap),0)) { traceCapsetEvent_(27, capset, capno); };
    ;
}

static inline void traceCapsetRemoveCap(CapsetID capset __attribute__((__unused__)),
                                        uint32_t capno __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_cap),0)) { traceCapsetEvent_(28, capset, capno); };
    ;
}

static inline void traceWallClockTime(void)
{
    traceWallClockTime_();

}

static inline void traceOSProcessInfo(void)
{
    traceOSProcessInfo_();


}

static inline void traceEventCreateSparkThread(Capability *cap __attribute__((__unused__)),
                                               StgThreadID spark_tid __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_spark_full),0)) { traceSparkEvent_(cap, 15, spark_tid); };
    ;
}

static inline void traceSparkCounters(Capability *cap __attribute__((__unused__)))
{

    if (__builtin_expect((TRACE_spark_sampled),0)) {
        traceSparkCounters_(cap, cap->spark_stats, sparkPoolSize(cap->sparks));
    }
   






                                                   ;

}

static inline void traceEventSparkCreate(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_spark_full),0)) { traceSparkEvent_(cap, 35, 0); };
    ;
}

static inline void traceEventSparkDud(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_spark_full),0)) { traceSparkEvent_(cap, 36, 0); };
    ;
}

static inline void traceEventSparkOverflow(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_spark_full),0)) { traceSparkEvent_(cap, 37, 0); };
    ;
}

static inline void traceEventSparkRun(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_spark_full),0)) { traceSparkEvent_(cap, 38, 0); };
    ;
}

static inline void traceEventSparkSteal(Capability *cap __attribute__((__unused__)),
                                        uint32_t victim_cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_spark_full),0)) { traceSparkEvent_(cap, 39, victim_cap); };
    ;
}

static inline void traceEventSparkFizzle(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_spark_full),0)) { traceSparkEvent_(cap, 40, 0); };
    ;
}

static inline void traceEventSparkGC(Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect((TRACE_spark_full),0)) { traceSparkEvent_(cap, 41, 0); };
    ;
}

static inline void traceTaskCreate(Task *task __attribute__((__unused__)),
                                   Capability *cap __attribute__((__unused__)))
{
    if (__builtin_expect(!!(task->cap == cap), 1)) ; else _assertFail("rts/Trace.h", 931);



    if (__builtin_expect(!!(cap != 
# 935 "rts/Trace.h" 3 4
   ((void *)0)
# 935 "rts/Trace.h"
   ), 1)) ; else _assertFail("rts/Trace.h", 935);


    if (__builtin_expect((TRACE_sched),0)) {
        traceTaskCreate_(task, cap);
    }
   

                                      ;
}

static inline void traceTaskMigrate(Task *task __attribute__((__unused__)),
                                    Capability *cap __attribute__((__unused__)),
                                    Capability *new_cap __attribute__((__unused__)))
{
    if (__builtin_expect(!!(task->cap == cap), 1)) ; else _assertFail("rts/Trace.h", 950);
    if (__builtin_expect(!!(cap != 
# 951 "rts/Trace.h" 3 4
   ((void *)0)
# 951 "rts/Trace.h"
   ), 1)) ; else _assertFail("rts/Trace.h", 951);
    if (__builtin_expect(!!(cap != new_cap), 1)) ; else _assertFail("rts/Trace.h", 952);
    if (__builtin_expect(!!(new_cap != 
# 953 "rts/Trace.h" 3 4
   ((void *)0)
# 953 "rts/Trace.h"
   ), 1)) ; else _assertFail("rts/Trace.h", 953);

    if (__builtin_expect((TRACE_sched),0)) {
        traceTaskMigrate_(task, cap, new_cap);
    }
   
                                                                        ;
}

static inline void traceTaskDelete(Task *task __attribute__((__unused__)))
{
    if (__builtin_expect(!!(task->cap != 
# 964 "rts/Trace.h" 3 4
   ((void *)0)
# 964 "rts/Trace.h"
   ), 1)) ; else _assertFail("rts/Trace.h", 964);
    if (__builtin_expect((TRACE_sched),0)) {
        traceTaskDelete_(task);
    }
    ;
}

# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 971 "rts/Trace.h" 2
# 15 "rts/Schedule.h" 2

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 17 "rts/Schedule.h" 2





void initScheduler (void);
void exitScheduler (
# 23 "rts/Schedule.h" 3 4
                   _Bool 
# 23 "rts/Schedule.h"
                        wait_foreign);
void freeScheduler (void);
void markScheduler (evac_fn evac, void *user);


void scheduleThread (Capability *cap, StgTSO *tso);



void scheduleThreadNow (Capability *cap, StgTSO *tso);




void scheduleThreadOn(Capability *cap, StgWord cpu, StgTSO *tso);






void wakeUpRts(void);



StgWord raiseExceptionHelper (StgRegTable *reg, StgTSO *tso, StgClosure *exception);


StgWord findRetryFrameHelper (Capability *cap, StgTSO *tso);


StgWord findAtomicallyFrameHelper (Capability *cap, StgTSO *tso);


void scheduleWorker (Capability *cap, Task *task);


void stopAllCapabilitiesWith (Capability **pCap, Task *task, SyncType sync_type);
void stopAllCapabilities (Capability **pCap, Task *task);
void releaseAllCapabilities(uint32_t n, Capability *keep_cap, Task *task);





#define SCHED_RUNNING 0
#define SCHED_INTERRUPTING 1
#define SCHED_SHUTTING_DOWN 2

extern volatile StgWord sched_state;
# 90 "rts/Schedule.h"
#define ACTIVITY_YES 0

#define ACTIVITY_MAYBE_NO 1

#define ACTIVITY_INACTIVE 2

#define ACTIVITY_DONE_GC 3
# 106 "rts/Schedule.h"
extern volatile StgWord recent_activity;
# 116 "rts/Schedule.h"
extern 
# 116 "rts/Schedule.h" 3 4
      _Bool 
# 116 "rts/Schedule.h"
           heap_overflow;


extern Mutex sched_mutex;



void interruptStgRts (void);

void resurrectThreads (StgTSO *);
# 139 "rts/Schedule.h"
inline void
appendToRunQueue (Capability *cap, StgTSO *tso);

inline void
appendToRunQueue (Capability *cap, StgTSO *tso)
{
    if (__builtin_expect(!!(tso->_link == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)), 1)) ; else _assertFail("rts/Schedule.h", 145);
    if (cap->run_queue_hd == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)) {
        cap->run_queue_hd = tso;
        tso->block_info.prev = ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure);
    } else {
        setTSOLink(cap, cap->run_queue_tl, tso);
        setTSOPrev(cap, tso, cap->run_queue_tl);
    }
    cap->run_queue_tl = tso;
    cap->n_run_queue++;
}




inline void
pushOnRunQueue (Capability *cap, StgTSO *tso);

inline void
pushOnRunQueue (Capability *cap, StgTSO *tso)
{
    setTSOLink(cap, tso, cap->run_queue_hd);
    tso->block_info.prev = ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure);
    if (cap->run_queue_hd != ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)) {
        setTSOPrev(cap, cap->run_queue_hd, tso);
    }
    cap->run_queue_hd = tso;
    if (cap->run_queue_tl == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)) {
        cap->run_queue_tl = tso;
    }
    cap->n_run_queue++;
}



static inline StgTSO *
popRunQueue (Capability *cap)
{
    if (__builtin_expect(!!(cap->n_run_queue > 0), 1)) ; else _assertFail("rts/Schedule.h", 183);
    StgTSO *t = cap->run_queue_hd;
    if (__builtin_expect(!!(t != ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)), 1)) ; else _assertFail("rts/Schedule.h", 185);
    cap->run_queue_hd = t->_link;

    StgTSO *link = __atomic_load_n(&t->_link, 0);
    if (link != ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)) {
        link->block_info.prev = ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure);
    }
    __atomic_store_n(&t->_link, ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure), 0);

    if (cap->run_queue_hd == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)) {
        cap->run_queue_tl = ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure);
    }
    cap->n_run_queue--;
    return t;
}

static inline StgTSO *
peekRunQueue (Capability *cap)
{
    return cap->run_queue_hd;
}

void promoteInRunQueue (Capability *cap, StgTSO *tso);
# 227 "rts/Schedule.h"
static inline 
# 227 "rts/Schedule.h" 3 4
             _Bool

# 228 "rts/Schedule.h"
emptyQueue (StgTSO *q)
{
    return (q == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure));
}

static inline 
# 233 "rts/Schedule.h" 3 4
             _Bool

# 234 "rts/Schedule.h"
emptyRunQueue(Capability *cap)
{

    ;
    return cap->n_run_queue == 0;
}

static inline void
truncateRunQueue(Capability *cap)
{

    ;
    ;
    ;
    cap->run_queue_hd = ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure);
    cap->run_queue_tl = ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure);
    cap->n_run_queue = 0;
}






static inline 
# 258 "rts/Schedule.h" 3 4
             _Bool

# 259 "rts/Schedule.h"
emptyThreadQueues(Capability *cap)
{
    return emptyRunQueue(cap)



    ;
}



# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 270 "rts/Schedule.h" 2
# 24 "rts/Capability.c" 2




# 1 "rts/STM.h" 1
# 33 "rts/STM.h"
       



#define STM_FG_LOCKS 




# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 43 "rts/STM.h" 2







void stmPreGCHook(Capability *cap);
# 61 "rts/STM.h"
StgTRecHeader *stmStartTransaction(Capability *cap, StgTRecHeader *outer);
StgTRecHeader *stmStartNestedTransaction(Capability *cap, StgTRecHeader *outer
);







void stmAbortTransaction(Capability *cap, StgTRecHeader *trec);
void stmFreeAbortedTRec(Capability *cap, StgTRecHeader *trec);
# 83 "rts/STM.h"
void stmCondemnTransaction(Capability *cap, StgTRecHeader *trec);
# 99 "rts/STM.h"
StgBool stmValidateNestOfTransactions(Capability *cap, StgTRecHeader *trec);
# 147 "rts/STM.h"
StgBool stmCommitTransaction(Capability *cap, StgTRecHeader *trec);
StgBool stmCommitNestedTransaction(Capability *cap, StgTRecHeader *trec);
# 157 "rts/STM.h"
StgBool stmWait(Capability *cap, StgTSO *tso, StgTRecHeader *trec);

void stmWaitUnlock(Capability *cap, StgTRecHeader *trec);
# 169 "rts/STM.h"
StgBool stmReWait(Capability *cap, StgTSO *tso);
# 182 "rts/STM.h"
StgClosure *stmReadTVar(Capability *cap,
                        StgTRecHeader *trec,
                        StgTVar *tvar);





void stmWriteTVar(Capability *cap,
                  StgTRecHeader *trec,
                  StgTVar *tvar,
                  StgClosure *new_value);





#define END_STM_WATCH_QUEUE ((StgTVarWatchQueue *)(void *)&stg_END_STM_WATCH_QUEUE_closure)
#define END_STM_CHUNK_LIST ((StgTRecChunk *)(void *)&stg_END_STM_CHUNK_LIST_closure)

#define NO_TREC ((StgTRecHeader *)(void *)&stg_NO_TREC_closure)



# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 206 "rts/STM.h" 2
# 29 "rts/Capability.c" 2
# 1 "rts/RtsUtils.h" 1
# 9 "rts/RtsUtils.h"
       

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 12 "rts/RtsUtils.h" 2





void initAllocator(void);
void shutdownAllocator(void);

void *stgMallocBytes(size_t n, char *msg)
    __attribute__((__malloc__));

void *stgReallocBytes(void *p, size_t n, char *msg);

void *stgCallocBytes(size_t count, size_t size, char *msg)
     __attribute__((__malloc__));

char *stgStrndup(const char *s, size_t n);

void stgFree(void* p);

void *stgMallocAlignedBytes(size_t n, size_t align, char *msg);

void stgFreeAligned(void *p);





int rtsSleep(Time t);
char *time_str(void);
char *showStgWord64(StgWord64, char *, 
# 42 "rts/RtsUtils.h" 3 4
                                      _Bool
# 42 "rts/RtsUtils.h"
                                          );


void heapCheckFail( void );


void printRtsInfo(const RtsConfig);

void checkFPUStack(void);

#define xstr(s) str(s)
#define str(s) #s

# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 55 "rts/RtsUtils.h" 2
# 30 "rts/Capability.c" 2
# 1 "rts/sm/OSMem.h" 1
# 9 "rts/sm/OSMem.h"
       

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 12 "rts/sm/OSMem.h" 2

void osMemInit(void);
void *osGetMBlocks(uint32_t n);
void osFreeMBlocks(void *addr, uint32_t n);
void osReleaseFreeMemory(void);
void osFreeAllMBlocks(void);
size_t getPageSize (void);
StgWord64 getPhysicalMemorySize (void);
void setExecutable (void *p, W_ len, 
# 20 "rts/sm/OSMem.h" 3 4
                                    _Bool 
# 20 "rts/sm/OSMem.h"
                                         exec);

# 21 "rts/sm/OSMem.h" 3 4
_Bool 
# 21 "rts/sm/OSMem.h"
    osBuiltWithNumaSupport(void);

# 22 "rts/sm/OSMem.h" 3 4
_Bool 
# 22 "rts/sm/OSMem.h"
    osNumaAvailable(void);
uint32_t osNumaNodes(void);
uint64_t osNumaMask(void);
void osBindMBlocksToNode(void *addr, StgWord size, uint32_t node);

static inline size_t
roundDownToPage (size_t x)
{
    size_t size = getPageSize();
    return (x & ~(size - 1));
}

static inline size_t
roundUpToAlign (size_t size, size_t align)
{

    return (size + align - 1) & ~(align - 1);
}

static inline size_t
roundUpToPage (size_t x)
{
    return roundUpToAlign(x, getPageSize());
}
# 70 "rts/sm/OSMem.h"
void *osReserveHeapMemory(void *startAddress, W_ *len);







void osCommitMemory(void *p, W_ len);







void osDecommitMemory(void *p, W_ len);






void osReleaseHeapMemory(void);


# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 96 "rts/sm/OSMem.h" 2
# 31 "rts/Capability.c" 2
# 1 "rts/sm/BlockAlloc.h" 1
# 9 "rts/sm/BlockAlloc.h"
       

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 12 "rts/sm/BlockAlloc.h" 2

bdescr *allocLargeChunk (W_ min, W_ max);
bdescr *allocLargeChunkOnNode (uint32_t node, W_ min, W_ max);



extern W_ countBlocks (bdescr *bd);
extern W_ countAllocdBlocks (bdescr *bd);
extern uint32_t returnMemoryToOS(uint32_t n);


void checkFreeListSanity(void);
W_ countFreeList(void);
void markBlocks (bdescr *bd);
void reportUnmarkedBlocks (void);


extern W_ n_alloc_blocks;
extern W_ hw_alloc_blocks;

# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 32 "rts/sm/BlockAlloc.h" 2
# 32 "rts/Capability.c" 2
# 1 "rts/IOManager.h" 1
# 20 "rts/IOManager.h"
       

# 1 "rts/BeginPrivate.h" 1
# 9 "rts/BeginPrivate.h"
#pragma GCC visibility push(hidden)
# 23 "rts/IOManager.h" 2



void initIOManager(void);







void initIOManagerAfterFork( Capability **pcap);
# 48 "rts/IOManager.h"
void stopIOManager(void);
void exitIOManager(
# 49 "rts/IOManager.h" 3 4
                  _Bool 
# 49 "rts/IOManager.h"
                       wait_threads);
# 66 "rts/IOManager.h"
void wakeupIOManager(void);







#define USED_IF_NOT_THREADS_AND_MINGW32 STG_UNUSED



#define USED_IF_THREADS_AND_NOT_MINGW32 





# 1 "rts/EndPrivate.h" 1

#pragma GCC visibility pop
# 84 "rts/IOManager.h" 2
# 33 "rts/Capability.c" 2





Capability MainCapability;

uint32_t n_capabilities = 0;
uint32_t enabled_capabilities = 0;






Capability **capabilities = 
# 48 "rts/Capability.c" 3 4
                           ((void *)0)
# 48 "rts/Capability.c"
                               ;





static Capability *last_free_capability[16];





PendingSync * volatile pending_sync = 0;


uint32_t n_numa_nodes;


uint32_t numa_map[16];





Capability * rts_unsafeGetMyCapability (void)
{

  return myTask()->cap;



}


static 
# 82 "rts/Capability.c" 3 4
             _Bool

# 83 "rts/Capability.c"
globalWorkToDo (void)
{
    return __atomic_load_n(&sched_state, 0) >= 1
      || __atomic_load_n(&recent_activity, 0) == 2;
}



StgClosure *
findSpark (Capability *cap)
{
  Capability *robbed;
  StgClosurePtr spark;
  
# 96 "rts/Capability.c" 3 4
 _Bool 
# 96 "rts/Capability.c"
      retry;
  uint32_t i = 0;


  if (!emptyRunQueue(cap) || __atomic_load_n(&cap->n_returning_tasks, 0) != 0) {



      return 0;
  }

  do {
      retry = 
# 108 "rts/Capability.c" 3 4
             0
# 108 "rts/Capability.c"
                  ;







      spark = tryStealSpark(cap->sparks);
      while (spark != 
# 117 "rts/Capability.c" 3 4
                     ((void *)0) 
# 117 "rts/Capability.c"
                          && fizzledSpark(spark)) {
          cap->spark_stats.fizzled++;
          traceEventSparkFizzle(cap);
          spark = tryStealSpark(cap->sparks);
      }
      if (spark != 
# 122 "rts/Capability.c" 3 4
                  ((void *)0)
# 122 "rts/Capability.c"
                      ) {
          cap->spark_stats.converted++;


          traceEventSparkRun(cap);

          return spark;
      }
      if (!emptySparkPoolCap(cap)) {
          retry = 
# 131 "rts/Capability.c" 3 4
                 1
# 131 "rts/Capability.c"
                     ;
      }

      if (getNumCapabilities() == 1) { return 
# 134 "rts/Capability.c" 3 4
                                             ((void *)0)
# 134 "rts/Capability.c"
                                                 ; }

      if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("cap %d: Trying to steal work from other capabilities", cap->no); }

                         ;



      for ( i=0 ; i < getNumCapabilities() ; i++ ) {
          robbed = capabilities[i];
          if (cap == robbed)
              continue;

          if (emptySparkPoolCap(robbed))
              continue;

          spark = tryStealSpark(robbed->sparks);
          while (spark != 
# 151 "rts/Capability.c" 3 4
                         ((void *)0) 
# 151 "rts/Capability.c"
                              && fizzledSpark(spark)) {
              cap->spark_stats.fizzled++;
              traceEventSparkFizzle(cap);
              spark = tryStealSpark(robbed->sparks);
          }
          if (spark == 
# 156 "rts/Capability.c" 3 4
                      ((void *)0) 
# 156 "rts/Capability.c"
                           && !emptySparkPoolCap(robbed)) {


              retry = 
# 159 "rts/Capability.c" 3 4
                     1
# 159 "rts/Capability.c"
                         ;
          }

          if (spark != 
# 162 "rts/Capability.c" 3 4
                      ((void *)0)
# 162 "rts/Capability.c"
                          ) {
              cap->spark_stats.converted++;
              traceEventSparkSteal(cap, robbed->no);

              return spark;
          }

      }
  } while (retry);

  if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("No sparks stolen"); };
  return 
# 173 "rts/Capability.c" 3 4
        ((void *)0)
# 173 "rts/Capability.c"
            ;
}






# 180 "rts/Capability.c" 3 4
_Bool

# 181 "rts/Capability.c"
anySparks (void)
{
    uint32_t i;

    for (i=0; i < getNumCapabilities(); i++) {
        if (!emptySparkPoolCap(capabilities[i])) {
            return 
# 187 "rts/Capability.c" 3 4
                  1
# 187 "rts/Capability.c"
                      ;
        }
    }
    return 
# 190 "rts/Capability.c" 3 4
          0
# 190 "rts/Capability.c"
               ;
}
# 201 "rts/Capability.c"
static void
newReturningTask (Capability *cap, Task *task)
{
    if (__builtin_expect(!!(pthread_mutex_lock(&cap->lock) == 
# 204 "rts/Capability.c" 3 4
   35
# 204 "rts/Capability.c"
   ), 1)) ; else _assertFail("rts/Capability.c", 204);
    if (__builtin_expect(!!(task->next == 
# 205 "rts/Capability.c" 3 4
   ((void *)0)
# 205 "rts/Capability.c"
   ), 1)) ; else _assertFail("rts/Capability.c", 205);
    if (cap->returning_tasks_hd) {
        if (__builtin_expect(!!(cap->returning_tasks_tl->next == 
# 207 "rts/Capability.c" 3 4
       ((void *)0)
# 207 "rts/Capability.c"
       ), 1)) ; else _assertFail("rts/Capability.c", 207);
        cap->returning_tasks_tl->next = task;
    } else {
        cap->returning_tasks_hd = task;
    }
    cap->returning_tasks_tl = task;


    __atomic_add_fetch(&cap->n_returning_tasks, 1, 0);

    if (__builtin_expect(!!(cap->returning_tasks_hd == 
# 217 "rts/Capability.c" 3 4
   ((void *)0) 
# 217 "rts/Capability.c"
   ? cap->returning_tasks_tl == 
# 217 "rts/Capability.c" 3 4
   ((void *)0) 
# 217 "rts/Capability.c"
   && cap->n_returning_tasks == 0 : 1), 1)) ; else _assertFail("rts/Capability.c", 217);;
}

static Task *
popReturningTask (Capability *cap)
{
    if (__builtin_expect(!!(pthread_mutex_lock(&cap->lock) == 
# 223 "rts/Capability.c" 3 4
   35
# 223 "rts/Capability.c"
   ), 1)) ; else _assertFail("rts/Capability.c", 223);
    Task *task;
    task = cap->returning_tasks_hd;
    if (__builtin_expect(!!(task), 1)) ; else _assertFail("rts/Capability.c", 226);
    cap->returning_tasks_hd = task->next;
    if (!cap->returning_tasks_hd) {
        cap->returning_tasks_tl = 
# 229 "rts/Capability.c" 3 4
                                 ((void *)0)
# 229 "rts/Capability.c"
                                     ;
    }
    task->next = 
# 231 "rts/Capability.c" 3 4
                ((void *)0)
# 231 "rts/Capability.c"
                    ;


    __atomic_add_fetch(&cap->n_returning_tasks, -1, 0);

    if (__builtin_expect(!!(cap->returning_tasks_hd == 
# 236 "rts/Capability.c" 3 4
   ((void *)0) 
# 236 "rts/Capability.c"
   ? cap->returning_tasks_tl == 
# 236 "rts/Capability.c" 3 4
   ((void *)0) 
# 236 "rts/Capability.c"
   && cap->n_returning_tasks == 0 : 1), 1)) ; else _assertFail("rts/Capability.c", 236);;
    return task;
}
# 247 "rts/Capability.c"
static void
initCapability (Capability *cap, uint32_t i)
{
    uint32_t g;

    cap->no = i;
    cap->node = ((i) % n_numa_nodes);
    cap->in_haskell = 
# 254 "rts/Capability.c" 3 4
                            0
# 254 "rts/Capability.c"
                                 ;
    cap->idle = 0;
    cap->disabled = 
# 256 "rts/Capability.c" 3 4
                            0
# 256 "rts/Capability.c"
                                 ;

    cap->run_queue_hd = ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure);
    cap->run_queue_tl = ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure);
    cap->n_run_queue = 0;


    initMutex(&cap->lock);
    cap->running_task = 
# 264 "rts/Capability.c" 3 4
                            ((void *)0)
# 264 "rts/Capability.c"
                                ;
    cap->spare_workers = 
# 265 "rts/Capability.c" 3 4
                            ((void *)0)
# 265 "rts/Capability.c"
                                ;
    cap->n_spare_workers = 0;
    cap->suspended_ccalls = 
# 267 "rts/Capability.c" 3 4
                            ((void *)0)
# 267 "rts/Capability.c"
                                ;
    cap->n_suspended_ccalls = 0;
    cap->returning_tasks_hd = 
# 269 "rts/Capability.c" 3 4
                             ((void *)0)
# 269 "rts/Capability.c"
                                 ;
    cap->returning_tasks_tl = 
# 270 "rts/Capability.c" 3 4
                             ((void *)0)
# 270 "rts/Capability.c"
                                 ;
    cap->n_returning_tasks = 0;
    cap->inbox = (Message*)((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure);
    cap->putMVars = 
# 273 "rts/Capability.c" 3 4
                             ((void *)0)
# 273 "rts/Capability.c"
                                 ;
    cap->sparks = allocSparkPool();
    cap->spark_stats.created = 0;
    cap->spark_stats.dud = 0;
    cap->spark_stats.overflowed = 0;
    cap->spark_stats.converted = 0;
    cap->spark_stats.gcd = 0;
    cap->spark_stats.fizzled = 0;

    cap->io_manager_control_wr_fd = -1;


    cap->total_allocated = 0;

    cap->f.stgEagerBlackholeInfo = (W_)&__stg_EAGER_BLACKHOLE_info;
    cap->f.stgGCEnter1 = (StgFunPtr)__stg_gc_enter_1;
    cap->f.stgGCFun = (StgFunPtr)__stg_gc_fun;

    cap->mut_lists = stgMallocBytes(sizeof(bdescr *) *
                                     RtsFlags.GcFlags.generations,
                                     "initCapability");
    cap->saved_mut_lists = stgMallocBytes(sizeof(bdescr *) *
                                          RtsFlags.GcFlags.generations,
                                          "initCapability");
    cap->current_segments = 
# 297 "rts/Capability.c" 3 4
                           ((void *)0)
# 297 "rts/Capability.c"
                               ;




    cap->upd_rem_set.queue.blocks = 
# 302 "rts/Capability.c" 3 4
                                   ((void *)0)
# 302 "rts/Capability.c"
                                       ;

    for (g = 0; g < RtsFlags.GcFlags.generations; g++) {
        cap->mut_lists[g] = 
# 305 "rts/Capability.c" 3 4
                           ((void *)0)
# 305 "rts/Capability.c"
                               ;
    }

    cap->weak_ptr_list_hd = 
# 308 "rts/Capability.c" 3 4
                           ((void *)0)
# 308 "rts/Capability.c"
                               ;
    cap->weak_ptr_list_tl = 
# 309 "rts/Capability.c" 3 4
                           ((void *)0)
# 309 "rts/Capability.c"
                               ;
    cap->free_tvar_watch_queues = ((StgTVarWatchQueue *)(void *)&stg_END_STM_WATCH_QUEUE_closure);
    cap->free_trec_chunks = ((StgTRecChunk *)(void *)&stg_END_STM_CHUNK_LIST_closure);
    cap->free_trec_headers = ((StgTRecHeader *)(void *)&stg_NO_TREC_closure);
    cap->transaction_tokens = 0;
    cap->context_switch = 0;
    cap->interrupt = 0;
    cap->pinned_object_block = 
# 316 "rts/Capability.c" 3 4
                              ((void *)0)
# 316 "rts/Capability.c"
                                  ;
    cap->pinned_object_blocks = 
# 317 "rts/Capability.c" 3 4
                               ((void *)0)
# 317 "rts/Capability.c"
                                   ;
    cap->pinned_object_empty = 
# 318 "rts/Capability.c" 3 4
                              ((void *)0)
# 318 "rts/Capability.c"
                                  ;


    cap->r.rCCCS = CCS_SYSTEM;






    cap->r.rCurrentTSO = 
# 328 "rts/Capability.c" 3 4
                        ((void *)0)
# 328 "rts/Capability.c"
                            ;

    traceCapCreate(cap);
    traceCapsetAssignCap(((CapsetID)0), i);
    traceCapsetAssignCap(((CapsetID)1), i);

    traceSparkCounters(cap);

}
# 346 "rts/Capability.c"
void initCapabilities (void)
{
    uint32_t i;



    traceCapsetCreate(((CapsetID)0), CapsetTypeOsProcess);
    traceCapsetCreate(((CapsetID)1), CapsetTypeClockdomain);


    if (!RtsFlags.GcFlags.numa) {
        n_numa_nodes = 1;
        for (i = 0; i < 16; i++) {
            numa_map[i] = 0;
        }
    } else if (RtsFlags.DebugFlags.numa) {

    } else {
        uint32_t nNodes = osNumaNodes();
        if (nNodes > 16) {
            barf("Too many NUMA nodes (max %d)", 16);
        }
        StgWord mask = RtsFlags.GcFlags.numaMask & osNumaMask();
        uint32_t logical = 0, physical = 0;
        for (; physical < 16; physical++) {
            if (mask & 1) {
                numa_map[logical++] = physical;
            }
            mask = mask >> 1;
        }
        n_numa_nodes = logical;
        if (logical == 0) {
            barf("available NUMA node set is empty");
        }
    }
# 392 "rts/Capability.c"
    n_capabilities = 0;
    moreCapabilities(0, RtsFlags.ParFlags.nCapabilities);
    n_capabilities = RtsFlags.ParFlags.nCapabilities;
# 406 "rts/Capability.c"
    enabled_capabilities = n_capabilities;




    for (i = 0; i < n_numa_nodes; i++) {
        last_free_capability[i] = capabilities[0];
    }
}

void
moreCapabilities (uint32_t from , uint32_t to )
{

    Capability **new_capabilities = stgMallocBytes(to * sizeof(Capability*), "moreCapabilities");






    stopTimer();

    if (to == 1) {



        new_capabilities[0] = &MainCapability;
        initCapability(&MainCapability, 0);
    }
    else
    {
        for (uint32_t i = 0; i < to; i++) {
            if (i < from) {
                new_capabilities[i] = capabilities[i];
            } else {
                new_capabilities[i] = stgMallocAlignedBytes(sizeof(Capability),
                                                            64,
                                                            "moreCapabilities");
                initCapability(new_capabilities[i], i);
            }
        }
    }

    if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("allocated %d more capabilities", to - from); };

    Capability **old_capabilities = __atomic_load_n(&capabilities, 2);
    __atomic_store_n(&capabilities, new_capabilities, 3);
    if (old_capabilities != 
# 454 "rts/Capability.c" 3 4
                           ((void *)0)
# 454 "rts/Capability.c"
                               ) {
        stgFree(old_capabilities);
    }

    startTimer();

}






void contextSwitchAllCapabilities(void)
{
    uint32_t i;
    for (i=0; i < getNumCapabilities(); i++) {
        contextSwitchCapability(capabilities[i]);
    }
}

void interruptAllCapabilities(void)
{
    uint32_t i;
    for (i=0; i < getNumCapabilities(); i++) {
        interruptCapability(capabilities[i]);
    }
}
# 498 "rts/Capability.c"
static void
giveCapabilityToTask (Capability *cap , Task *task)
{
    if (__builtin_expect(!!(pthread_mutex_lock(&cap->lock) == 
# 501 "rts/Capability.c" 3 4
   35
# 501 "rts/Capability.c"
   ), 1)) ; else _assertFail("rts/Capability.c", 501);
    if (__builtin_expect(!!(task->cap == cap), 1)) ; else _assertFail("rts/Capability.c", 502);
    if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("passing capability %d to %s %#" 
# 503 "rts/Capability.c" 3 4
   "l" "x"
# 503 "rts/Capability.c"
   , cap->no, task->incall->tso ? "bound task" : "worker", serialisableTaskId(task)); }

                                        ;
    { ; int __r = pthread_mutex_lock(&task->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 506, __r); } };
    if (task->wakeup == 
# 507 "rts/Capability.c" 3 4
                       0
# 507 "rts/Capability.c"
                            ) {
        task->wakeup = 
# 508 "rts/Capability.c" 3 4
                      1
# 508 "rts/Capability.c"
                          ;



        signalCondition(&task->cond);
    }
    ; if (pthread_mutex_unlock(&task->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",514); };
}
# 532 "rts/Capability.c"
void
releaseCapability_ (Capability* cap,
                    
# 534 "rts/Capability.c" 3 4
                   _Bool 
# 534 "rts/Capability.c"
                        always_wakeup)
{
    Task *task;

    task = cap->running_task;

    if (__builtin_expect(!!(cap->run_queue_hd == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure) ? cap->run_queue_tl == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure) && cap->n_run_queue == 0 : 1), 1)) ; else _assertFail("rts/Capability.c", 540); if (__builtin_expect(!!(cap->suspended_ccalls == 
# 540 "rts/Capability.c" 3 4
   ((void *)0) 
# 540 "rts/Capability.c"
   ? cap->n_suspended_ccalls == 0 : 1), 1)) ; else _assertFail("rts/Capability.c", 540); if (__builtin_expect(!!(myTask() == task), 1)) ; else _assertFail("rts/Capability.c", 540); if (__builtin_expect(!!(task->id == osThreadId()), 1)) ; else _assertFail("rts/Capability.c", 540);;
    if (__builtin_expect(!!(cap->returning_tasks_hd == 
# 541 "rts/Capability.c" 3 4
   ((void *)0) 
# 541 "rts/Capability.c"
   ? cap->returning_tasks_tl == 
# 541 "rts/Capability.c" 3 4
   ((void *)0) 
# 541 "rts/Capability.c"
   && cap->n_returning_tasks == 0 : 1), 1)) ; else _assertFail("rts/Capability.c", 541);;
    if (__builtin_expect(!!(pthread_mutex_lock(&cap->lock) == 
# 542 "rts/Capability.c" 3 4
   35
# 542 "rts/Capability.c"
   ), 1)) ; else _assertFail("rts/Capability.c", 542);

    __atomic_store_n(&cap->running_task, 
# 544 "rts/Capability.c" 3 4
   ((void *)0)
# 544 "rts/Capability.c"
   , 0);



    if (cap->n_returning_tasks != 0) {
        giveCapabilityToTask(cap,cap->returning_tasks_hd);

        return;
    }
# 563 "rts/Capability.c"
    PendingSync *sync = __atomic_load_n(&pending_sync, 5);
    if (sync && (sync->type != SYNC_GC_PAR || sync->idle[cap->no])) {
        if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("sync pending, freeing capability %d", cap->no); };
        return;
    }



    if (!emptyRunQueue(cap) && peekRunQueue(cap)->bound) {





        task = peekRunQueue(cap)->bound->task;
        giveCapabilityToTask(cap, task);
        return;
    }

    if (!cap->spare_workers) {




        if (__atomic_load_n(&sched_state, 0) < 2 || !emptyRunQueue(cap)) {
            if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("starting new worker on capability %d", cap->no); }
                                                                       ;
            startWorkerTask(cap);
            return;
        }
    }



    if (always_wakeup ||
        !emptyRunQueue(cap) || !emptyInbox(cap) ||
        (!cap->disabled && !emptySparkPoolCap(cap)) || globalWorkToDo()) {
        if (cap->spare_workers) {
            giveCapabilityToTask(cap, cap->spare_workers);

            return;
        }
    }


    cap->r.rCCCS = CCS_IDLE;

    __atomic_store_n(&last_free_capability[cap->node], cap, 0);
    if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("freeing capability %d", cap->no); };
}

void
releaseCapability (Capability* cap )
{
    { ; int __r = pthread_mutex_lock(&cap->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 617, __r); } };
    releaseCapability_(cap, 
# 618 "rts/Capability.c" 3 4
                           0
# 618 "rts/Capability.c"
                                );
    ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",619); };
}

void
releaseAndWakeupCapability (Capability* cap )
{
    { ; int __r = pthread_mutex_lock(&cap->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 625, __r); } };
    releaseCapability_(cap, 
# 626 "rts/Capability.c" 3 4
                           1
# 626 "rts/Capability.c"
                               );
    ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",627); };
}

static void
enqueueWorker (Capability* cap )
{
    Task *task;

    task = cap->running_task;



    if (__builtin_expect(!!(!task->stopped), 1)) ; else _assertFail("rts/Capability.c", 639);
    if (__builtin_expect(!!(task->worker), 1)) ; else _assertFail("rts/Capability.c", 640);

    if (cap->n_spare_workers < 6)
    {
        task->next = cap->spare_workers;
        cap->spare_workers = task;
        cap->n_spare_workers++;
    }
    else
    {
        if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("%d spare workers already, exiting", cap->n_spare_workers); }
                                        ;
        releaseCapability_(cap,
# 652 "rts/Capability.c" 3 4
                              0
# 652 "rts/Capability.c"
                                   );

        workerTaskStop(task);
        ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",655); };
        shutdownThread();
    }
}
# 701 "rts/Capability.c"
static Capability * waitForWorkerCapability (Task *task)
{
    Capability *cap;

    for (;;) {
        { ; int __r = pthread_mutex_lock(&task->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 706, __r); } };

        if (!task->wakeup) waitCondition(&task->cond, &task->lock);


        ;
        cap = task->cap;


        ;
        task->wakeup = 
# 716 "rts/Capability.c" 3 4
                      0
# 716 "rts/Capability.c"
                           ;
        ; if (pthread_mutex_unlock(&task->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",717); };

        if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("woken up on capability %d", cap->no); };

        { ; int __r = pthread_mutex_lock(&cap->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 721, __r); } };
        if (cap->running_task != 
# 722 "rts/Capability.c" 3 4
                                ((void *)0)
# 722 "rts/Capability.c"
                                    ) {
            if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("capability %d is owned by another task", cap->no); }
                                                                         ;
            ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",725); };
            continue;
        }

        if (task->cap != cap) {

            if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("task has been migrated to cap %d", task->cap->no); }
                                                                         ;
            ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",733); };
            continue;
        }

        if (task->incall->tso == 
# 737 "rts/Capability.c" 3 4
                                ((void *)0)
# 737 "rts/Capability.c"
                                    ) {
            if (__builtin_expect(!!(cap->spare_workers != 
# 738 "rts/Capability.c" 3 4
           ((void *)0)
# 738 "rts/Capability.c"
           ), 1)) ; else _assertFail("rts/Capability.c", 738);


            if (cap->spare_workers != task) {
                giveCapabilityToTask(cap,cap->spare_workers);
                ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",743); };
                continue;
            }
            cap->spare_workers = task->next;
            task->next = 
# 747 "rts/Capability.c" 3 4
                        ((void *)0)
# 747 "rts/Capability.c"
                            ;
            cap->n_spare_workers--;
        }

        __atomic_store_n(&cap->running_task, task, 0);
        ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",752); };
        break;
    }

    return cap;
}
# 772 "rts/Capability.c"
static Capability * waitForReturnCapability (Task *task)
{
    Capability *cap;

    for (;;) {
        { ; int __r = pthread_mutex_lock(&task->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 777, __r); } };

        if (!task->wakeup) waitCondition(&task->cond, &task->lock);
        cap = task->cap;
        task->wakeup = 
# 781 "rts/Capability.c" 3 4
                      0
# 781 "rts/Capability.c"
                           ;
        ; if (pthread_mutex_unlock(&task->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",782); };


        { ; int __r = pthread_mutex_lock(&cap->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 785, __r); } };
        if (cap->running_task == 
# 786 "rts/Capability.c" 3 4
                                ((void *)0)
# 786 "rts/Capability.c"
                                    ) {
            if (cap->returning_tasks_hd != task) {
                giveCapabilityToTask(cap,cap->returning_tasks_hd);
                ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",789); };
                continue;
            }
            __atomic_store_n(&cap->running_task, task, 0);
            popReturningTask(cap);
            ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",794); };
            break;
        }
        ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",797); };
    }

    return cap;
}
# 816 "rts/Capability.c"
static 
# 816 "rts/Capability.c" 3 4
      _Bool 
# 816 "rts/Capability.c"
           capability_is_busy(const Capability * cap)
{
    return __atomic_load_n(&cap->running_task, 0) != 
# 818 "rts/Capability.c" 3 4
                                              ((void *)0)
# 818 "rts/Capability.c"
                                                  ;
}
# 830 "rts/Capability.c"
static Capability * find_capability_for_task(const Task * task)
{
    if (task->preferred_capability != -1) {

        return capabilities[task->preferred_capability %
                            enabled_capabilities];
    } else {

        Capability *cap = __atomic_load_n(&last_free_capability[task->node], 0);




        if (!capability_is_busy(cap)) {
            return cap;
        } else {


            for (uint32_t i = task->node; i < enabled_capabilities;
                  i += n_numa_nodes) {


                if (!__atomic_load_n(&capabilities[i]->running_task, 0)) {
                    return capabilities[i];
                }
            }


            return __atomic_load_n(&last_free_capability[task->node], 0);
        }
    }
}
# 877 "rts/Capability.c"
void waitForCapability (Capability **pCap, Task *task)
{







    Capability *cap = *pCap;

    if (cap == 
# 888 "rts/Capability.c" 3 4
              ((void *)0)
# 888 "rts/Capability.c"
                  ) {
        cap = find_capability_for_task(task);


        task->cap = cap;
    } else {
        if (__builtin_expect(!!(task->cap == cap), 1)) ; else _assertFail("rts/Capability.c", 894);
    }

    if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("returning; I want capability %d", cap->no); };

    { ; int __r = pthread_mutex_lock(&cap->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 899, __r); } };
    if (!cap->running_task) {

        __atomic_store_n(&cap->running_task, task, 0);
        ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",903); };
    } else {
        newReturningTask(cap,task);
        ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",906); };
        cap = waitForReturnCapability(task);
    }


    cap->r.rCCCS = CCS_SYSTEM;


    if (__builtin_expect(!!(cap->running_task != 
# 914 "rts/Capability.c" 3 4
   ((void *)0) 
# 914 "rts/Capability.c"
   && cap->running_task == task), 1)) ; else _assertFail("rts/Capability.c", 914); if (__builtin_expect(!!(task->cap == cap), 1)) ; else _assertFail("rts/Capability.c", 914); if (__builtin_expect(!!(cap->run_queue_hd == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure) ? cap->run_queue_tl == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure) && cap->n_run_queue == 0 : 1), 1)) ; else _assertFail("rts/Capability.c", 914); if (__builtin_expect(!!(cap->suspended_ccalls == 
# 914 "rts/Capability.c" 3 4
   ((void *)0) 
# 914 "rts/Capability.c"
   ? cap->n_suspended_ccalls == 0 : 1), 1)) ; else _assertFail("rts/Capability.c", 914); if (__builtin_expect(!!(myTask() == task), 1)) ; else _assertFail("rts/Capability.c", 914); if (__builtin_expect(!!(task->id == osThreadId()), 1)) ; else _assertFail("rts/Capability.c", 914);;

    if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("resuming capability %d", cap->no); };

    *pCap = cap;

}
# 951 "rts/Capability.c"

# 951 "rts/Capability.c" 3 4
_Bool

# 952 "rts/Capability.c"
yieldCapability
    ( Capability** pCap




    , Task *task
    , 
# 959 "rts/Capability.c" 3 4
     _Bool 
# 959 "rts/Capability.c"
          gcAllowed
    )
{
    Capability *cap = *pCap;

    if (gcAllowed)
    {
        PendingSync *sync = __atomic_load_n(&pending_sync, 5);

        if (sync) {
            switch (sync->type) {
            case SYNC_GC_PAR:
                if (! sync->idle[cap->no]) {
                    traceEventGcStart(cap);
                    gcWorkerThread(cap);
                    traceEventGcEnd(cap);
                    traceSparkCounters(cap);

                    if (task->cap == cap) {
                        return 
# 978 "rts/Capability.c" 3 4
                              1
# 978 "rts/Capability.c"
                                  ;
                    }
                }
                break;

            case SYNC_FLUSH_UPD_REM_SET:
                if (__builtin_expect((RtsFlags.DebugFlags.nonmoving_gc),0)) { trace_("Flushing update remembered set blocks..."); };
                break;

            case SYNC_FLUSH_EVENT_LOG:

                break;

            default:
                break;
            }
        }
    }

    if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("giving up capability %d", cap->no); };


    task->wakeup = 
# 1000 "rts/Capability.c" 3 4
                  0
# 1000 "rts/Capability.c"
                       ;

    { ; int __r = pthread_mutex_lock(&cap->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 1002, __r); } };


    if (isWorker(task)) {
        enqueueWorker(cap);
    }

    releaseCapability_(cap, 
# 1009 "rts/Capability.c" 3 4
                           0
# 1009 "rts/Capability.c"
                                );

    if (isWorker(task) || isBoundTask(task)) {
        ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",1012); };
        cap = waitForWorkerCapability(task);
    } else {





        newReturningTask(cap,task);
        ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",1021); };
        cap = waitForReturnCapability(task);
    }

    if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("resuming capability %d", cap->no); };
    if (__builtin_expect(!!(cap->running_task == task), 1)) ; else _assertFail("rts/Capability.c", 1026);


    cap->r.rCCCS = CCS_SYSTEM;


    *pCap = cap;

    if (__builtin_expect(!!(cap->running_task != 
# 1034 "rts/Capability.c" 3 4
   ((void *)0) 
# 1034 "rts/Capability.c"
   && cap->running_task == task), 1)) ; else _assertFail("rts/Capability.c", 1034); if (__builtin_expect(!!(task->cap == cap), 1)) ; else _assertFail("rts/Capability.c", 1034); if (__builtin_expect(!!(cap->run_queue_hd == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure) ? cap->run_queue_tl == ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure) && cap->n_run_queue == 0 : 1), 1)) ; else _assertFail("rts/Capability.c", 1034); if (__builtin_expect(!!(cap->suspended_ccalls == 
# 1034 "rts/Capability.c" 3 4
   ((void *)0) 
# 1034 "rts/Capability.c"
   ? cap->n_suspended_ccalls == 0 : 1), 1)) ; else _assertFail("rts/Capability.c", 1034); if (__builtin_expect(!!(myTask() == task), 1)) ; else _assertFail("rts/Capability.c", 1034); if (__builtin_expect(!!(task->id == osThreadId()), 1)) ; else _assertFail("rts/Capability.c", 1034);;

    return 
# 1036 "rts/Capability.c" 3 4
          0
# 1036 "rts/Capability.c"
               ;
}
# 1086 "rts/Capability.c"
void
prodCapability (Capability *cap, Task *task)
{
    { ; int __r = pthread_mutex_lock(&cap->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 1089, __r); } };
    if (!cap->running_task) {
        cap->running_task = task;
        releaseCapability_(cap,
# 1092 "rts/Capability.c" 3 4
                              1
# 1092 "rts/Capability.c"
                                  );
    }
    ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",1094); };
}
# 1108 "rts/Capability.c"

# 1108 "rts/Capability.c" 3 4
_Bool

# 1109 "rts/Capability.c"
tryGrabCapability (Capability *cap, Task *task)
{
    int r;

    ;
    if (__atomic_load_n(&cap->running_task, 0) != 
# 1114 "rts/Capability.c" 3 4
                                           ((void *)0)
# 1114 "rts/Capability.c"
                                               ) return 
# 1114 "rts/Capability.c" 3 4
                                                        0
# 1114 "rts/Capability.c"
                                                             ;

    r = OS_TRY_ACQUIRE_LOCK(&cap->lock);
    if (r != 0) return 
# 1117 "rts/Capability.c" 3 4
                      0
# 1117 "rts/Capability.c"
                           ;
    if (cap->running_task != 
# 1118 "rts/Capability.c" 3 4
                            ((void *)0)
# 1118 "rts/Capability.c"
                                ) {
        ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",1119); };
        return 
# 1120 "rts/Capability.c" 3 4
              0
# 1120 "rts/Capability.c"
                   ;
    }
    task->cap = cap;
    __atomic_store_n(&cap->running_task, task, 0);
    ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",1124); };
    return 
# 1125 "rts/Capability.c" 3 4
          1
# 1125 "rts/Capability.c"
              ;
}
# 1146 "rts/Capability.c"
static void
shutdownCapability (Capability *cap ,
                    Task *task ,
                    
# 1149 "rts/Capability.c" 3 4
                   _Bool 
# 1149 "rts/Capability.c"
                        safe )
{

    uint32_t i;

    task->cap = cap;







    for (i = 0; ; i++) {
        if (__builtin_expect(!!(sched_state == 2), 1)) ; else _assertFail("rts/Capability.c", 1163);

        if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("shutting down capability %d, attempt %d", cap->no, i); }
                                                                         ;
        { ; int __r = pthread_mutex_lock(&cap->lock); if (__r != 0) { barf("ACQUIRE_LOCK failed (%s:%d): %d", "rts/Capability.c", 1167, __r); } };
        if (cap->running_task) {
            ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",1169); };
            if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("not owner, yielding"); };
            yieldThread();
            continue;
        }
        cap->running_task = task;

        if (cap->spare_workers) {






            Task *t, *prev;
            prev = 
# 1184 "rts/Capability.c" 3 4
                  ((void *)0)
# 1184 "rts/Capability.c"
                      ;
            for (t = cap->spare_workers; t != 
# 1185 "rts/Capability.c" 3 4
                                             ((void *)0)
# 1185 "rts/Capability.c"
                                                 ; t = t->next) {
                if (!osThreadIsAlive(t->id)) {
                    if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("worker thread %p has died unexpectedly", (void *)(size_t)t->id); }
                                                                                               ;
                    cap->n_spare_workers--;
                    if (!prev) {
                        cap->spare_workers = t->next;
                    } else {
                        prev->next = t->next;
                    }
                    prev = t;
                }
            }
        }

        if (!emptyRunQueue(cap) || cap->spare_workers) {
            if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("runnable threads or workers still alive, yielding"); }
                                                                           ;
            releaseCapability_(cap,
# 1203 "rts/Capability.c" 3 4
                                  0
# 1203 "rts/Capability.c"
                                       );
            ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",1204); };
            yieldThread();
            continue;
        }







        if (cap->suspended_ccalls && safe) {
            if (__builtin_expect((RtsFlags.DebugFlags.scheduler),0)) { trace_("thread(s) are involved in foreign calls, yielding"); }
                                                                           ;
            cap->running_task = 
# 1218 "rts/Capability.c" 3 4
                               ((void *)0)
# 1218 "rts/Capability.c"
                                   ;
            ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",1219); };
# 1235 "rts/Capability.c"
            stopIOManager();
            yieldThread();
            continue;
        }

        traceSparkCounters(cap);
        ; if (pthread_mutex_unlock(&cap->lock) != 0) { barf("RELEASE_LOCK: I do not own this lock: %s %d", "rts/Capability.c",1241); };
        break;
    }
# 1252 "rts/Capability.c"
}

void
shutdownCapabilities(Task *task, 
# 1255 "rts/Capability.c" 3 4
                                _Bool 
# 1255 "rts/Capability.c"
                                     safe)
{
    uint32_t i;
    for (i=0; i < getNumCapabilities(); i++) {
        if (__builtin_expect(!!(task->incall->tso == 
# 1259 "rts/Capability.c" 3 4
       ((void *)0)
# 1259 "rts/Capability.c"
       ), 1)) ; else _assertFail("rts/Capability.c", 1259);
        shutdownCapability(capabilities[i], task, safe);
    }

    if (__builtin_expect(!!(checkSparkCountInvariant()), 1)) ; else _assertFail("rts/Capability.c", 1263);

}

static void
freeCapability (Capability *cap)
{
    stgFree(cap->mut_lists);
    stgFree(cap->saved_mut_lists);
    if (cap->current_segments) {
        stgFree(cap->current_segments);
    }

    freeSparkPool(cap->sparks);

    traceCapsetRemoveCap(((CapsetID)0), cap->no);
    traceCapsetRemoveCap(((CapsetID)1), cap->no);
    traceCapDelete(cap);
}

void
freeCapabilities (void)
{

    uint32_t i;
    for (i=0; i < getNumCapabilities(); i++) {
        freeCapability(capabilities[i]);
        if (capabilities[i] != &MainCapability)
            stgFreeAligned(capabilities[i]);
    }



    stgFree(capabilities);
    traceCapsetDelete(((CapsetID)0));
    traceCapsetDelete(((CapsetID)1));
}







void
markCapability (evac_fn evac, void *user, Capability *cap,
                
# 1309 "rts/Capability.c" 3 4
               _Bool 
# 1309 "rts/Capability.c"
                    no_mark_sparks )
{
    InCall *incall;






    evac(user, (StgClosure **)(void *)&cap->run_queue_hd);
    evac(user, (StgClosure **)(void *)&cap->run_queue_tl);

    evac(user, (StgClosure **)(void *)&cap->inbox);

    for (incall = cap->suspended_ccalls; incall != 
# 1323 "rts/Capability.c" 3 4
                                                  ((void *)0)
# 1323 "rts/Capability.c"
                                                      ;
         incall=incall->next) {
        evac(user, (StgClosure **)(void *)&incall->suspended_tso);
    }


    if (!no_mark_sparks) {
        traverseSparkQueue (evac, user, cap);
    }



    stmPreGCHook(cap);
}

void
markCapabilities (evac_fn evac, void *user)
{
    uint32_t n;
    for (n = 0; n < getNumCapabilities(); n++) {
        markCapability(evac, user, capabilities[n], 
# 1343 "rts/Capability.c" 3 4
                                                   0
# 1343 "rts/Capability.c"
                                                        );
    }
}



# 1348 "rts/Capability.c" 3 4
_Bool 
# 1348 "rts/Capability.c"
    checkSparkCountInvariant (void)
{
    SparkCounters sparks = { 0, 0, 0, 0, 0, 0 };
    StgWord64 remaining = 0;
    uint32_t i;

    for (i = 0; i < getNumCapabilities(); i++) {
        sparks.created += capabilities[i]->spark_stats.created;
        sparks.dud += capabilities[i]->spark_stats.dud;
        sparks.overflowed+= capabilities[i]->spark_stats.overflowed;
        sparks.converted += capabilities[i]->spark_stats.converted;
        sparks.gcd += capabilities[i]->spark_stats.gcd;
        sparks.fizzled += capabilities[i]->spark_stats.fizzled;
        remaining += sparkPoolSize(capabilities[i]->sparks);
    }




    if (__builtin_expect((RtsFlags.DebugFlags.sparks),0)) { trace_("spark invariant: %ld == %ld + %ld + %ld + %ld " "(created == converted + remaining + gcd + fizzled)", sparks.created, sparks.converted, remaining, sparks.gcd, sparks.fizzled); }


                                                       ;

    return (sparks.created ==
              sparks.converted + remaining + sparks.gcd + sparks.fizzled);

}
